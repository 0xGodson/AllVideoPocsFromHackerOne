{"id":925527,"global_id":"Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC85MjU1Mjc=","url":"https://hackerone.com/reports/925527","title":"Blind HTTP GET SSRF via website icon fetch (bypass of pull#812)","state":"Closed","substate":"resolved","severity_rating":"low","readable_substate":"Resolved","created_at":"2020-07-16T16:40:56.817Z","submitted_at":"2020-07-16T16:40:56.817Z","is_member_of_team?":false,"reporter":{"disabled":false,"username":"shielder","url":"/shielder","profile_picture_urls":{"small":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"is_me?":false,"cleared":false,"hackerone_triager":false,"hacker_mediation":false},"team":{"id":21024,"url":"https://hackerone.com/bitwarden","handle":"bitwarden","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/uHvBgHfLjcd9SPWDmjdYVf21/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a","medium":"https://profile-photos.hackerone-user-content.com/variants/uHvBgHfLjcd9SPWDmjdYVf21/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"permissions":[],"submission_state":"open","default_currency":"usd","awards_miles":false,"offers_bounties":false,"state":"public_mode","only_cleared_hackers":false,"profile":{"name":"Bitwarden","twitter_handle":"bitwarden","website":"https://bitwarden.com","about":"Open source password management solutions for individuals, teams, and business organizations."}},"has_bounty?":false,"in_validation?":false,"rejected_anc_report_that_can_be_sent_back_to_anc_triagers?":false,"can_view_team":true,"can_view_report":true,"is_external_bug":false,"is_published":false,"is_participant":false,"stage":4,"public":true,"visibility":"full","cve_ids":[],"singular_disclosure_disabled":false,"disclosed_at":"2020-09-11T13:24:08.854Z","bug_reporter_agreed_on_going_public_at":"2020-09-11T07:48:09.608Z","team_member_agreed_on_going_public_at":"2020-09-11T13:24:08.760Z","comments_closed?":false,"facebook_team?":false,"team_private?":false,"vulnerability_information":"After a credential has been added to vault.bitwarden.com (or any self-hosted installation), if the settings allow website icons to be fetched (https://bitwarden.com/help/article/website-icons/), the Bitwarden server will try to fetch the icon image.\n\nThe relevant source code is https://github.com/bitwarden/server/blob/master/src/Icons/Controllers/IconsController.cs#L42-L65 and https://github.com/bitwarden/server/blob/master/src/Icons/Services/IconFetchingService.cs#L59\nAs we can see in the second link, just the domain is used as entrypoint to retrieve the icon image. After trying both HTTPS and HTTP connections, if an HTTP redirect happens the backend will try to follow it, for a maximum of 2 times.\n\nThe merged pull request https://github.com/bitwarden/server/pull/812 (which seems based on the vulnerable code snippet available on https://stackoverflow.com/a/8113687) tries to prevent SSRF attacks by checking if the domain resolves to a private IP, but that protection can be bypassed because not all IPs are checked: for example \"0.0.0.0\" (which will request \"127.0.0.1\") or the private subnet \"169.254.0.0/16\" used in many cloud environments as metadata API (e.g. https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-retrieval.html) will pass that test and send the HTTP request to the private host.\n\n### Proof-of-concept\n0. Buy a domain and set it up on a server with a public IP address\n1. Setup a webserver on the domain, e.g. nginx\n2. Setup a malicious nameserver for the domain, I've used https://github.com/Crypt0s/FakeDns with the following configuration (change the domain name and IP with yours):\n\n```\nA www.yourdomain.com YOUR.PUBLIC.IP\nA .*.local.yourdomain.com 0.0.0.0\n```\n\n4. Create a redirect index page on the newly created webserver, e.g. (change the domain name with yours):\n\n```php\n\u003c?php\nheader(\"location: http://test.local.yourdomain.com/PATH_IS_KEPT\");\nexit();\n```\n\n3. Create a self-hosted Bitwarden instance following the instructions at https://bitwarden.com/help/article/install-on-premise/ and create an account\n4. Log-in via cli on the `icons` docker instance and setup a dummy TCP listener on port 80, this will confirm we can request arbitrary HTTP endpoints on 127.0.0.1 \n(**NOTE: i'm opening this socket just for PoC purposes -- of course the attacker wouldn't have such access however they could attack other locally-exposed services, such as the metadata API on 169.254.169.254**), e.g.:\n\n```\n# perl -MIO::Socket::INET -ne 'BEGIN{$l=IO::Socket::INET-\u003enew( LocalPort=\u003e80,Proto=\u003e\"tcp\",Listen=\u003e5,ReuseAddr=\u003e1); my $l=$l-\u003eaccept(); while(\u003c$l\u003e){ print $_; }; close($l);}'\n```\n\n5. Log-in Bitwarden and add a credential with URL \"www.yourdomain.com\" (change the domain name with yours)\n6. Notice the request at https://github.com/bitwarden/server/blob/master/src/Icons/Services/IconFetchingService.cs#L301-L314 arrives on the local TCP listener, e.g.:\n\n```\nroot@2efebadd421d:/app# perl -MIO::Socket::INET -ne 'BEGIN{$l=IO::Socket::INET-\u003enew( LocalPort=\u003e80,Proto=\u003e\"tcp\",Listen=\u003e5,ReuseAddr=\u003e1); my $l=$l-\u003eaccept(); while(\u003c$l\u003e){ print $_; }; close($l);}'\nGET /PATH_IS_KEPT HTTP/1.1\nHost: redacted\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 Edge/16.16299\nAccept-Language: en-US, en; q=0.8\nCache-Control: no-cache\nPragma: no-cache\nAccept: text/html, application/xhtml+xml, application/xml; q=0.9, image/webp, image/apng, */*; q=0.8\nRequest-Id: |3d01319c-4dccd9dac66f3032.3.\nAccept-Encoding: gzip, deflate\n\n^C\nroot@2efebadd421d:/app#\n```\n\n### Bonus potential bypass (unverified) \nIt could also be possible to bypass such check via a DNS resolution Time-of-check/Time-of-use (TOCTOU, https://cwe.mitre.org/data/definitions/367.html) attack, similarly to what was done in https://hackerone.com/reports/541169.\n\nBy controlling a domain name and its nameserver an attacker can reply to the first DNS A resolution (the private IP check in https://github.com/bitwarden/server/blob/master/src/Icons/Services/IconFetchingService.cs#L295) with a non-private IP address (with a very low TTL, such as 0, this way it is resolved again next time) to pass the check and then reply to the second DNS A resolution (the HTTP client DNS resolution triggered in https://github.com/bitwarden/server/blob/master/src/Icons/Services/IconFetchingService.cs#L318) with any IP they want. Doing so allows them to bypass again the new protection and use any IP they want for the HTTP request. \n\nHere's a step-by-step explanation of the attack:\n\n0. The malicious user inputs a credential with URL \"http://shielder.it\" (whose nameserver they control)\n1. Bitwarden's backend requests a name resolution for the domain to check if it is a private IP (1st resolution, in https://github.com/bitwarden/server/blob/master/src/Icons/Services/IconFetchingService.cs#L295)\n2. the attacker nameserver replies with any non-private IP, e.g. 8.8.8.8, with a low TTL, e.g. 0\n3. the Bitwarden backend checks it is not a private IP and tries to setup an HTTP request to it\n4. since the 1st resolution's TTL has now expired, the Bitwarden's server HTTP client resolves it again (2nd resolution, triggered by https://github.com/bitwarden/server/blob/master/src/Icons/Services/IconFetchingService.cs#L318)\n5. the malicious nameserver now replies with a private IP address, e.g. 10.10.10.3\n6. the Bitwarden backend sends a HTTP request using the last IP address, e.g. 10.10.10.3\n\nMoreover, the attacker has the ability to send HTTP GET requests to arbitrary endpoint through the redirect technique I have talked about above.\n\nAs said previously, I haven't verified this second attack can actually work, however I wanted to point out it **should** theoretically be possible.\n\n### Remediation\n\nHere are my suggestions for the attack scenarios i have presented:\n* Consider in the check all the potential private IPs which now pass it, for example I suggest to have a look at what GitLab does (it is Ruby code but readable) at https://gitlab.com/gitlab-org/gitlab-foss/-/blob/master/lib/gitlab/url_blocker.rb\n* Verify the DNS resolution is not perfomed again after the IP is checked, if possible \"lock\" the HTTP request to the verified IP address so it is not sent using an unverified IP address\n\n### Credits\nPlease credit \"polict of Shielder\" in your changelog/hall-of-fame for the discovery of this vulnerability.\n\n## Impact\n\nA malicious Bitwarden user can use the Bitwarden server to scan the local network and send arbitrary HTTP GET requests to a locally-exposed host, such as localhost or an endpoint in 169.254.0.0/16. The privilege to send such requests could potentially allow them to get hold of reserved information or escalate their privileges.","vulnerability_information_html":"\u003cp\u003eAfter a credential has been added to vault.bitwarden.com (or any self-hosted installation), if the settings allow website icons to be fetched (\u003ca title=\"https://bitwarden.com/help/article/website-icons/\" href=\"/redirect?url=https%3A%2F%2Fbitwarden.com%2Fhelp%2Farticle%2Fwebsite-icons%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://bitwarden.com/help/article/website-icons/\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e), the Bitwarden server will try to fetch the icon image.\u003c/p\u003e\n\n\u003cp\u003eThe relevant source code is \u003ca title=\"https://github.com/bitwarden/server/blob/master/src/Icons/Controllers/IconsController.cs#L42-L65\" href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fbitwarden%2Fserver%2Fblob%2Fmaster%2Fsrc%2FIcons%2FControllers%2FIconsController.cs%23L42-L65\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://github.com/bitwarden/server/blob/master/src/Icons/Controllers/IconsController.cs#L42-L65\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e and \u003ca title=\"https://github.com/bitwarden/server/blob/master/src/Icons/Services/IconFetchingService.cs#L59\" href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fbitwarden%2Fserver%2Fblob%2Fmaster%2Fsrc%2FIcons%2FServices%2FIconFetchingService.cs%23L59\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://github.com/bitwarden/server/blob/master/src/Icons/Services/IconFetchingService.cs#L59\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003cbr\u003e\nAs we can see in the second link, just the domain is used as entrypoint to retrieve the icon image. After trying both HTTPS and HTTP connections, if an HTTP redirect happens the backend will try to follow it, for a maximum of 2 times.\u003c/p\u003e\n\n\u003cp\u003eThe merged pull request \u003ca title=\"https://github.com/bitwarden/server/pull/812\" href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fbitwarden%2Fserver%2Fpull%2F812\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://github.com/bitwarden/server/pull/812\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e (which seems based on the vulnerable code snippet available on \u003ca title=\"https://stackoverflow.com/a/8113687\" href=\"/redirect?url=https%3A%2F%2Fstackoverflow.com%2Fa%2F8113687\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://stackoverflow.com/a/8113687\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e) tries to prevent SSRF attacks by checking if the domain resolves to a private IP, but that protection can be bypassed because not all IPs are checked: for example \u0026quot;0.0.0.0\u0026quot; (which will request \u0026quot;127.0.0.1\u0026quot;) or the private subnet \u0026quot;169.254.0.0/16\u0026quot; used in many cloud environments as metadata API (e.g. \u003ca title=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-retrieval.html\" href=\"/redirect?url=https%3A%2F%2Fdocs.aws.amazon.com%2FAWSEC2%2Flatest%2FUserGuide%2Finstancedata-data-retrieval.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-retrieval.html\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e) will pass that test and send the HTTP request to the private host.\u003c/p\u003e\n\n\u003ch3 id=\"proof-of-concept\"\u003eProof-of-concept\u003c/h3\u003e\n\n\u003col\u003e\n\u003cli\u003eBuy a domain and set it up on a server with a public IP address\u003c/li\u003e\n\u003cli\u003eSetup a webserver on the domain, e.g. nginx\u003c/li\u003e\n\u003cli\u003eSetup a malicious nameserver for the domain, I\u0026#39;ve used \u003ca title=\"https://github.com/Crypt0s/FakeDns\" href=\"/redirect?url=https%3A%2F%2Fgithub.com%2FCrypt0s%2FFakeDns\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://github.com/Crypt0s/FakeDns\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e with the following configuration (change the domain name and IP with yours):\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003eA www.yourdomain.com YOUR.PUBLIC.IP\nA .*.local.yourdomain.com 0.0.0.0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003col\u003e\n\u003cli\u003eCreate a redirect index page on the newly created webserver, e.g. (change the domain name with yours):\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight php\"\u003e\u003ccode\u003e\u003cspan class=\"cp\"\u003e\u0026lt;?php\u003c/span\u003e\n\u003cspan class=\"nb\"\u003eheader\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026quot;location: http://test.local.yourdomain.com/PATH_IS_KEPT\u0026quot;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"k\"\u003eexit\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003col\u003e\n\u003cli\u003eCreate a self-hosted Bitwarden instance following the instructions at \u003ca title=\"https://bitwarden.com/help/article/install-on-premise/\" href=\"/redirect?url=https%3A%2F%2Fbitwarden.com%2Fhelp%2Farticle%2Finstall-on-premise%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://bitwarden.com/help/article/install-on-premise/\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e and create an account\u003c/li\u003e\n\u003cli\u003eLog-in via cli on the \u003ccode\u003eicons\u003c/code\u003e docker instance and setup a dummy TCP listener on port 80, this will confirm we can request arbitrary HTTP endpoints on 127.0.0.1 \n(\u003cstrong\u003eNOTE: i\u0026#39;m opening this socket just for PoC purposes -- of course the attacker wouldn\u0026#39;t have such access however they could attack other locally-exposed services, such as the metadata API on 169.254.169.254\u003c/strong\u003e), e.g.:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e# perl -MIO::Socket::INET -ne \u0026#39;BEGIN{$l=IO::Socket::INET-\u0026gt;new( LocalPort=\u0026gt;80,Proto=\u0026gt;\u0026quot;tcp\u0026quot;,Listen=\u0026gt;5,ReuseAddr=\u0026gt;1); my $l=$l-\u0026gt;accept(); while(\u0026lt;$l\u0026gt;){ print $_; }; close($l);}\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003col\u003e\n\u003cli\u003eLog-in Bitwarden and add a credential with URL \u0026quot;\u003ca href=\"/redirect?url=http%3A%2F%2Fwww.yourdomain.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ewww.yourdomain.com\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u0026quot; (change the domain name with yours)\u003c/li\u003e\n\u003cli\u003eNotice the request at \u003ca title=\"https://github.com/bitwarden/server/blob/master/src/Icons/Services/IconFetchingService.cs#L301-L314\" href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fbitwarden%2Fserver%2Fblob%2Fmaster%2Fsrc%2FIcons%2FServices%2FIconFetchingService.cs%23L301-L314\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://github.com/bitwarden/server/blob/master/src/Icons/Services/IconFetchingService.cs#L301-L314\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e arrives on the local TCP listener, e.g.:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003eroot@2efebadd421d:/app# perl -MIO::Socket::INET -ne \u0026#39;BEGIN{$l=IO::Socket::INET-\u0026gt;new( LocalPort=\u0026gt;80,Proto=\u0026gt;\u0026quot;tcp\u0026quot;,Listen=\u0026gt;5,ReuseAddr=\u0026gt;1); my $l=$l-\u0026gt;accept(); while(\u0026lt;$l\u0026gt;){ print $_; }; close($l);}\u0026#39;\nGET /PATH_IS_KEPT HTTP/1.1\nHost: redacted\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 Edge/16.16299\nAccept-Language: en-US, en; q=0.8\nCache-Control: no-cache\nPragma: no-cache\nAccept: text/html, application/xhtml+xml, application/xml; q=0.9, image/webp, image/apng, */*; q=0.8\nRequest-Id: |3d01319c-4dccd9dac66f3032.3.\nAccept-Encoding: gzip, deflate\n\n^C\nroot@2efebadd421d:/app#\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch3 id=\"bonus-potential-bypass-unverified\"\u003eBonus potential bypass (unverified)\u003c/h3\u003e\n\n\u003cp\u003eIt could also be possible to bypass such check via a DNS resolution Time-of-check/Time-of-use (TOCTOU, \u003ca title=\"https://cwe.mitre.org/data/definitions/367.html\" href=\"/redirect?url=https%3A%2F%2Fcwe.mitre.org%2Fdata%2Fdefinitions%2F367.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://cwe.mitre.org/data/definitions/367.html\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e) attack, similarly to what was done in \u003ca title=\"https://hackerone.com/reports/541169\" href=\"https://hackerone.com/reports/541169\"\u003ehttps://hackerone.com/reports/541169\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eBy controlling a domain name and its nameserver an attacker can reply to the first DNS A resolution (the private IP check in \u003ca title=\"https://github.com/bitwarden/server/blob/master/src/Icons/Services/IconFetchingService.cs#L295\" href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fbitwarden%2Fserver%2Fblob%2Fmaster%2Fsrc%2FIcons%2FServices%2FIconFetchingService.cs%23L295\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://github.com/bitwarden/server/blob/master/src/Icons/Services/IconFetchingService.cs#L295\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e) with a non-private IP address (with a very low TTL, such as 0, this way it is resolved again next time) to pass the check and then reply to the second DNS A resolution (the HTTP client DNS resolution triggered in \u003ca title=\"https://github.com/bitwarden/server/blob/master/src/Icons/Services/IconFetchingService.cs#L318\" href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fbitwarden%2Fserver%2Fblob%2Fmaster%2Fsrc%2FIcons%2FServices%2FIconFetchingService.cs%23L318\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://github.com/bitwarden/server/blob/master/src/Icons/Services/IconFetchingService.cs#L318\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e) with any IP they want. Doing so allows them to bypass again the new protection and use any IP they want for the HTTP request. \u003c/p\u003e\n\n\u003cp\u003eHere\u0026#39;s a step-by-step explanation of the attack:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eThe malicious user inputs a credential with URL \u0026quot;\u003ca title=\"http://shielder.it\" href=\"/redirect?url=http%3A%2F%2Fshielder.it\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttp://shielder.it\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u0026quot; (whose nameserver they control)\u003c/li\u003e\n\u003cli\u003eBitwarden\u0026#39;s backend requests a name resolution for the domain to check if it is a private IP (1st resolution, in \u003ca title=\"https://github.com/bitwarden/server/blob/master/src/Icons/Services/IconFetchingService.cs#L295\" href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fbitwarden%2Fserver%2Fblob%2Fmaster%2Fsrc%2FIcons%2FServices%2FIconFetchingService.cs%23L295\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://github.com/bitwarden/server/blob/master/src/Icons/Services/IconFetchingService.cs#L295\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e)\u003c/li\u003e\n\u003cli\u003ethe attacker nameserver replies with any non-private IP, e.g. 8.8.8.8, with a low TTL, e.g. 0\u003c/li\u003e\n\u003cli\u003ethe Bitwarden backend checks it is not a private IP and tries to setup an HTTP request to it\u003c/li\u003e\n\u003cli\u003esince the 1st resolution\u0026#39;s TTL has now expired, the Bitwarden\u0026#39;s server HTTP client resolves it again (2nd resolution, triggered by \u003ca title=\"https://github.com/bitwarden/server/blob/master/src/Icons/Services/IconFetchingService.cs#L318\" href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fbitwarden%2Fserver%2Fblob%2Fmaster%2Fsrc%2FIcons%2FServices%2FIconFetchingService.cs%23L318\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://github.com/bitwarden/server/blob/master/src/Icons/Services/IconFetchingService.cs#L318\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e)\u003c/li\u003e\n\u003cli\u003ethe malicious nameserver now replies with a private IP address, e.g. 10.10.10.3\u003c/li\u003e\n\u003cli\u003ethe Bitwarden backend sends a HTTP request using the last IP address, e.g. 10.10.10.3\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eMoreover, the attacker has the ability to send HTTP GET requests to arbitrary endpoint through the redirect technique I have talked about above.\u003c/p\u003e\n\n\u003cp\u003eAs said previously, I haven\u0026#39;t verified this second attack can actually work, however I wanted to point out it \u003cstrong\u003eshould\u003c/strong\u003e theoretically be possible.\u003c/p\u003e\n\n\u003ch3 id=\"remediation\"\u003eRemediation\u003c/h3\u003e\n\n\u003cp\u003eHere are my suggestions for the attack scenarios i have presented:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eConsider in the check all the potential private IPs which now pass it, for example I suggest to have a look at what GitLab does (it is Ruby code but readable) at \u003ca title=\"https://gitlab.com/gitlab-org/gitlab-foss/-/blob/master/lib/gitlab/url_blocker.rb\" href=\"/redirect?url=https%3A%2F%2Fgitlab.com%2Fgitlab-org%2Fgitlab-foss%2F-%2Fblob%2Fmaster%2Flib%2Fgitlab%2Furl_blocker.rb\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://gitlab.com/gitlab-org/gitlab-foss/-/blob/master/lib/gitlab/url_blocker.rb\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003eVerify the DNS resolution is not perfomed again after the IP is checked, if possible \u0026quot;lock\u0026quot; the HTTP request to the verified IP address so it is not sent using an unverified IP address\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"credits\"\u003eCredits\u003c/h3\u003e\n\n\u003cp\u003ePlease credit \u0026quot;polict of Shielder\u0026quot; in your changelog/hall-of-fame for the discovery of this vulnerability.\u003c/p\u003e\n\n\u003ch2 id=\"impact\"\u003eImpact\u003c/h2\u003e\n\n\u003cp\u003eA malicious Bitwarden user can use the Bitwarden server to scan the local network and send arbitrary HTTP GET requests to a locally-exposed host, such as localhost or an endpoint in 169.254.0.0/16. The privilege to send such requests could potentially allow them to get hold of reserved information or escalate their privileges.\u003c/p\u003e\n","weakness":{"id":68,"name":"Server-Side Request Forgery (SSRF)"},"original_report_id":null,"original_report_url":null,"attachments":[],"allow_singular_disclosure_at":"2020-10-11T07:48:09.666Z","allow_singular_disclosure_after":-6823430.439754198,"singular_disclosure_allowed":true,"vote_count":18,"voters":["x86scale","demonia","codeur","m7mdharoun","smaury","b69fb2ebda43240ece9dbeb","vaibhavprajapati","its_pyro","breathingduke","hsbyter","and 8 more..."],"severity":{"rating":"low","author_type":"Team"},"structured_scope":{"databaseId":773,"asset_type":"SOURCE_CODE","asset_identifier":"https://github.com/bitwarden","max_severity":"critical"},"abilities":{"assignable_team_members":[],"assignable_team_member_groups":[]},"can_edit_custom_fields_attributes":false,"activities":[{"id":8622485,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Hi, thank you for the report. What version of the Bitwarden server are you testing with? The `Dns.GetHostEntry` checks that you are referencing in `master` have not yet been released. I do not beleive that the `HttpRequestMessage` you reference should not be following redirects as you suggest.","markdown_message":"\u003cp\u003eHi, thank you for the report. What version of the Bitwarden server are you testing with? The \u003ccode\u003eDns.GetHostEntry\u003c/code\u003e checks that you are referencing in \u003ccode\u003emaster\u003c/code\u003e have not yet been released. I do not beleive that the \u003ccode\u003eHttpRequestMessage\u003c/code\u003e you reference should not be following redirects as you suggest.\u003c/p\u003e\n","automated_response":false,"created_at":"2020-07-16T19:39:33.275Z","updated_at":"2020-07-16T19:39:33.275Z","actor":{"username":"kspearrin","cleared":false,"url":"/kspearrin","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/NfF9KdzShJTHMmhSb4ajYq1p/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"bitwarden","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":8622488,"is_internal":false,"editable":false,"type":"Activities::BugNeedsMoreInfo","message":"","markdown_message":"","automated_response":false,"created_at":"2020-07-16T19:39:44.992Z","updated_at":"2020-07-16T19:39:44.992Z","actor":{"username":"kspearrin","cleared":false,"url":"/kspearrin","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/NfF9KdzShJTHMmhSb4ajYq1p/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"bitwarden","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":8625703,"is_internal":false,"editable":false,"type":"Activities::BugNew","message":"Hi @kspearrin and thanks for the quick reply.\n\nI have tested it using both the hard-coded version in the \"self-deploy\" script (`$coreVersion = \"1.35.1\" and $webVersion = \"2.15.1\"` at https://raw.githubusercontent.com/bitwarden/server/master/scripts/bitwarden.ps1) and also by manually editing the generated DockerCompose file to use the `dev` build of the Icons service (specifically I am using the build https://hub.docker.com/layers/bitwarden/icons/dev/images/sha256-1f88d913e835f457ca5302801afa601baa09947f10349c1baf691920ce558a0b?context=explore). I'm pretty sure such build contains https://github.com/bitwarden/server/pull/812 because if I use `127.0.0.1.xip.io` (which resolves to 127.0.0.1) as website domain the icon's HTTP request is not sent, I guess because this check fails https://github.com/bitwarden/server/blob/master/src/Icons/Services/IconFetchingService.cs#L418. However let me know if I should create the environment in another way and I'll re-test it ASAP.\n\nRegarding the second point I'm not sure I have correctly understood what you mean: can you reformulate?","markdown_message":"\u003cp\u003eHi \u003ca href=\"/kspearrin\"\u003e@kspearrin\u003c/a\u003e and thanks for the quick reply.\u003c/p\u003e\n\n\u003cp\u003eI have tested it using both the hard-coded version in the \u0026quot;self-deploy\u0026quot; script (\u003ccode\u003e$coreVersion = \u0026quot;1.35.1\u0026quot; and $webVersion = \u0026quot;2.15.1\u0026quot;\u003c/code\u003e at \u003ca title=\"https://raw.githubusercontent.com/bitwarden/server/master/scripts/bitwarden.ps1\" href=\"/redirect?url=https%3A%2F%2Fraw.githubusercontent.com%2Fbitwarden%2Fserver%2Fmaster%2Fscripts%2Fbitwarden.ps1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://raw.githubusercontent.com/bitwarden/server/master/scripts/bitwarden.ps1\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e) and also by manually editing the generated DockerCompose file to use the \u003ccode\u003edev\u003c/code\u003e build of the Icons service (specifically I am using the build \u003ca title=\"https://hub.docker.com/layers/bitwarden/icons/dev/images/sha256-1f88d913e835f457ca5302801afa601baa09947f10349c1baf691920ce558a0b?context=explore\" href=\"/redirect?url=https%3A%2F%2Fhub.docker.com%2Flayers%2Fbitwarden%2Ficons%2Fdev%2Fimages%2Fsha256-1f88d913e835f457ca5302801afa601baa09947f10349c1baf691920ce558a0b%3Fcontext%3Dexplore\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://hub.docker.com/layers/bitwarden/icons/dev/images/sha256-1f88d913e835f457ca5302801afa601baa09947f10349c1baf691920ce558a0b?context=explore\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e). I\u0026#39;m pretty sure such build contains \u003ca title=\"https://github.com/bitwarden/server/pull/812\" href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fbitwarden%2Fserver%2Fpull%2F812\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://github.com/bitwarden/server/pull/812\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e because if I use \u003ccode\u003e127.0.0.1.xip.io\u003c/code\u003e (which resolves to 127.0.0.1) as website domain the icon\u0026#39;s HTTP request is not sent, I guess because this check fails \u003ca title=\"https://github.com/bitwarden/server/blob/master/src/Icons/Services/IconFetchingService.cs#L418\" href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fbitwarden%2Fserver%2Fblob%2Fmaster%2Fsrc%2FIcons%2FServices%2FIconFetchingService.cs%23L418\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://github.com/bitwarden/server/blob/master/src/Icons/Services/IconFetchingService.cs#L418\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e. However let me know if I should create the environment in another way and I\u0026#39;ll re-test it ASAP.\u003c/p\u003e\n\n\u003cp\u003eRegarding the second point I\u0026#39;m not sure I have correctly understood what you mean: can you reformulate?\u003c/p\u003e\n","automated_response":false,"created_at":"2020-07-17T07:30:07.309Z","updated_at":"2020-07-17T07:30:07.309Z","actor":{"username":"shielder","cleared":false,"url":"/shielder","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"bitwarden","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":8628872,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Thanks for verifying. If I understand correctly, in your attack you have a domain that resolves a public IP address and then redirects (location header) to `test.local.yourdomain.com` which resolves a localhost IP. We also do the internal IP checks on location header follows so I am a bit confused about how this gets by those checks.","markdown_message":"\u003cp\u003eThanks for verifying. If I understand correctly, in your attack you have a domain that resolves a public IP address and then redirects (location header) to \u003ccode\u003etest.local.yourdomain.com\u003c/code\u003e which resolves a localhost IP. We also do the internal IP checks on location header follows so I am a bit confused about how this gets by those checks.\u003c/p\u003e\n","automated_response":false,"created_at":"2020-07-17T12:00:10.037Z","updated_at":"2020-07-17T12:00:10.037Z","actor":{"username":"kspearrin","cleared":false,"url":"/kspearrin","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/NfF9KdzShJTHMmhSb4ajYq1p/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"bitwarden","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":8629496,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"That's correct, but the problem is that those checks don't cover all possible private IPs. As I've mentioned earlier for example \"0.0.0.0\" (which in this context means \"all IPv4s addresses on the local machine\", https://en.wikipedia.org/wiki/0.0.0.0#As_a_host_address) will pass the checks performed in `IsInternal` and it will be used in the HTTP request, sending that request to 127.0.0.1, even though that should not be possible. In particular, the `IPAddress.IsLoopback` API doesn't consider it: \"In the case of IPv4, that the IsLoopback method returns true for any IP address of the form 127.X.Y.Z (where X, Y, and Z are in the range 0-255), not just Loopback (127.0.0.1).\" from https://docs.microsoft.com/en-gb/dotnet/api/system.net.ipaddress.isloopback?view=netcore-3.1. \n\nAnother \"private\" IP address which passes the checks is 169.254.169.254 (any IP in 169.254.0.0/16 actually), but it shouldn't because in many cloud environments that subnet is used for the metadata API (e.g. Amazon AWS https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-retrieval.html), so in case the self-hosted Bitwarden is deployed there an attacker can interact with the API and potentially elevate its privileges.\n\nThe HTTP redirect handling logic is not the problem here. I have used it just to gain the privilege of defining the `path` of the URL requested, because the first HTTP requests are done using only the `host` portion of the URL, and they wouldn't be of much value to an attacker by themselves if they want to interact meaningfully with another locally-available API.","markdown_message":"\u003cp\u003eThat\u0026#39;s correct, but the problem is that those checks don\u0026#39;t cover all possible private IPs. As I\u0026#39;ve mentioned earlier for example \u0026quot;0.0.0.0\u0026quot; (which in this context means \u0026quot;all IPv4s addresses on the local machine\u0026quot;, \u003ca title=\"https://en.wikipedia.org/wiki/0.0.0.0#As_a_host_address\" href=\"/redirect?url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2F0.0.0.0%23As_a_host_address\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://en.wikipedia.org/wiki/0.0.0.0#As_a_host_address\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e) will pass the checks performed in \u003ccode\u003eIsInternal\u003c/code\u003e and it will be used in the HTTP request, sending that request to 127.0.0.1, even though that should not be possible. In particular, the \u003ccode\u003eIPAddress.IsLoopback\u003c/code\u003e API doesn\u0026#39;t consider it: \u0026quot;In the case of IPv4, that the IsLoopback method returns true for any IP address of the form 127.X.Y.Z (where X, Y, and Z are in the range 0-255), not just Loopback (127.0.0.1).\u0026quot; from \u003ca title=\"https://docs.microsoft.com/en-gb/dotnet/api/system.net.ipaddress.isloopback?view=netcore-3.1\" href=\"/redirect?url=https%3A%2F%2Fdocs.microsoft.com%2Fen-gb%2Fdotnet%2Fapi%2Fsystem.net.ipaddress.isloopback%3Fview%3Dnetcore-3.1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://docs.microsoft.com/en-gb/dotnet/api/system.net.ipaddress.isloopback?view=netcore-3.1\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e. \u003c/p\u003e\n\n\u003cp\u003eAnother \u0026quot;private\u0026quot; IP address which passes the checks is 169.254.169.254 (any IP in 169.254.0.0/16 actually), but it shouldn\u0026#39;t because in many cloud environments that subnet is used for the metadata API (e.g. Amazon AWS \u003ca title=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-retrieval.html\" href=\"/redirect?url=https%3A%2F%2Fdocs.aws.amazon.com%2FAWSEC2%2Flatest%2FUserGuide%2Finstancedata-data-retrieval.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-retrieval.html\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e), so in case the self-hosted Bitwarden is deployed there an attacker can interact with the API and potentially elevate its privileges.\u003c/p\u003e\n\n\u003cp\u003eThe HTTP redirect handling logic is not the problem here. I have used it just to gain the privilege of defining the \u003ccode\u003epath\u003c/code\u003e of the URL requested, because the first HTTP requests are done using only the \u003ccode\u003ehost\u003c/code\u003e portion of the URL, and they wouldn\u0026#39;t be of much value to an attacker by themselves if they want to interact meaningfully with another locally-available API.\u003c/p\u003e\n","automated_response":false,"created_at":"2020-07-17T13:04:18.741Z","updated_at":"2020-07-17T13:04:18.741Z","actor":{"username":"shielder","cleared":false,"url":"/shielder","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"bitwarden","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":8629931,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"So I think we just need to add more IP ranges to the IsInternal check? Both `0.0.0.0` and `169.254.0.0/16`?","markdown_message":"\u003cp\u003eSo I think we just need to add more IP ranges to the IsInternal check? Both \u003ccode\u003e0.0.0.0\u003c/code\u003e and \u003ccode\u003e169.254.0.0/16\u003c/code\u003e?\u003c/p\u003e\n","automated_response":false,"created_at":"2020-07-17T14:00:48.188Z","updated_at":"2020-07-17T14:00:48.188Z","actor":{"username":"kspearrin","cleared":false,"url":"/kspearrin","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/NfF9KdzShJTHMmhSb4ajYq1p/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"bitwarden","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":8630428,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Exactly, this way private IPv4 addresses should all be covered. About IPv6 addresses I suggest adding to the check all the IPv6 prefixes written in https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html#application-layer_1:\n```python \ndef is_private_ip(ip_address):\n    is_private = False\n    \"\"\"\n    Determine if a IP address provided is a private one.\n    Return TRUE if it's the case, FALSE otherwise.\n    \"\"\"\n    # Build the list of IP prefix for V4 and V6 addresses\n    ip_prefix = []\n    [...]\n    # Add IP V6 prefix for private addresses\n    # See https://en.wikipedia.org/wiki/Unique_local_address\n    # See https://en.wikipedia.org/wiki/Private_network\n    # See https://simpledns.com/private-ipv6\n    ip_prefix.append(\"fc\")\n    ip_prefix.append(\"fd\")\n    ip_prefix.append(\"fe\")\n    ip_prefix.append(\"ff\")\n    ip_prefix.append(\"::1\")\n    # Verify the provided IP address\n    # Remove whitespace characters from the beginning/end of the string\n    # and convert it to lower case\n    # Lower case is for preventing any IPV6 case bypass using mixed case\n    # depending on the source used to get the IP address\n    ip_to_verify = ip_address.strip().lower()\n    # Perform the check against the list of prefix\n    for prefix in ip_prefix:\n        if ip_to_verify.startswith(prefix):\n            is_private = True\n            break\n    return is_private\n```\n","markdown_message":"\u003cp\u003eExactly, this way private IPv4 addresses should all be covered. About IPv6 addresses I suggest adding to the check all the IPv6 prefixes written in \u003ca title=\"https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html#application-layer_1:\" href=\"/redirect?url=https%3A%2F%2Fcheatsheetseries.owasp.org%2Fcheatsheets%2FServer_Side_Request_Forgery_Prevention_Cheat_Sheet.html%23application-layer_1%3A\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html#application-layer_1:\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight python\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"nf\"\u003eis_private_ip\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eip_address\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eis_private\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"bp\"\u003eFalse\u003c/span\u003e\n    \u003cspan class=\"s\"\u003e\u0026quot;\u0026quot;\u0026quot;\n    Determine if a IP address provided is a private one.\n    Return TRUE if it\u0026#39;s the case, FALSE otherwise.\n    \u0026quot;\u0026quot;\u0026quot;\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e# Build the list of IP prefix for V4 and V6 addresses\n\u003c/span\u003e    \u003cspan class=\"n\"\u003eip_prefix\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[]\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e# Add IP V6 prefix for private addresses\n\u003c/span\u003e    \u003cspan class=\"c1\"\u003e# See https://en.wikipedia.org/wiki/Unique_local_address\n\u003c/span\u003e    \u003cspan class=\"c1\"\u003e# See https://en.wikipedia.org/wiki/Private_network\n\u003c/span\u003e    \u003cspan class=\"c1\"\u003e# See https://simpledns.com/private-ipv6\n\u003c/span\u003e    \u003cspan class=\"n\"\u003eip_prefix\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eappend\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026quot;fc\u0026quot;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eip_prefix\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eappend\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026quot;fd\u0026quot;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eip_prefix\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eappend\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026quot;fe\u0026quot;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eip_prefix\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eappend\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026quot;ff\u0026quot;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eip_prefix\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eappend\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026quot;::1\u0026quot;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e# Verify the provided IP address\n\u003c/span\u003e    \u003cspan class=\"c1\"\u003e# Remove whitespace characters from the beginning/end of the string\n\u003c/span\u003e    \u003cspan class=\"c1\"\u003e# and convert it to lower case\n\u003c/span\u003e    \u003cspan class=\"c1\"\u003e# Lower case is for preventing any IPV6 case bypass using mixed case\n\u003c/span\u003e    \u003cspan class=\"c1\"\u003e# depending on the source used to get the IP address\n\u003c/span\u003e    \u003cspan class=\"n\"\u003eip_to_verify\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eip_address\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003estrip\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003elower\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e# Perform the check against the list of prefix\n\u003c/span\u003e    \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003eprefix\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003eip_prefix\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003eip_to_verify\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003estartswith\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eprefix\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eis_private\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"bp\"\u003eTrue\u003c/span\u003e\n            \u003cspan class=\"k\"\u003ebreak\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eis_private\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","automated_response":false,"created_at":"2020-07-17T14:52:00.647Z","updated_at":"2020-07-17T14:52:00.647Z","actor":{"username":"shielder","cleared":false,"url":"/shielder","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"bitwarden","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":8630876,"is_internal":false,"editable":false,"type":"Activities::ReportSeverityUpdated","message":"","markdown_message":"","automated_response":false,"created_at":"2020-07-17T15:52:09.711Z","updated_at":"2020-07-17T15:52:09.711Z","additional_data":{"old_severity":null,"new_severity":"Low","old_severity_id":null,"new_severity_id":782682},"actor":{"username":"kspearrin","cleared":false,"url":"/kspearrin","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/NfF9KdzShJTHMmhSb4ajYq1p/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"bitwarden","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":8630877,"is_internal":false,"editable":false,"type":"Activities::BugTriaged","message":"Thanks for the reference. Please see https://github.com/bitwarden/server/pull/827 to verify the fix.","markdown_message":"\u003cp\u003eThanks for the reference. Please see \u003ca title=\"https://github.com/bitwarden/server/pull/827\" href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fbitwarden%2Fserver%2Fpull%2F827\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://github.com/bitwarden/server/pull/827\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e to verify the fix.\u003c/p\u003e\n","automated_response":false,"created_at":"2020-07-17T15:52:12.363Z","updated_at":"2020-07-17T15:52:12.363Z","actor":{"username":"kspearrin","cleared":false,"url":"/kspearrin","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/NfF9KdzShJTHMmhSb4ajYq1p/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"bitwarden","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":8631910,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Were you able to validate DNS 0-TTL attack theory? My assumption is that with the initial check via DNS we're likely getting dotnet Core's System.Net internal DNS resolver cache which from my understanding doesn't respect much, including TTL, the time-to-execution, even if extended beyond 10 to 100ms between the initial DNS query to the time of execution (which will ultimately use dotnet's internal DNS resolver cache) will likely not hit a cache-miss and will use the original IP address (this would need to be tested) but I feel this would be a pretty small attack vector. To my understanding most folks actually have a harder time getting dotnet to dump it's internal DNS resolver cache vs. the other way around (too many repetitive DNS queries).","markdown_message":"\u003cp\u003eWere you able to validate DNS 0-TTL attack theory? My assumption is that with the initial check via DNS we\u0026#39;re likely getting dotnet Core\u0026#39;s System.Net internal DNS resolver cache which from my understanding doesn\u0026#39;t respect much, including TTL, the time-to-execution, even if extended beyond 10 to 100ms between the initial DNS query to the time of execution (which will ultimately use dotnet\u0026#39;s internal DNS resolver cache) will likely not hit a cache-miss and will use the original IP address (this would need to be tested) but I feel this would be a pretty small attack vector. To my understanding most folks actually have a harder time getting dotnet to dump it\u0026#39;s internal DNS resolver cache vs. the other way around (too many repetitive DNS queries).\u003c/p\u003e\n","automated_response":false,"created_at":"2020-07-17T16:08:21.129Z","updated_at":"2020-07-17T16:08:41.880Z","actor":{"username":"chadscharf","cleared":false,"url":"/chadscharf","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/y7jahHdm66MGJNS9dmHCvJns/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"bitwarden","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":8640376,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"@kspearrin, I think this `return false;` should be a `return true;` because it is one of the localhost IPv6 address rapresentations (https://en.wikipedia.org/wiki/IPv6_address#Local_addresses): https://github.com/bitwarden/server/blob/52554d0443e147613308fb6813c0e3436dca36a4/src/Icons/Services/IconFetchingService.cs#L426 Moreover I'd add in the same `if` block also the check for `::`, which is equivalent to `::1` but would pass those checks at the moment (even with the correct return). Besides these changes it looks good to me!\n\n@chadscharf, yes I have tried it yesterday without success, I guess your explanation is correct and hence it is not really exploitable at the moment. Nonetheless, maybe it could be a good idea to add a comment in the code about it to prevent future changes from making it exploitable -- what do you think?","markdown_message":"\u003cp\u003e\u003ca href=\"/kspearrin\"\u003e@kspearrin\u003c/a\u003e, I think this \u003ccode\u003ereturn false;\u003c/code\u003e should be a \u003ccode\u003ereturn true;\u003c/code\u003e because it is one of the localhost IPv6 address rapresentations (\u003ca title=\"https://en.wikipedia.org/wiki/IPv6_address#Local_addresses):\" href=\"/redirect?url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FIPv6_address%23Local_addresses%29%3A\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://en.wikipedia.org/wiki/IPv6_address#Local_addresses):\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e \u003ca title=\"https://github.com/bitwarden/server/blob/52554d0443e147613308fb6813c0e3436dca36a4/src/Icons/Services/IconFetchingService.cs#L426\" href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fbitwarden%2Fserver%2Fblob%2F52554d0443e147613308fb6813c0e3436dca36a4%2Fsrc%2FIcons%2FServices%2FIconFetchingService.cs%23L426\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://github.com/bitwarden/server/blob/52554d0443e147613308fb6813c0e3436dca36a4/src/Icons/Services/IconFetchingService.cs#L426\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e Moreover I\u0026#39;d add in the same \u003ccode\u003eif\u003c/code\u003e block also the check for \u003ccode\u003e::\u003c/code\u003e, which is equivalent to \u003ccode\u003e::1\u003c/code\u003e but would pass those checks at the moment (even with the correct return). Besides these changes it looks good to me!\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"/chadscharf\"\u003e@chadscharf\u003c/a\u003e, yes I have tried it yesterday without success, I guess your explanation is correct and hence it is not really exploitable at the moment. Nonetheless, maybe it could be a good idea to add a comment in the code about it to prevent future changes from making it exploitable -- what do you think?\u003c/p\u003e\n","automated_response":false,"created_at":"2020-07-18T10:54:09.953Z","updated_at":"2020-07-18T10:54:09.953Z","actor":{"username":"shielder","cleared":false,"url":"/shielder","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"bitwarden","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":8640695,"is_internal":false,"editable":false,"type":"Activities::BugResolved","message":"Thanks. The fix will be available in the next release.","markdown_message":"\u003cp\u003eThanks. The fix will be available in the next release.\u003c/p\u003e\n","automated_response":false,"created_at":"2020-07-18T12:08:18.787Z","updated_at":"2020-07-18T12:08:18.787Z","actor":{"username":"kspearrin","cleared":false,"url":"/kspearrin","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/NfF9KdzShJTHMmhSb4ajYq1p/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":null},"reporter":{"username":"shielder","url":"/shielder"},"genius_execution_id":null,"team_handle":"bitwarden","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":9188000,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"Can we disclose?","markdown_message":"\u003cp\u003eCan we disclose?\u003c/p\u003e\n","automated_response":false,"created_at":"2020-09-11T07:48:09.633Z","updated_at":"2020-09-11T07:48:09.633Z","first_to_agree":true,"actor":{"username":"shielder","cleared":false,"url":"/shielder","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"bitwarden","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":9192122,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","markdown_message":"","automated_response":false,"created_at":"2020-09-11T13:24:08.783Z","updated_at":"2020-09-11T13:24:08.783Z","actor":{"username":"chadscharf","cleared":false,"url":"/chadscharf","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/y7jahHdm66MGJNS9dmHCvJns/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"bitwarden","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":9192123,"is_internal":false,"editable":false,"type":"Activities::ReportBecamePublic","message":"","markdown_message":"","automated_response":false,"created_at":"2020-09-11T13:24:08.886Z","updated_at":"2020-09-11T13:24:08.886Z","actor":{"username":"chadscharf","cleared":false,"url":"/chadscharf","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/y7jahHdm66MGJNS9dmHCvJns/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"bitwarden","actor_is_team_member":true,"actor_is_concealed_member":false}],"activity_page_count":1,"activity_page_number":1,"summaries":[{"category":"team","can_view?":true,"can_create?":false},{"category":"researcher","can_view?":true,"can_create?":false}]}