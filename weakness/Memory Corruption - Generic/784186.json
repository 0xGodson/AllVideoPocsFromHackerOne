{"id":784186,"global_id":"Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC83ODQxODY=","url":"https://hackerone.com/reports/784186","title":"napi_get_value_string_X allow various kinds of memory corruption","state":"Closed","substate":"resolved","severity_rating":"high","readable_substate":"Resolved","created_at":"2020-01-27T16:49:36.768Z","submitted_at":"2020-01-27T16:49:36.768Z","is_member_of_team?":false,"reporter":{"disabled":false,"username":"tniessen","url":"/tniessen","profile_picture_urls":{"small":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"is_me?":false,"cleared":false,"hackerone_triager":false,"hacker_mediation":false},"team":{"id":22984,"url":"https://hackerone.com/nodejs","handle":"nodejs","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/022/984/e600648ace4a8553247bce967d461a030aa81d49_original.png/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a","medium":"https://profile-photos.hackerone-user-content.com/variants/000/022/984/e600648ace4a8553247bce967d461a030aa81d49_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"permissions":[],"submission_state":"open","default_currency":"usd","awards_miles":false,"offers_bounties":true,"state":"public_mode","only_cleared_hackers":false,"profile":{"name":"Node.js","twitter_handle":"nodejs","website":"https://nodejs.org","about":"The Node.js JavaScript Runtime"}},"has_bounty?":true,"in_validation?":false,"rejected_anc_report_that_can_be_sent_back_to_anc_triagers?":false,"can_view_team":true,"can_view_report":true,"is_external_bug":false,"is_published":false,"is_participant":false,"stage":4,"public":true,"visibility":"full","cve_ids":["CVE-2020-8174"],"singular_disclosure_disabled":false,"disclosed_at":"2020-07-02T19:53:41.174Z","bug_reporter_agreed_on_going_public_at":null,"team_member_agreed_on_going_public_at":"2020-06-02T19:53:24.048Z","comments_closed?":false,"facebook_team?":false,"team_private?":false,"vulnerability_information":"**Summary:**\n\n`napi_get_value_string_latin1`, `napi_get_value_string_utf8`, `napi_get_value_string_utf16` are vulnerable to buffer overflows, partially due to an integer underflow.\n\n**Description:**\n\n`napi_get_value_string_latin1`, `napi_get_value_string_utf8`, and `napi_get_value_string_utf16` behave like this:\n\n1. If the output pointer is `NULL`, return.\n2. Write `min(string_length, bufsize - 1)` bytes to the output buffer. Note that `bufsize` is an unsigned type, so this leads to an integer underflow for `bufsize == 0`. Since this is a `size_t`, the underflow will cause the entire string to be written to memory, no matter how long the string is.\n3. Finally, write to `buf[copied]`, where `copied` is the number of bytes previously written. Even if step 2 hadn't written out of bounds, this would (for `bufsize == 0`).\n\n## Steps To Reproduce:\n\n```cpp\nNapi::Value Test(const Napi::CallbackInfo\u0026 info) {\n  char buf[1];\n  // This should be a valid call, e.g., due to a malloc(0).\n  napi_get_value_string_latin1(info.Env(), info[0], buf, 0, nullptr);\n  return info.Env().Undefined();\n}\n```\n\n```js\nconst binding = require('bindings')('validation');\nconsole.log(binding.test('this could be code that might later be executed'));\n```\n\nRunning the above script corrupts the call stack:\n\n```bash\ntniessen@local-vm:~/validation-fails$ node .\n*** stack smashing detected ***: \u003cunknown\u003e terminated\nAborted (core dumped)\n```\n\nThe best outcome is a crash, but a very likely outcome is data corruption. If the attacker can control the string's contents, they can even insert code into the process heap, or modify the call stack. Depending on the architecture and application, this can lead to various issues, up to remote code execution.\n\nIt is perfectly valid to pass in a non-NULL pointer for `buf` while specifying `bufsize == 0`. For example, `malloc(0)` is not guaranteed to return `NULL`.  A npm package might correctly work on one machine based on the assumption that `malloc(0) == NULL`, but might create severe security issues on a different host. Passing a non-NULL pointer is also not ruled out by the documentation of N-API, so it is not valid to assume that `buf` will always be `NULL` if `bufsize == 0`.\n\n## Impact\n\nnpm packages and other applications that use N-API may involuntarily open up severe security issues, that might even be exploitable remotely. Even if `buf` is a valid pointer, passing `bufsize == 0` allows to write outside of the boundaries of that buffer.\n\nStep 2 of the description allows an attacker to precisely define what is written to memory by passing in a custom string. Depending on whether the pointer points to heap or stack, possible results include data corruption, crashes (and thus DoS), and possibly even remote code execution, either by writing instructions to heap memory or by corrupting the stack.\n\nMany attacks are likely caught by kernel and hardware protection mechanisms, but that depends on the specific hardware, kernel, and application, and memory layout. Even if they are caught, the entire process will crash (which is still good compared to other outcomes).","vulnerability_information_html":"\u003cp\u003e\u003cstrong\u003eSummary:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enapi_get_value_string_latin1\u003c/code\u003e, \u003ccode\u003enapi_get_value_string_utf8\u003c/code\u003e, \u003ccode\u003enapi_get_value_string_utf16\u003c/code\u003e are vulnerable to buffer overflows, partially due to an integer underflow.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enapi_get_value_string_latin1\u003c/code\u003e, \u003ccode\u003enapi_get_value_string_utf8\u003c/code\u003e, and \u003ccode\u003enapi_get_value_string_utf16\u003c/code\u003e behave like this:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eIf the output pointer is \u003ccode\u003eNULL\u003c/code\u003e, return.\u003c/li\u003e\n\u003cli\u003eWrite \u003ccode\u003emin(string_length, bufsize - 1)\u003c/code\u003e bytes to the output buffer. Note that \u003ccode\u003ebufsize\u003c/code\u003e is an unsigned type, so this leads to an integer underflow for \u003ccode\u003ebufsize == 0\u003c/code\u003e. Since this is a \u003ccode\u003esize_t\u003c/code\u003e, the underflow will cause the entire string to be written to memory, no matter how long the string is.\u003c/li\u003e\n\u003cli\u003eFinally, write to \u003ccode\u003ebuf[copied]\u003c/code\u003e, where \u003ccode\u003ecopied\u003c/code\u003e is the number of bytes previously written. Even if step 2 hadn\u0026#39;t written out of bounds, this would (for \u003ccode\u003ebufsize == 0\u003c/code\u003e).\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"steps-to-reproduce\"\u003eSteps To Reproduce:\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight cpp\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eNapi\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eValue\u003c/span\u003e \u003cspan class=\"nf\"\u003eTest\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003eNapi\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eCallbackInfo\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003einfo\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"n\"\u003ebuf\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n  \u003cspan class=\"c1\"\u003e// This should be a valid call, e.g., due to a malloc(0).\u003c/span\u003e\n  \u003cspan class=\"n\"\u003enapi_get_value_string_latin1\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003einfo\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eEnv\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"n\"\u003einfo\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e],\u003c/span\u003e \u003cspan class=\"n\"\u003ebuf\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nb\"\u003enullptr\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n  \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003einfo\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eEnv\u003c/span\u003e\u003cspan class=\"p\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eUndefined\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight javascript\"\u003e\u003ccode\u003e\u003cspan class=\"kd\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003ebinding\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003erequire\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"dl\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003ebindings\u003c/span\u003e\u003cspan class=\"dl\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e)(\u003c/span\u003e\u003cspan class=\"dl\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003evalidation\u003c/span\u003e\u003cspan class=\"dl\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"nx\"\u003econsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003elog\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ebinding\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003etest\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"dl\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003ethis could be code that might later be executed\u003c/span\u003e\u003cspan class=\"dl\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eRunning the above script corrupts the call stack:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight shell\"\u003e\u003ccode\u003etniessen@local-vm:~/validation-fails\u003cspan class=\"nv\"\u003e$ \u003c/span\u003enode \u003cspan class=\"nb\"\u003e.\u003c/span\u003e\n\u003cspan class=\"k\"\u003e***\u003c/span\u003e stack smashing detected \u003cspan class=\"k\"\u003e***\u003c/span\u003e: \u0026lt;unknown\u0026gt; terminated\nAborted \u003cspan class=\"o\"\u003e(\u003c/span\u003ecore dumped\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe best outcome is a crash, but a very likely outcome is data corruption. If the attacker can control the string\u0026#39;s contents, they can even insert code into the process heap, or modify the call stack. Depending on the architecture and application, this can lead to various issues, up to remote code execution.\u003c/p\u003e\n\n\u003cp\u003eIt is perfectly valid to pass in a non-NULL pointer for \u003ccode\u003ebuf\u003c/code\u003e while specifying \u003ccode\u003ebufsize == 0\u003c/code\u003e. For example, \u003ccode\u003emalloc(0)\u003c/code\u003e is not guaranteed to return \u003ccode\u003eNULL\u003c/code\u003e.  A npm package might correctly work on one machine based on the assumption that \u003ccode\u003emalloc(0) == NULL\u003c/code\u003e, but might create severe security issues on a different host. Passing a non-NULL pointer is also not ruled out by the documentation of N-API, so it is not valid to assume that \u003ccode\u003ebuf\u003c/code\u003e will always be \u003ccode\u003eNULL\u003c/code\u003e if \u003ccode\u003ebufsize == 0\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch2 id=\"impact\"\u003eImpact\u003c/h2\u003e\n\n\u003cp\u003enpm packages and other applications that use N-API may involuntarily open up severe security issues, that might even be exploitable remotely. Even if \u003ccode\u003ebuf\u003c/code\u003e is a valid pointer, passing \u003ccode\u003ebufsize == 0\u003c/code\u003e allows to write outside of the boundaries of that buffer.\u003c/p\u003e\n\n\u003cp\u003eStep 2 of the description allows an attacker to precisely define what is written to memory by passing in a custom string. Depending on whether the pointer points to heap or stack, possible results include data corruption, crashes (and thus DoS), and possibly even remote code execution, either by writing instructions to heap memory or by corrupting the stack.\u003c/p\u003e\n\n\u003cp\u003eMany attacks are likely caught by kernel and hardware protection mechanisms, but that depends on the specific hardware, kernel, and application, and memory layout. Even if they are caught, the entire process will crash (which is still good compared to other outcomes).\u003c/p\u003e\n","bounty_amount":"250.0","formatted_bounty":"$250","weakness":{"id":2,"name":"Memory Corruption - Generic"},"original_report_id":null,"original_report_url":null,"attachments":[],"allow_singular_disclosure_at":"2020-07-02T19:53:24.119Z","allow_singular_disclosure_after":-15505125.701700008,"singular_disclosure_allowed":true,"vote_count":6,"voters":["dwisiswant0","donotenter","tr1n1ty8","mubeen-m","ohioguy","beforedayone"],"severity":{"rating":"high","score":8.5,"author_type":"User","metrics":{"attack_vector":"network","attack_complexity":"high","privileges_required":"low","user_interaction":"none","scope":"changed","confidentiality":"low","integrity":"high","availability":"high"}},"structured_scope":{"databaseId":666,"asset_type":"SOURCE_CODE","asset_identifier":"https://github.com/nodejs/node","max_severity":"critical"},"abilities":{"assignable_team_members":[],"assignable_team_member_groups":[]},"can_edit_custom_fields_attributes":false,"activities":[{"id":6882358,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"I’m not too worried about this being a common case, as most usage of these functions will first figure out the length of the buffer based on the length of the string (like e.g. the node-addon-api code does), but I’m okay with treating this as a security issue.\n\nWould you be okay opening PRs that fix this in the private repository? It should be fairly straightforward to do so.\n\nI think this also means that we’d want to push out new releases for node-addon-api@v1.x and @v2.x? Maybe ping Gabriel when you open the PRs?","markdown_message":"\u003cp\u003eI’m not too worried about this being a common case, as most usage of these functions will first figure out the length of the buffer based on the length of the string (like e.g. the node-addon-api code does), but I’m okay with treating this as a security issue.\u003c/p\u003e\n\n\u003cp\u003eWould you be okay opening PRs that fix this in the private repository? It should be fairly straightforward to do so.\u003c/p\u003e\n\n\u003cp\u003eI think this also means that we’d want to push out new releases for \u003ca title=\"node-addon-api@v1.x\" href=\"mailto:node-addon-api@v1.x\" rel=\"nofollow noopener noreferrer\"\u003enode-addon-api@v1.x\u003c/a\u003e and \u003ca href=\"/v2\"\u003e@v2\u003c/a\u003e.x? Maybe ping Gabriel when you open the PRs?\u003c/p\u003e\n","automated_response":false,"created_at":"2020-01-27T17:14:26.112Z","updated_at":"2020-01-27T17:14:26.112Z","actor":{"username":"addaleax","cleared":false,"url":"/addaleax","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"nodejs","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6882906,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"\u003e I’m not too worried about this being a common case\n\nI am also convinced that it is not common. But it might still affect real applications, and from my perspective, the implementation violates the general contract of not writing to a zero-length buffer in a dangerous way that can potentially allow targeted memory corruption, up to remote code execution.\n\n\u003e most usage of these functions will first figure out the length of the buffer based on the length of the string\n\nI agree, but even then, OOB access is possible: Assume that `len(string) == 0`. The application probably allocates the buffer using `malloc(0)`, which is not guaranteed to return `NULL`, and may in fact return any pointer, that `napi_get_value_string_*` will then write at least one byte to, even though the string is empty.\n\n\u003e Would you be okay opening PRs that fix this in the private repository? It should be fairly straightforward to do so.\n\nSure, I can do that.","markdown_message":"\u003cblockquote\u003e\n\u003cp\u003eI’m not too worried about this being a common case\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eI am also convinced that it is not common. But it might still affect real applications, and from my perspective, the implementation violates the general contract of not writing to a zero-length buffer in a dangerous way that can potentially allow targeted memory corruption, up to remote code execution.\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003emost usage of these functions will first figure out the length of the buffer based on the length of the string\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eI agree, but even then, OOB access is possible: Assume that \u003ccode\u003elen(string) == 0\u003c/code\u003e. The application probably allocates the buffer using \u003ccode\u003emalloc(0)\u003c/code\u003e, which is not guaranteed to return \u003ccode\u003eNULL\u003c/code\u003e, and may in fact return any pointer, that \u003ccode\u003enapi_get_value_string_*\u003c/code\u003e will then write at least one byte to, even though the string is empty.\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eWould you be okay opening PRs that fix this in the private repository? It should be fairly straightforward to do so.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eSure, I can do that.\u003c/p\u003e\n","automated_response":false,"created_at":"2020-01-27T17:30:36.555Z","updated_at":"2020-01-27T17:30:36.555Z","actor":{"username":"tniessen","cleared":false,"url":"/tniessen","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"nodejs","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":6884500,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"@addaleax,   I assume the suggestion to push out new releases of node-addon-api@v1.x and @v2.x is because they included a copy of the related code that was used for version of Node.js that did not yet provide N-API ?  If so we should probalby loop in Nicola Del Gobbo (@NickNaso) as he's being helping with publishing the recent node-addon-api releases.","markdown_message":"\u003cp\u003e\u003ca href=\"/addaleax\"\u003e@addaleax\u003c/a\u003e,   I assume the suggestion to push out new releases of \u003ca title=\"node-addon-api@v1.x\" href=\"mailto:node-addon-api@v1.x\" rel=\"nofollow noopener noreferrer\"\u003enode-addon-api@v1.x\u003c/a\u003e and \u003ca href=\"/v2\"\u003e@v2\u003c/a\u003e.x is because they included a copy of the related code that was used for version of Node.js that did not yet provide N-API ?  If so we should probalby loop in Nicola Del Gobbo (@NickNaso) as he\u0026#39;s being helping with publishing the recent node-addon-api releases.\u003c/p\u003e\n","automated_response":false,"created_at":"2020-01-27T19:11:12.678Z","updated_at":"2020-01-27T19:11:12.678Z","actor":{"username":"mhdawson","cleared":false,"url":"/mhdawson","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"nodejs","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":7035597,"is_internal":false,"editable":false,"type":"Activities::BugTriaged","message":"","markdown_message":"","automated_response":false,"created_at":"2020-02-12T19:52:27.139Z","updated_at":"2020-02-12T19:52:27.139Z","actor":{"username":"octetcloud","cleared":false,"url":"/octetcloud","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/210/672/27b2c0c2193cfb366f7889374e7ce71077431f74_original.jpeg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"nodejs","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":7891574,"is_internal":false,"editable":false,"type":"Activities::ReportTitleUpdated","message":"","markdown_message":"","automated_response":false,"created_at":"2020-05-04T19:55:37.761Z","updated_at":"2020-05-04T19:55:37.761Z","additional_data":{"old_title":"napi_get_value_string_* allow various kinds of memory corruption","new_title":"napi_get_value_string_X allow various kinds of memory corruption"},"actor":{"username":"octetcloud","cleared":false,"url":"/octetcloud","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/210/672/27b2c0c2193cfb366f7889374e7ce71077431f74_original.jpeg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"nodejs","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":8182750,"is_internal":false,"editable":false,"type":"Activities::BugResolved","message":"https://nodejs.org/en/blog/vulnerability/june-2020-security-releases/","markdown_message":"\u003cp\u003e\u003ca title=\"https://nodejs.org/en/blog/vulnerability/june-2020-security-releases/\" href=\"/redirect?url=https%3A%2F%2Fnodejs.org%2Fen%2Fblog%2Fvulnerability%2Fjune-2020-security-releases%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://nodejs.org/en/blog/vulnerability/june-2020-security-releases/\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/p\u003e\n","automated_response":false,"created_at":"2020-06-02T19:52:52.011Z","updated_at":"2020-06-02T19:52:52.011Z","actor":{"username":"octetcloud","cleared":false,"url":"/octetcloud","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/210/672/27b2c0c2193cfb366f7889374e7ce71077431f74_original.jpeg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":null},"reporter":{"username":"tniessen","url":"/tniessen"},"genius_execution_id":null,"team_handle":"nodejs","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":8182752,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","markdown_message":"","automated_response":false,"created_at":"2020-06-02T19:53:24.065Z","updated_at":"2020-06-02T19:53:24.065Z","first_to_agree":true,"actor":{"username":"octetcloud","cleared":false,"url":"/octetcloud","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/210/672/27b2c0c2193cfb366f7889374e7ce71077431f74_original.jpeg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"nodejs","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":8484605,"is_internal":false,"editable":false,"type":"Activities::ReportBecamePublic","message":"","markdown_message":"","automated_response":false,"created_at":"2020-07-02T19:53:41.341Z","updated_at":"2020-07-02T19:53:41.341Z","actor":{"url":"/nodejs","ibb":true,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/022/984/e600648ace4a8553247bce967d461a030aa81d49_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"Node.js"}},"genius_execution_id":null,"team_handle":"nodejs","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":8610769,"is_internal":false,"editable":false,"type":"Activities::BountyAwarded","message":"","markdown_message":"","automated_response":false,"created_at":"2020-07-15T17:37:06.844Z","updated_at":"2020-07-15T17:37:06.844Z","actor":{"url":"/nodejs","ibb":true,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/022/984/e600648ace4a8553247bce967d461a030aa81d49_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"Node.js"}},"bounty_amount":"250.0","bounty_currency":"usd","bonus_amount":"0.0","genius_execution_id":null,"team_handle":"nodejs","collaborator":{"username":"tniessen","url":"/tniessen"},"actor_is_team_member":true,"actor_is_concealed_member":false}],"activity_page_count":1,"activity_page_number":1,"summaries":[{"category":"team","can_view?":true,"can_create?":false},{"category":"researcher","can_view?":true,"can_create?":false}]}