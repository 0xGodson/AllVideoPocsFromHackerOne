{"id":138025,"global_id":"Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8xMzgwMjU=","url":"https://hackerone.com/reports/138025","title":"Heap corruption via memarea.c","state":"Closed","substate":"resolved","readable_substate":"Resolved","created_at":"2016-05-11T20:00:34.272Z","submitted_at":"2016-05-11T20:00:34.272Z","is_member_of_team?":false,"reporter":{"disabled":false,"username":"guido","url":"/guido","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/002/983/e55b0b2324777fb7efc2de4212fd8d337ca816bd_original.jpg/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a"},"is_me?":false,"cleared":false,"hackerone_triager":false,"hacker_mediation":false},"team":{"id":1800,"url":"https://hackerone.com/torproject","handle":"torproject","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/001/800/6e575d0a9127b91e83833cf4a9e6be6e8b30cbc3_original.jpg/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a","medium":"https://profile-photos.hackerone-user-content.com/variants/000/001/800/6e575d0a9127b91e83833cf4a9e6be6e8b30cbc3_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"permissions":[],"submission_state":"paused","default_currency":"usd","awards_miles":false,"offers_bounties":true,"state":"public_mode","only_cleared_hackers":false,"profile":{"name":"Tor","twitter_handle":"torproject","website":"https://www.torproject.org/","about":"Anonymity Online"}},"has_bounty?":true,"in_validation?":false,"rejected_anc_report_that_can_be_sent_back_to_anc_triagers?":false,"can_view_team":true,"can_view_report":true,"is_external_bug":false,"is_published":false,"is_participant":false,"stage":4,"public":true,"visibility":"full","cve_ids":[],"singular_disclosure_disabled":false,"disclosed_at":"2017-10-19T10:16:01.417Z","bug_reporter_agreed_on_going_public_at":"2017-10-19T10:16:01.366Z","team_member_agreed_on_going_public_at":"2017-10-19T09:35:39.803Z","comments_closed?":false,"facebook_team?":false,"team_private?":false,"vulnerability_information":"Hello again,\n\nThere is a potential vulnerability in memarea.c.\n\ncommon/memarea.c:\n\n```c\n230 void *\n231 memarea_alloc(memarea_t *area, size_t sz)\n232 {\n233   memarea_chunk_t *chunk = area-\u003efirst;\n234   char *result;\n235   tor_assert(chunk);\n236   CHECK_SENTINEL(chunk);\n237   tor_assert(sz \u003c SIZE_T_CEILING);\n238   if (sz == 0)\n239     sz = 1;\n240   if (chunk-\u003enext_mem+sz \u003e chunk-\u003eU_MEM+chunk-\u003emem_size) {\n```\n\nThe vulnerability lies in the addition of a pointer and an integer on line 240:\n\n```c\n240   if (chunk-\u003enext_mem+sz ...\n```\nTo which address ```chunk-\u003enext_mem``` points is not within the application's (tor) purview, since it originates from within malloc() (which is accessed via tor_malloc()) and to some extent the system's kernel memory management), and malloc() is implemented in the libc with which tor was linked.\nMy point is that no or few assumptions can be made about the virtual address to which chunk-\u003enext_mem points.\n\n```sz``` is variable and may be influenced by an external party on the network.\n\nFurthermore, it is guaranteed that ```sz``` is smaller than SIZE_T_CEILING, which is 0x80000000 on 32 bit:\n\n```c\ntor_assert(sz \u003c SIZE_T_CEILING);\n```\n\nThe above predicates imply that 1) given a 32 bit system, where 2) chunk-\u003enext_mem happens to point to a virtual address of 0x80000000 or higher and 3) ```sz``` \u003e= ```0x100000000 - chunk-\u003emem_next``` an overflow will occur in the addition of the pointer ```chunk-\u003enext_mem+sz```, thus unduly evading this check, which was meant to assert whether is sufficient memory in the current block.\n\nIn other words, if chunk-\u003enext_mem is 0xA0000000, and memarea_alloc is called to request ```0x60000000``` bytes, then the following will happen:\n\n```c\n230 void *\n231 memarea_alloc(memarea_t *area, size_t sz)\n232 {     \n233   memarea_chunk_t *chunk = area-\u003efirst;\n234   char *result;\n235   tor_assert(chunk);\n236   CHECK_SENTINEL(chunk);\n237   tor_assert(sz \u003c SIZE_T_CEILING);\n238   if (sz == 0)\n239     sz = 1;\n240   if (chunk-\u003enext_mem+sz \u003e chunk-\u003eU_MEM+chunk-\u003emem_size) {\n...\n...   This code is not executed\n...\n254   } \n255   result = chunk-\u003enext_mem;\n256   chunk-\u003enext_mem = chunk-\u003enext_mem + sz;\n```\n\nIn this case, line 256 translate to:\n\n```\n256   chunk-\u003enext_mem = 0xA0000000 + 0x60000000;\n```\n\nEg. ```chunk-\u003enext_mem``` now equals 0.\n\nThe higher the value of ```chunk-\u003enext_mem```, and the higher the maximum value of ```sz``` that a potential attacker can enforce to be allocated, the higher the odds of yielding a ```chunk-\u003enext_mem``` value that points to real data (eg. a block of heap memory allocated by tor).\n\nI've used 32 bit in this example. 64 bit is theoretically possible too (SIZE_T_CEILING is larger on 64 bit as well), but less likely.\n\nAn easy way to test this is by changing this line in memarea.c alloc_chunk():\n\n```c\nres = tor_malloc(chunk_size);\n```\n\nto\n\n```c\nres = mmap((void*)0xF0000000, chunk_size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n```\n\n(also include ```#include \u003csys/mman.h\u003e```)\n\nthen this code will trigger a segmentation fault\n\n```\n  memarea_t *area;\n  area = memarea_new();\n  char *mem = memarea_alloc(area, 0x10000000);\n  memset(mem, 0, 0x10000000);\n```\n\n(be aware that this example applies to 32 bit, so compile with ```CFLAGS=\"-m32\"```)\n\nGuido","vulnerability_information_html":"\u003cp\u003eHello again,\u003c/p\u003e\n\n\u003cp\u003eThere is a potential vulnerability in memarea.c.\u003c/p\u003e\n\n\u003cp\u003ecommon/memarea.c:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight c\"\u003e\u003ccode\u003e\u003cspan class=\"mi\"\u003e230\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e231\u003c/span\u003e \u003cspan class=\"n\"\u003ememarea_alloc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ememarea_t\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003earea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003esize_t\u003c/span\u003e \u003cspan class=\"n\"\u003esz\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e232\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e233\u003c/span\u003e   \u003cspan class=\"n\"\u003ememarea_chunk_t\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003echunk\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003earea\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003efirst\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e234\u003c/span\u003e   \u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eresult\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e235\u003c/span\u003e   \u003cspan class=\"n\"\u003etor_assert\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e236\u003c/span\u003e   \u003cspan class=\"n\"\u003eCHECK_SENTINEL\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e237\u003c/span\u003e   \u003cspan class=\"n\"\u003etor_assert\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esz\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eSIZE_T_CEILING\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e238\u003c/span\u003e   \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esz\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e239\u003c/span\u003e     \u003cspan class=\"n\"\u003esz\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e240\u003c/span\u003e   \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext_mem\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003esz\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eU_MEM\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003emem_size\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe vulnerability lies in the addition of a pointer and an integer on line 240:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight c\"\u003e\u003ccode\u003e\u003cspan class=\"mi\"\u003e240\u003c/span\u003e   \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext_mem\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003esz\u003c/span\u003e \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eTo which address \u003ccode\u003echunk-\u0026gt;next_mem\u003c/code\u003e points is not within the application\u0026#39;s (tor) purview, since it originates from within malloc() (which is accessed via tor_malloc()) and to some extent the system\u0026#39;s kernel memory management), and malloc() is implemented in the libc with which tor was linked.\u003cbr\u003e\nMy point is that no or few assumptions can be made about the virtual address to which chunk-\u0026gt;next_mem points.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003esz\u003c/code\u003e is variable and may be influenced by an external party on the network.\u003c/p\u003e\n\n\u003cp\u003eFurthermore, it is guaranteed that \u003ccode\u003esz\u003c/code\u003e is smaller than SIZE_T_CEILING, which is 0x80000000 on 32 bit:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight c\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003etor_assert\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esz\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eSIZE_T_CEILING\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe above predicates imply that 1) given a 32 bit system, where 2) chunk-\u0026gt;next_mem happens to point to a virtual address of 0x80000000 or higher and 3) \u003ccode\u003esz\u003c/code\u003e \u0026gt;= \u003ccode\u003e0x100000000 - chunk-\u0026gt;mem_next\u003c/code\u003e an overflow will occur in the addition of the pointer \u003ccode\u003echunk-\u0026gt;next_mem+sz\u003c/code\u003e, thus unduly evading this check, which was meant to assert whether is sufficient memory in the current block.\u003c/p\u003e\n\n\u003cp\u003eIn other words, if chunk-\u0026gt;next_mem is 0xA0000000, and memarea_alloc is called to request \u003ccode\u003e0x60000000\u003c/code\u003e bytes, then the following will happen:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight c\"\u003e\u003ccode\u003e\u003cspan class=\"mi\"\u003e230\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e231\u003c/span\u003e \u003cspan class=\"n\"\u003ememarea_alloc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ememarea_t\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003earea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003esize_t\u003c/span\u003e \u003cspan class=\"n\"\u003esz\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e232\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e     \n\u003cspan class=\"mi\"\u003e233\u003c/span\u003e   \u003cspan class=\"n\"\u003ememarea_chunk_t\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003echunk\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003earea\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003efirst\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e234\u003c/span\u003e   \u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eresult\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e235\u003c/span\u003e   \u003cspan class=\"n\"\u003etor_assert\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e236\u003c/span\u003e   \u003cspan class=\"n\"\u003eCHECK_SENTINEL\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e237\u003c/span\u003e   \u003cspan class=\"n\"\u003etor_assert\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esz\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eSIZE_T_CEILING\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e238\u003c/span\u003e   \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esz\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e239\u003c/span\u003e     \u003cspan class=\"n\"\u003esz\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e240\u003c/span\u003e   \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext_mem\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003esz\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eU_MEM\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003emem_size\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\u003cspan class=\"p\"\u003e...\u003c/span\u003e   \u003cspan class=\"n\"\u003eThis\u003c/span\u003e \u003cspan class=\"n\"\u003ecode\u003c/span\u003e \u003cspan class=\"n\"\u003eis\u003c/span\u003e \u003cspan class=\"n\"\u003enot\u003c/span\u003e \u003cspan class=\"n\"\u003eexecuted\u003c/span\u003e\n\u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e254\u003c/span\u003e   \u003cspan class=\"p\"\u003e}\u003c/span\u003e \n\u003cspan class=\"mi\"\u003e255\u003c/span\u003e   \u003cspan class=\"n\"\u003eresult\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext_mem\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e256\u003c/span\u003e   \u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext_mem\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext_mem\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003esz\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eIn this case, line 256 translate to:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e256   chunk-\u0026gt;next_mem = 0xA0000000 + 0x60000000;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eEg. \u003ccode\u003echunk-\u0026gt;next_mem\u003c/code\u003e now equals 0.\u003c/p\u003e\n\n\u003cp\u003eThe higher the value of \u003ccode\u003echunk-\u0026gt;next_mem\u003c/code\u003e, and the higher the maximum value of \u003ccode\u003esz\u003c/code\u003e that a potential attacker can enforce to be allocated, the higher the odds of yielding a \u003ccode\u003echunk-\u0026gt;next_mem\u003c/code\u003e value that points to real data (eg. a block of heap memory allocated by tor).\u003c/p\u003e\n\n\u003cp\u003eI\u0026#39;ve used 32 bit in this example. 64 bit is theoretically possible too (SIZE_T_CEILING is larger on 64 bit as well), but less likely.\u003c/p\u003e\n\n\u003cp\u003eAn easy way to test this is by changing this line in memarea.c alloc_chunk():\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight c\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eres\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etor_malloc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003echunk_size\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eto\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight c\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eres\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emmap\u003c/span\u003e\u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"mh\"\u003e0xF0000000\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003echunk_size\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ePROT_READ\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"n\"\u003ePROT_WRITE\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eMAP_SHARED\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"n\"\u003eMAP_ANONYMOUS\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e(also include \u003ccode\u003e#include \u0026lt;sys/mman.h\u0026gt;\u003c/code\u003e)\u003c/p\u003e\n\n\u003cp\u003ethen this code will trigger a segmentation fault\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e  memarea_t *area;\n  area = memarea_new();\n  char *mem = memarea_alloc(area, 0x10000000);\n  memset(mem, 0, 0x10000000);\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e(be aware that this example applies to 32 bit, so compile with \u003ccode\u003eCFLAGS=\u0026quot;-m32\u0026quot;\u003c/code\u003e)\u003c/p\u003e\n\n\u003cp\u003eGuido\u003c/p\u003e\n","bounty_amount":"300.0","formatted_bounty":"$300","weakness":{"id":2,"name":"Memory Corruption - Generic"},"original_report_id":null,"original_report_url":null,"attachments":[],"allow_singular_disclosure_at":"2017-11-18T09:35:40.030Z","allow_singular_disclosure_after":-98218286.80808252,"singular_disclosure_allowed":true,"vote_count":6,"voters":["eveeez","geeknik","mr_r3boot","spetr0x","b4155f7c29acd42c27d007a","mycel"],"structured_scope":null,"abilities":{"assignable_team_members":[],"assignable_team_member_groups":[]},"can_edit_custom_fields_attributes":false,"activities":[{"id":962155,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Hey Guido!\n\nThanks for the bug report!\n\nThis does sound like a pretty bad bug, but I actually can't find a way to exploit it the way you describe. That is, I can't find a vector where `memarea_alloc()` is called with a dangerously big `sz` argument.\n\nSpecifically, the function seems to get used a lot in `routerparse.c:get_next_token()` but it seems like all its inputs are restricted to 128kb, that is `MAX_LINE_LENGTH` and `MAX_UNPARSED_OBJECT_SIZE`.\nSo we are talking about `sz` arguments of value 131072 or so, which is nowhere close to the `0x60000000` you provided :/\n\nI feel that this bug should be fixed for sure, but I doubt it can actually be exploitable for RCE. How would you exploit this bug? I am tempted to rank this as a \"low severity\" issue if no plausible attack vector is provided.\n\nAlso, how would you fix this bug? Do you think we could just replace the overflowing pointer length check with something like `if sz \u003e chunk-\u003emem_size`?\n\nIn any case, I'll pipe this issue to more Tor developers.\n\nThanks for the report!","markdown_message":"\u003cp\u003eHey Guido!\u003c/p\u003e\n\n\u003cp\u003eThanks for the bug report!\u003c/p\u003e\n\n\u003cp\u003eThis does sound like a pretty bad bug, but I actually can\u0026#39;t find a way to exploit it the way you describe. That is, I can\u0026#39;t find a vector where \u003ccode\u003ememarea_alloc()\u003c/code\u003e is called with a dangerously big \u003ccode\u003esz\u003c/code\u003e argument.\u003c/p\u003e\n\n\u003cp\u003eSpecifically, the function seems to get used a lot in \u003ccode\u003erouterparse.c:get_next_token()\u003c/code\u003e but it seems like all its inputs are restricted to 128kb, that is \u003ccode\u003eMAX_LINE_LENGTH\u003c/code\u003e and \u003ccode\u003eMAX_UNPARSED_OBJECT_SIZE\u003c/code\u003e.\u003cbr\u003e\nSo we are talking about \u003ccode\u003esz\u003c/code\u003e arguments of value 131072 or so, which is nowhere close to the \u003ccode\u003e0x60000000\u003c/code\u003e you provided :/\u003c/p\u003e\n\n\u003cp\u003eI feel that this bug should be fixed for sure, but I doubt it can actually be exploitable for RCE. How would you exploit this bug? I am tempted to rank this as a \u0026quot;low severity\u0026quot; issue if no plausible attack vector is provided.\u003c/p\u003e\n\n\u003cp\u003eAlso, how would you fix this bug? Do you think we could just replace the overflowing pointer length check with something like \u003ccode\u003eif sz \u0026gt; chunk-\u0026gt;mem_size\u003c/code\u003e?\u003c/p\u003e\n\n\u003cp\u003eIn any case, I\u0026#39;ll pipe this issue to more Tor developers.\u003c/p\u003e\n\n\u003cp\u003eThanks for the report!\u003c/p\u003e\n","automated_response":false,"created_at":"2016-05-17T20:49:12.306Z","updated_at":"2016-05-17T20:49:12.306Z","actor":{"username":"asn","cleared":false,"url":"/asn","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"torproject","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":962281,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Hey asn,\n\nI agree that if 128kb is the largest size allocated via memarea, the worst that can happen is a remote denial of service (via a null pointer write).\n\nIf we assume that ```chunk-\u003enext_mem``` is 0xFFFE0000 or upward, and memarea_alloc is called with sz == 0x20000 (128 kilobyte), then\n\nthis:\n\n```c\nif (chunk-\u003enext_mem+sz \u003e chunk-\u003eU_MEM+chunk-\u003emem_size) { ... }\n```\n\nwill render to\n\n```c\nif ( 0 \u003e chunk-\u003eU_MEM+chunk-\u003emem_size ) { ... }\n```\n\nwhich is always false so\n\n```c\nchunk-\u003enext_mem = chunk-\u003enext_mem + sz;\n```\n\nbecomes\n\n```c\nchunk-\u003enext_mem = 0;\n```\n\nafter which a write to 0x00000000 or thereabouts is expected to happen, which would crash tor.\n\nSome notes:\n\nJust as there is (as far as I know) no strict limit to the maximum (highest) virtual address that malloc() may return, there may also not be a strict lower limit.\nmalloc(), or the system's low-level allocation facilities will never return a legal heap pointer to 0x00000000, as in:\n\n```c\nc = malloc(1024);\n/* c == 0x00000000 */\nmemset(c, 0, 1024);\n```\n\nBut it might be possible that malloc() would return a pointer to, say, 0x00010000.\n\nIf we assume for a moment that\n   - some unrelated function has some stored some data on 0x00010000\n   - chunk-\u003enext_mem is currently 0xFFFF0000 ,and chunk-\u003emem_size is some smallish amount.\n   - A call to memarea_alloc is made requesting a size of 128KB (0x20000)\n\nSince 0xFFFF0000 (start of current heap block) + 0x20000 (requested amount) overflows into 0xFFFF0000 + 0x200000 = 0x100010000 = 0x00010000 on a 32 bit system,\n\n```c\nif (chunk-\u003enext_mem+sz \u003e chunk-\u003eU_MEM+chunk-\u003emem_size) { ... }\n```\n\nbecomes\n\n```c\nif (0x00010000 \u003e chunk-\u003eU_MEM+chunk-\u003emem_size) { ... }\n```\n\nwhich is false,\n\nSo\n\n```c\nchunk-\u003enext_mem = chunk-\u003enext_mem + sz;\n```\n\nbecomes\n\n```c\nchunk-\u003enext_mem = 0x00010000;\n```\n\nwhich happens to be totally unrelated heap memory containing unrelated data in this example.\n\nAnyway, I think this example of potential RCE is a very arcane cornercase that would only be exploitable on a specific 32 bit architecture+kernel+libc that allows both very high virtual address allocations (0xFFFF0000) and very low virtual address allocations (0x00010000) (or static data residing there ).\n\nSo because there is a potential remote DoS, and fixing it may prevent an RCE if you will use memarea at more places in the future (ie. it's implementing a best practice/additional safety guard), and RCE is currently only possible in very unlikely scenario's (if at all), I fully agree with your grading of \"low severity\".\n\nI think your proposed fix ```if sz \u003e chunk-\u003emem_size``` is correct but I'm gonna double check that right now and I'll get back to it later.\n\nGuido","markdown_message":"\u003cp\u003eHey asn,\u003c/p\u003e\n\n\u003cp\u003eI agree that if 128kb is the largest size allocated via memarea, the worst that can happen is a remote denial of service (via a null pointer write).\u003c/p\u003e\n\n\u003cp\u003eIf we assume that \u003ccode\u003echunk-\u0026gt;next_mem\u003c/code\u003e is 0xFFFE0000 or upward, and memarea_alloc is called with sz == 0x20000 (128 kilobyte), then\u003c/p\u003e\n\n\u003cp\u003ethis:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight c\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext_mem\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003esz\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eU_MEM\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003emem_size\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"p\"\u003e...\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003ewill render to\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight c\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eU_MEM\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003emem_size\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"p\"\u003e...\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003ewhich is always false so\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight c\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext_mem\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext_mem\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003esz\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003ebecomes\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight c\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext_mem\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eafter which a write to 0x00000000 or thereabouts is expected to happen, which would crash tor.\u003c/p\u003e\n\n\u003cp\u003eSome notes:\u003c/p\u003e\n\n\u003cp\u003eJust as there is (as far as I know) no strict limit to the maximum (highest) virtual address that malloc() may return, there may also not be a strict lower limit.\u003cbr\u003e\nmalloc(), or the system\u0026#39;s low-level allocation facilities will never return a legal heap pointer to 0x00000000, as in:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight c\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emalloc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1024\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"cm\"\u003e/* c == 0x00000000 */\u003c/span\u003e\n\u003cspan class=\"n\"\u003ememset\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e1024\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eBut it might be possible that malloc() would return a pointer to, say, 0x00010000.\u003c/p\u003e\n\n\u003cp\u003eIf we assume for a moment that\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003esome unrelated function has some stored some data on 0x00010000\u003c/li\u003e\n\u003cli\u003echunk-\u0026gt;next_mem is currently 0xFFFF0000 ,and chunk-\u0026gt;mem_size is some smallish amount.\u003c/li\u003e\n\u003cli\u003eA call to memarea_alloc is made requesting a size of 128KB (0x20000)\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eSince 0xFFFF0000 (start of current heap block) + 0x20000 (requested amount) overflows into 0xFFFF0000 + 0x200000 = 0x100010000 = 0x00010000 on a 32 bit system,\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight c\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext_mem\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003esz\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eU_MEM\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003emem_size\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"p\"\u003e...\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003ebecomes\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight c\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mh\"\u003e0x00010000\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eU_MEM\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003emem_size\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"p\"\u003e...\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003ewhich is false,\u003c/p\u003e\n\n\u003cp\u003eSo\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight c\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext_mem\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext_mem\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003esz\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003ebecomes\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight c\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003echunk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext_mem\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x00010000\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003ewhich happens to be totally unrelated heap memory containing unrelated data in this example.\u003c/p\u003e\n\n\u003cp\u003eAnyway, I think this example of potential RCE is a very arcane cornercase that would only be exploitable on a specific 32 bit architecture+kernel+libc that allows both very high virtual address allocations (0xFFFF0000) and very low virtual address allocations (0x00010000) (or static data residing there ).\u003c/p\u003e\n\n\u003cp\u003eSo because there is a potential remote DoS, and fixing it may prevent an RCE if you will use memarea at more places in the future (ie. it\u0026#39;s implementing a best practice/additional safety guard), and RCE is currently only possible in very unlikely scenario\u0026#39;s (if at all), I fully agree with your grading of \u0026quot;low severity\u0026quot;.\u003c/p\u003e\n\n\u003cp\u003eI think your proposed fix \u003ccode\u003eif sz \u0026gt; chunk-\u0026gt;mem_size\u003c/code\u003e is correct but I\u0026#39;m gonna double check that right now and I\u0026#39;ll get back to it later.\u003c/p\u003e\n\n\u003cp\u003eGuido\u003c/p\u003e\n","automated_response":false,"created_at":"2016-05-17T22:08:01.381Z","updated_at":"2016-05-17T22:08:01.381Z","actor":{"username":"guido","cleared":false,"url":"/guido","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/002/983/e55b0b2324777fb7efc2de4212fd8d337ca816bd_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"torproject","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":966304,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Checking the size directly seems to be the way to go.\n\nIncidentally, someone wrote a blog post on the problem over pointer overflow checks a couple of days ago: https://blog.regehr.org/archives/1395 . In that article he argues that pointer additions resulting in a non-valid pointer address are in fact undefined behavior per the C standard, and while compilers work around this particular pattern introduced by the programmer to avoid problems, it seems that direct size checking (the solution you proposed) is actually the correct way to deal with these kinds of situations.","markdown_message":"\u003cp\u003eChecking the size directly seems to be the way to go.\u003c/p\u003e\n\n\u003cp\u003eIncidentally, someone wrote a blog post on the problem over pointer overflow checks a couple of days ago: \u003ca title=\"https://blog.regehr.org/archives/1395\" href=\"/redirect?url=https%3A%2F%2Fblog.regehr.org%2Farchives%2F1395\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://blog.regehr.org/archives/1395\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e . In that article he argues that pointer additions resulting in a non-valid pointer address are in fact undefined behavior per the C standard, and while compilers work around this particular pattern introduced by the programmer to avoid problems, it seems that direct size checking (the solution you proposed) is actually the correct way to deal with these kinds of situations.\u003c/p\u003e\n","automated_response":false,"created_at":"2016-05-20T13:01:54.078Z","updated_at":"2016-05-20T13:01:54.078Z","actor":{"username":"guido","cleared":false,"url":"/guido","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/002/983/e55b0b2324777fb7efc2de4212fd8d337ca816bd_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"torproject","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":969523,"is_internal":false,"editable":false,"type":"Activities::BountyAwarded","message":" Hello Guido!\n\nWe decided to award $300 to this vulnerability report, for its DoS implications and for future code correctness.\n\nThanks for the report!","markdown_message":"\u003cp\u003eHello Guido!\u003c/p\u003e\n\n\u003cp\u003eWe decided to award $300 to this vulnerability report, for its DoS implications and for future code correctness.\u003c/p\u003e\n\n\u003cp\u003eThanks for the report!\u003c/p\u003e\n","automated_response":false,"created_at":"2016-05-23T08:23:37.499Z","updated_at":"2016-05-23T08:23:37.499Z","actor":{"url":"/torproject","ibb":false,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/001/800/6e575d0a9127b91e83833cf4a9e6be6e8b30cbc3_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"Tor"}},"bounty_amount":"300.0","bounty_currency":"usd","genius_execution_id":null,"team_handle":"torproject","collaborator":{"username":"guido","url":"/guido"},"actor_is_team_member":true,"actor_is_concealed_member":false},{"id":970592,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Thanks!!\n\nPlease mark the report as 'resolved' when you're ready, thanks.\n\nGuido","markdown_message":"\u003cp\u003eThanks!!\u003c/p\u003e\n\n\u003cp\u003ePlease mark the report as \u0026#39;resolved\u0026#39; when you\u0026#39;re ready, thanks.\u003c/p\u003e\n\n\u003cp\u003eGuido\u003c/p\u003e\n","automated_response":false,"created_at":"2016-05-23T18:29:21.413Z","updated_at":"2016-05-23T18:29:21.413Z","actor":{"username":"guido","cleared":false,"url":"/guido","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/002/983/e55b0b2324777fb7efc2de4212fd8d337ca816bd_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"torproject","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":970965,"is_internal":false,"editable":false,"type":"Activities::BugResolved","message":"","markdown_message":"","automated_response":false,"created_at":"2016-05-23T20:59:45.924Z","updated_at":"2016-05-23T20:59:45.924Z","actor":{"username":"asn","cleared":false,"url":"/asn","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":false},"reporter":{"username":"guido","url":"/guido"},"genius_execution_id":null,"team_handle":"torproject","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":2083668,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","markdown_message":"","automated_response":false,"created_at":"2017-10-19T09:35:39.907Z","updated_at":"2017-10-19T09:35:39.907Z","first_to_agree":true,"actor":{"username":"geko","cleared":false,"url":"/geko","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"torproject","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":2083743,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","markdown_message":"","automated_response":false,"created_at":"2017-10-19T10:16:01.390Z","updated_at":"2017-10-19T10:16:01.390Z","actor":{"username":"guido","cleared":false,"url":"/guido","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/002/983/e55b0b2324777fb7efc2de4212fd8d337ca816bd_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"torproject","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":2083744,"is_internal":false,"editable":false,"type":"Activities::ReportBecamePublic","message":"","markdown_message":"","automated_response":false,"created_at":"2017-10-19T10:16:01.436Z","updated_at":"2017-10-19T10:16:01.436Z","actor":{"username":"guido","cleared":false,"url":"/guido","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/002/983/e55b0b2324777fb7efc2de4212fd8d337ca816bd_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"torproject","actor_is_team_member":false,"actor_is_concealed_member":false}],"activity_page_count":1,"activity_page_number":1,"summaries":[{"category":"team","can_view?":true,"can_create?":false},{"category":"researcher","can_view?":true,"can_create?":false}]}