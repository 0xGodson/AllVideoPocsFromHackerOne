{"id":55140,"global_id":"Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC81NTE0MA==","url":"https://hackerone.com/reports/55140","title":"Race Conditions in OAuth 2 API implementations","state":"Closed","substate":"resolved","severity_rating":"medium","readable_substate":"Resolved","created_at":"2015-04-06T23:56:06.373Z","submitted_at":"2015-04-06T23:56:06.373Z","is_member_of_team?":false,"reporter":{"disabled":false,"username":"dor1s","url":"/dor1s","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/017/930/63baa5788d9952bc13497da61518a8902db31756_original.gif/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a"},"is_me?":false,"cleared":false,"hackerone_triager":false,"hacker_mediation":false},"team":{"id":20,"url":"https://hackerone.com/internet","handle":"internet","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/000/020/e3e1c58882b2645d9108ec102731a354cbf5852e_original.png/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a","medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/020/e3e1c58882b2645d9108ec102731a354cbf5852e_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"permissions":[],"submission_state":"open","default_currency":"usd","awards_miles":false,"offers_bounties":true,"state":"public_mode","only_cleared_hackers":false,"profile":{"name":"The Internet","twitter_handle":null,"website":"","about":"Hack all the things."}},"has_bounty?":true,"in_validation?":false,"rejected_anc_report_that_can_be_sent_back_to_anc_triagers?":false,"can_view_team":true,"can_view_report":true,"is_external_bug":false,"is_published":false,"is_participant":false,"stage":4,"public":true,"visibility":"full","cve_ids":[],"singular_disclosure_disabled":false,"disclosed_at":"2017-09-19T17:40:28.080Z","bug_reporter_agreed_on_going_public_at":"2017-09-18T14:10:45.973Z","team_member_agreed_on_going_public_at":"2017-09-19T17:40:28.024Z","comments_closed?":false,"facebook_team?":false,"team_private?":false,"vulnerability_information":"Most of OAuth 2 API implementations seem to have multiple Race Condition vulnerabilities for processing requests for Access Token or Refresh Token.\r\n\r\nRace Condition allows a malicious application to obtain several `access_token` and `refresh_token` pairs while only one pair should be generated. Further, it leads to authorization bypass when access would be revoked.\r\n\r\nI've already tested for this vulnerability 11 different targets (web-services providing OAuth2 API), and 6 of them are vulnerable. Only one target seems to be certainly protected (or I just failed to catch into Race Condition time window). The rest 4 targets have Race Condition bug, but protected against further exploitation by one of the following reasons:\r\n* only one of several tokens generated is valid (**1 target**)\r\n* for any access revocation all tokens always are revoked (**1 target**)\r\n* for all concurring requests finished successfully the same `access_token` values (or in pair with `refresh_token`) obtained (**2 targets**)\r\n\r\nAt this moment I cannot list vulnerable targets here because of responsible disclosure, but I think it would be possible to publish their names soon.\r\n\r\nInitially, I thought the vulnerability is located in [Doorkeeper gem for Ruby](https://github.com/doorkeeper-gem/doorkeeper). It is very popular, and I know that some of the vulnerable targets use this gem. To be clear, I tested [OAuth 2 provider example based on it](https://github.com/doorkeeper-gem/doorkeeper-provider-app) and it was safe for me. *Honestly, I'm not ruby developer, so it is not easy for me to quickly inspect doorkeeper's code and distinguish is it vulnerable or not*.\r\n\r\nHowever, I'm sure that 6 of vulnerable targets use different implementations (at least more than one). So the attack vector seems to be universal and possible by design.\r\n\r\nRace Condition for Access Token\r\n===============================\r\nAccording to [OAuth 2.0 RFC](https://tools.ietf.org/html/rfc6749), `code` obtained via callback may be used only once to generate `access_token` (and corresponding `refresh_token`).\r\n\r\nRace Condition vulnerability allows a malicious application to generate several `access_token` and `refresh_token` pairs. This leads to authentication issue when a user will revoke access for an application. One `access_token` and `refresh_token` pair would be revoked, but all the rest stay active.\r\n\r\nProof-Of-Concept\r\n------------------------\r\n *PoC description is unified and may be used for any provider*\r\n\r\n0) Register an application for using OAuth 2.0 API of the target provider. Obtain credentials for the application\r\n\r\n1) Open link for the application authorization in browser. Usually it looks like:\r\n```\r\nhttps://OAUTH_PROVIDER_DOMAIN/oauth/authorize?client_id=APPLICATION_ID\u0026redirect_uri=https://APPLICATION_REDIRECT_URI\u0026response_type=code\r\n```\r\n\r\n2) Log into *a victim's* account (if it needed) and allow access for the application\r\n\r\n3) Obtain `code` value from callback:\r\n```\r\nhttps://APPLICATION_REDIRECT_URI?code=AUTHORIZATION_CODE_VALUE\r\n```\r\n\r\n4) Try to exploit Race Condition for Access Token request. I used the following script for that:\r\n```\r\n#!/bin/bash\r\ncurl --data \"grant_type=authorization_code\u0026code=AUTHORIZATION_CODE_VALUE\u0026client_id=APPLICATION_ID\u0026client_secret=APPLICATION_SECRET\u0026redirect_uri=APPLICATION_REDIRECT_URI\" \"https://OAUTH_PROVIDER_DOMAIN/oauth/token\" \u0026\r\n\u003c ... previous line repeated 20 times ... \u003e\r\n```\r\n\r\nFor different attempts result of its execution gives from 1 to 20 different `access_token` values (may be in pair with `refresh_token` values) for targets which has Race Condition bug (10 of 11 tested).\r\n\r\n5) Check each `access_token`. Take the simplest request from the target API and try it for each value, like:\r\n```\r\nGET /api/me?access_token=ACCESS_TOKEN_VALUE HTTP/1.1\r\nHost: OAUTH_PROVIDER_DOMAIN\r\n\r\n```\r\n\r\nUsually all `access_token` values are valid and working.\r\n\r\n6) Please note that Race Condition is probabilistic vulnerability. It may be needed to do few attempts with PoC to reproduce it. Attackers usually can generate some additional load to the server (not DoS, but many requests to vulnerable script) to increase the chance of successful exploitation.\r\n\r\n7) Here execution flow has two possible directions:\r\n7A) Go to **settings** or **applications** page in the victim's account and revoke access for the application. Then repeat step 5 and see if all `access_token`s become invalid or not. If all `access_token`s are invalid, It is good behavior despite successful Race Condition exploitation. Actually, in some cases only one `access_token` is revoked, while all the rest stay valid.\r\n\r\n7B) Use revocation request (like `/oauth/revoke`) for one of the `access_token`s. Then repeat step 5 and see that in this case only one token is revoked, while all the rest stay active (except one of the targets tested).\r\n\r\n\r\nRace Condition for Refresh Token\r\n--------------------------------\r\nWhile `code` may be used only once to obtain `access_token`, `refresh_token` often may be used only once too. In such case, Race Condition vulnerability allows an attacker to generate huge number of `access_token` and `refresh_token` pairs. This will make it very hard for a victim to revoke access for the malicious application.\r\n\r\n0) Register an application for using OAuth 2.0 API of the target provider. Obtain credentials for the application\r\n\r\n1) Open link for the application authorization in browser. Usually it looks like:\r\n```\r\nhttps://OAUTH_PROVIDER_DOMAIN/oauth/authorize?client_id=APPLICATION_ID\u0026redirect_uri=https://APPLICATION_REDIRECT_URI\u0026response_type=code\r\n```\r\n\r\n2) Log into *a victim's* account (if it needed) and allow access for the application\r\n\r\n3) Obtain `code` value from callback:\r\n```\r\nhttps://APPLICATION_REDIRECT_URI?code=AUTHORIZATION_CODE_VALUE\r\n```\r\n\r\n4) Legally obtain `access_token` and `refresh_token`. Usually it may be done by request like:\r\n```\r\ncurl --data \"grant_type=authorization_code\u0026code=AUTHORIZATION_CODE_VALUE\u0026client_id=APPLICATION_ID\u0026client_secret=APPLICATION_SECRET\u0026redirect_uri=APPLICATION_REDIRECT_URI\" \"https://OAUTH_PROVIDER_DOMAIN/oauth/token\"\r\n```\r\n\r\n5) Try to exploit Race Condition for `refresh_token`. I used the following script for that:\r\n```\r\n#!/bin/bash\r\ncurl --data \"grant_type=refresh_token\u0026refresh_token=REFRESH_TOKEN_VALUE\u0026client_id=APPLICATION_ID\u0026client_secret=APPLICATION_SECRET\" \"https://OAUTH_PROVIDER_DOMAIN/oauth/token\" \u0026\r\n\u003c ... previous line repeated 20 times ... \u003e\r\n\r\n```\r\n\r\nFor different attempts result of its execution gives from 1 to 20 different `access_token` values (may be in pair with `refresh_token` values) for targets which has Race Condition bug.\r\n\r\n6) Check obtained `access_token`s as in previous Proof-of-Concept. All of them are valid and working for API.\r\n\r\n7) Please note that Race Condition is probabilistic vulnerability. It may be needed to do few attempts with PoC to reproduce it. Attackers usually can generate some additional load to the server (not DoS, but many requests to vulnerable script) to increase the chance of successful exploitation.\r\n\r\n8) Here execution flow has two possible directions:\r\n8A) Go to **settings** or **applications** page in the victim's account and revoke access for the application. Then repeat step 5 and see if all `access_token`s become invalid or not. If all `access_token`s are invalid, It is good behavior despite successful Race Condition exploitation. Actually, in some cases only one `access_token` is revoked, while all the rest stay valid.\r\n\r\n8B) Use revocation request (like `/oauth/revoke`) for one of the `access_token`s. Then repeat step 5 and see that in this case only one token is revoked, while all the rest stay active (except one of the targets tested).\r\n\r\n\r\nExploitation for `refresh_token` is more dangerous than for `access_token`, because there is no way for an attacker to fail. Each exploitation gives at least one new `refresh_token` which may be used further. Thus, number of token pairs grows exponentially.\r\n\r\nImpact\r\n======\r\nGenerating huge number of tokens for access is serious issue which violates [OAuth framework RFC](https://tools.ietf.org/html/rfc6749) and best practices. This vulnerability deprives a victim of ability to deny access for malicious application (for most of implementations tested).\r\n\r\nBecause of target (e.g `/oauth/token`) script is vulnerable to Race Condition, there are more attack vectors than I demonstrated. For example, an application may infinitely refresh its access and user would not be able to revoke access too.\r\n\r\nPut it simply\r\n-----------------\r\nOAuth API is widespread mechanism nowadays. Number of different services and applications increases so fast, that almost no one wants to have so many different accounts for all of them. This is why OAuth is popular and important. But, on the other hand, no one wants to grant access to yet another one service/application, if he knows that it is impossible for him to revoke deny access later. This is why such bypassing of access revocation should be prevented.\r\n\r\n","vulnerability_information_html":"\u003cp\u003eMost of OAuth 2 API implementations seem to have multiple Race Condition vulnerabilities for processing requests for Access Token or Refresh Token.\u003c/p\u003e\n\n\u003cp\u003eRace Condition allows a malicious application to obtain several \u003ccode\u003eaccess_token\u003c/code\u003e and \u003ccode\u003erefresh_token\u003c/code\u003e pairs while only one pair should be generated. Further, it leads to authorization bypass when access would be revoked.\u003c/p\u003e\n\n\u003cp\u003eI\u0026#39;ve already tested for this vulnerability 11 different targets (web-services providing OAuth2 API), and 6 of them are vulnerable. Only one target seems to be certainly protected (or I just failed to catch into Race Condition time window). The rest 4 targets have Race Condition bug, but protected against further exploitation by one of the following reasons:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eonly one of several tokens generated is valid (\u003cstrong\u003e1 target\u003c/strong\u003e)\u003c/li\u003e\n\u003cli\u003efor any access revocation all tokens always are revoked (\u003cstrong\u003e1 target\u003c/strong\u003e)\u003c/li\u003e\n\u003cli\u003efor all concurring requests finished successfully the same \u003ccode\u003eaccess_token\u003c/code\u003e values (or in pair with \u003ccode\u003erefresh_token\u003c/code\u003e) obtained (\u003cstrong\u003e2 targets\u003c/strong\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eAt this moment I cannot list vulnerable targets here because of responsible disclosure, but I think it would be possible to publish their names soon.\u003c/p\u003e\n\n\u003cp\u003eInitially, I thought the vulnerability is located in \u003ca href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fdoorkeeper-gem%2Fdoorkeeper\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003eDoorkeeper gem for Ruby\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e. It is very popular, and I know that some of the vulnerable targets use this gem. To be clear, I tested \u003ca href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fdoorkeeper-gem%2Fdoorkeeper-provider-app\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003eOAuth 2 provider example based on it\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e and it was safe for me. \u003cem\u003eHonestly, I\u0026#39;m not ruby developer, so it is not easy for me to quickly inspect doorkeeper\u0026#39;s code and distinguish is it vulnerable or not\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eHowever, I\u0026#39;m sure that 6 of vulnerable targets use different implementations (at least more than one). So the attack vector seems to be universal and possible by design.\u003c/p\u003e\n\n\u003ch1 id=\"race-condition-for-access-token\"\u003eRace Condition for Access Token\u003c/h1\u003e\n\n\u003cp\u003eAccording to \u003ca href=\"/redirect?url=https%3A%2F%2Ftools.ietf.org%2Fhtml%2Frfc6749\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003eOAuth 2.0 RFC\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e, \u003ccode\u003ecode\u003c/code\u003e obtained via callback may be used only once to generate \u003ccode\u003eaccess_token\u003c/code\u003e (and corresponding \u003ccode\u003erefresh_token\u003c/code\u003e).\u003c/p\u003e\n\n\u003cp\u003eRace Condition vulnerability allows a malicious application to generate several \u003ccode\u003eaccess_token\u003c/code\u003e and \u003ccode\u003erefresh_token\u003c/code\u003e pairs. This leads to authentication issue when a user will revoke access for an application. One \u003ccode\u003eaccess_token\u003c/code\u003e and \u003ccode\u003erefresh_token\u003c/code\u003e pair would be revoked, but all the rest stay active.\u003c/p\u003e\n\n\u003ch2 id=\"proof-of-concept\"\u003eProof-Of-Concept\u003c/h2\u003e\n\n\u003cp\u003e\u003cem\u003ePoC description is unified and may be used for any provider\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003e0) Register an application for using OAuth 2.0 API of the target provider. Obtain credentials for the application\u003c/p\u003e\n\n\u003cp\u003e1) Open link for the application authorization in browser. Usually it looks like:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003ehttps://OAUTH_PROVIDER_DOMAIN/oauth/authorize?client_id=APPLICATION_ID\u0026amp;redirect_uri=https://APPLICATION_REDIRECT_URI\u0026amp;response_type=code\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e2) Log into \u003cem\u003ea victim\u0026#39;s\u003c/em\u003e account (if it needed) and allow access for the application\u003c/p\u003e\n\n\u003cp\u003e3) Obtain \u003ccode\u003ecode\u003c/code\u003e value from callback:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003ehttps://APPLICATION_REDIRECT_URI?code=AUTHORIZATION_CODE_VALUE\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e4) Try to exploit Race Condition for Access Token request. I used the following script for that:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight shell\"\u003e\u003ccode\u003e\u003cspan class=\"c\"\u003e#!/bin/bash\u003c/span\u003e\ncurl \u003cspan class=\"nt\"\u003e--data\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026quot;grant_type=authorization_code\u0026amp;code=AUTHORIZATION_CODE_VALUE\u0026amp;client_id=APPLICATION_ID\u0026amp;client_secret=APPLICATION_SECRET\u0026amp;redirect_uri=APPLICATION_REDIRECT_URI\u0026quot;\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026quot;https://OAUTH_PROVIDER_DOMAIN/oauth/token\u0026quot;\u003c/span\u003e \u0026amp;\n\u0026lt; ... previous line repeated 20 \u003cspan class=\"nb\"\u003etimes\u003c/span\u003e ... \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eFor different attempts result of its execution gives from 1 to 20 different \u003ccode\u003eaccess_token\u003c/code\u003e values (may be in pair with \u003ccode\u003erefresh_token\u003c/code\u003e values) for targets which has Race Condition bug (10 of 11 tested).\u003c/p\u003e\n\n\u003cp\u003e5) Check each \u003ccode\u003eaccess_token\u003c/code\u003e. Take the simplest request from the target API and try it for each value, like:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003eGET /api/me?access_token=ACCESS_TOKEN_VALUE HTTP/1.1\nHost: OAUTH_PROVIDER_DOMAIN\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eUsually all \u003ccode\u003eaccess_token\u003c/code\u003e values are valid and working.\u003c/p\u003e\n\n\u003cp\u003e6) Please note that Race Condition is probabilistic vulnerability. It may be needed to do few attempts with PoC to reproduce it. Attackers usually can generate some additional load to the server (not DoS, but many requests to vulnerable script) to increase the chance of successful exploitation.\u003c/p\u003e\n\n\u003cp\u003e7) Here execution flow has two possible directions:\u003cbr\u003e\n7A) Go to \u003cstrong\u003esettings\u003c/strong\u003e or \u003cstrong\u003eapplications\u003c/strong\u003e page in the victim\u0026#39;s account and revoke access for the application. Then repeat step 5 and see if all \u003ccode\u003eaccess_token\u003c/code\u003es become invalid or not. If all \u003ccode\u003eaccess_token\u003c/code\u003es are invalid, It is good behavior despite successful Race Condition exploitation. Actually, in some cases only one \u003ccode\u003eaccess_token\u003c/code\u003e is revoked, while all the rest stay valid.\u003c/p\u003e\n\n\u003cp\u003e7B) Use revocation request (like \u003ccode\u003e/oauth/revoke\u003c/code\u003e) for one of the \u003ccode\u003eaccess_token\u003c/code\u003es. Then repeat step 5 and see that in this case only one token is revoked, while all the rest stay active (except one of the targets tested).\u003c/p\u003e\n\n\u003ch2 id=\"race-condition-for-refresh-token\"\u003eRace Condition for Refresh Token\u003c/h2\u003e\n\n\u003cp\u003eWhile \u003ccode\u003ecode\u003c/code\u003e may be used only once to obtain \u003ccode\u003eaccess_token\u003c/code\u003e, \u003ccode\u003erefresh_token\u003c/code\u003e often may be used only once too. In such case, Race Condition vulnerability allows an attacker to generate huge number of \u003ccode\u003eaccess_token\u003c/code\u003e and \u003ccode\u003erefresh_token\u003c/code\u003e pairs. This will make it very hard for a victim to revoke access for the malicious application.\u003c/p\u003e\n\n\u003cp\u003e0) Register an application for using OAuth 2.0 API of the target provider. Obtain credentials for the application\u003c/p\u003e\n\n\u003cp\u003e1) Open link for the application authorization in browser. Usually it looks like:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003ehttps://OAUTH_PROVIDER_DOMAIN/oauth/authorize?client_id=APPLICATION_ID\u0026amp;redirect_uri=https://APPLICATION_REDIRECT_URI\u0026amp;response_type=code\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e2) Log into \u003cem\u003ea victim\u0026#39;s\u003c/em\u003e account (if it needed) and allow access for the application\u003c/p\u003e\n\n\u003cp\u003e3) Obtain \u003ccode\u003ecode\u003c/code\u003e value from callback:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003ehttps://APPLICATION_REDIRECT_URI?code=AUTHORIZATION_CODE_VALUE\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e4) Legally obtain \u003ccode\u003eaccess_token\u003c/code\u003e and \u003ccode\u003erefresh_token\u003c/code\u003e. Usually it may be done by request like:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003ecurl --data \u0026quot;grant_type=authorization_code\u0026amp;code=AUTHORIZATION_CODE_VALUE\u0026amp;client_id=APPLICATION_ID\u0026amp;client_secret=APPLICATION_SECRET\u0026amp;redirect_uri=APPLICATION_REDIRECT_URI\u0026quot; \u0026quot;https://OAUTH_PROVIDER_DOMAIN/oauth/token\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e5) Try to exploit Race Condition for \u003ccode\u003erefresh_token\u003c/code\u003e. I used the following script for that:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight shell\"\u003e\u003ccode\u003e\u003cspan class=\"c\"\u003e#!/bin/bash\u003c/span\u003e\ncurl \u003cspan class=\"nt\"\u003e--data\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026quot;grant_type=refresh_token\u0026amp;refresh_token=REFRESH_TOKEN_VALUE\u0026amp;client_id=APPLICATION_ID\u0026amp;client_secret=APPLICATION_SECRET\u0026quot;\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026quot;https://OAUTH_PROVIDER_DOMAIN/oauth/token\u0026quot;\u003c/span\u003e \u0026amp;\n\u0026lt; ... previous line repeated 20 \u003cspan class=\"nb\"\u003etimes\u003c/span\u003e ... \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eFor different attempts result of its execution gives from 1 to 20 different \u003ccode\u003eaccess_token\u003c/code\u003e values (may be in pair with \u003ccode\u003erefresh_token\u003c/code\u003e values) for targets which has Race Condition bug.\u003c/p\u003e\n\n\u003cp\u003e6) Check obtained \u003ccode\u003eaccess_token\u003c/code\u003es as in previous Proof-of-Concept. All of them are valid and working for API.\u003c/p\u003e\n\n\u003cp\u003e7) Please note that Race Condition is probabilistic vulnerability. It may be needed to do few attempts with PoC to reproduce it. Attackers usually can generate some additional load to the server (not DoS, but many requests to vulnerable script) to increase the chance of successful exploitation.\u003c/p\u003e\n\n\u003cp\u003e8) Here execution flow has two possible directions:\u003cbr\u003e\n8A) Go to \u003cstrong\u003esettings\u003c/strong\u003e or \u003cstrong\u003eapplications\u003c/strong\u003e page in the victim\u0026#39;s account and revoke access for the application. Then repeat step 5 and see if all \u003ccode\u003eaccess_token\u003c/code\u003es become invalid or not. If all \u003ccode\u003eaccess_token\u003c/code\u003es are invalid, It is good behavior despite successful Race Condition exploitation. Actually, in some cases only one \u003ccode\u003eaccess_token\u003c/code\u003e is revoked, while all the rest stay valid.\u003c/p\u003e\n\n\u003cp\u003e8B) Use revocation request (like \u003ccode\u003e/oauth/revoke\u003c/code\u003e) for one of the \u003ccode\u003eaccess_token\u003c/code\u003es. Then repeat step 5 and see that in this case only one token is revoked, while all the rest stay active (except one of the targets tested).\u003c/p\u003e\n\n\u003cp\u003eExploitation for \u003ccode\u003erefresh_token\u003c/code\u003e is more dangerous than for \u003ccode\u003eaccess_token\u003c/code\u003e, because there is no way for an attacker to fail. Each exploitation gives at least one new \u003ccode\u003erefresh_token\u003c/code\u003e which may be used further. Thus, number of token pairs grows exponentially.\u003c/p\u003e\n\n\u003ch1 id=\"impact\"\u003eImpact\u003c/h1\u003e\n\n\u003cp\u003eGenerating huge number of tokens for access is serious issue which violates \u003ca href=\"/redirect?url=https%3A%2F%2Ftools.ietf.org%2Fhtml%2Frfc6749\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003eOAuth framework RFC\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e and best practices. This vulnerability deprives a victim of ability to deny access for malicious application (for most of implementations tested).\u003c/p\u003e\n\n\u003cp\u003eBecause of target (e.g \u003ccode\u003e/oauth/token\u003c/code\u003e) script is vulnerable to Race Condition, there are more attack vectors than I demonstrated. For example, an application may infinitely refresh its access and user would not be able to revoke access too.\u003c/p\u003e\n\n\u003ch2 id=\"put-it-simply\"\u003ePut it simply\u003c/h2\u003e\n\n\u003cp\u003eOAuth API is widespread mechanism nowadays. Number of different services and applications increases so fast, that almost no one wants to have so many different accounts for all of them. This is why OAuth is popular and important. But, on the other hand, no one wants to grant access to yet another one service/application, if he knows that it is impossible for him to revoke deny access later. This is why such bypassing of access revocation should be prevented.\u003c/p\u003e\n","bounty_amount":"2500.0","formatted_bounty":"$2,500","weakness":{"id":27,"name":"Improper Authentication - Generic"},"original_report_id":null,"original_report_url":null,"attachments":[],"allow_singular_disclosure_at":"2017-10-18T14:10:46.031Z","allow_singular_disclosure_after":-100886956.49783476,"singular_disclosure_allowed":true,"vote_count":33,"voters":["flamezzz","sp1d3rs","shailesh4594","bl4de","fizhimchik","ivodafon","reactors08","003random","skavans","w2w","and 23 more..."],"severity":{"rating":"medium","author_type":"Team"},"structured_scope":null,"abilities":{"assignable_team_members":[],"assignable_team_member_groups":[]},"can_edit_custom_fields_attributes":false,"activities":[{"id":375049,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Just to update statistics. I've tested two more OAuth providers, Both of them have Race Conditions:\n* 1 is vulnerable to abuse with multiple tokens generation\n* 1 is protected from exploitation because all tokens become revoked ","markdown_message":"\u003cp\u003eJust to update statistics. I\u0026#39;ve tested two more OAuth providers, Both of them have Race Conditions:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e1 is vulnerable to abuse with multiple tokens generation\u003c/li\u003e\n\u003cli\u003e1 is protected from exploitation because all tokens become revoked \u003c/li\u003e\n\u003c/ul\u003e\n","automated_response":false,"created_at":"2015-04-08T13:31:21.071Z","updated_at":"2015-04-08T13:31:21.071Z","actor":{"username":"dor1s","cleared":false,"url":"/dor1s","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/017/930/63baa5788d9952bc13497da61518a8902db31756_original.gif/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"internet","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":379323,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Let me update statistics one more time. I've tested 5 more OAuth providers (in addition to previous research):\n* 3 are vulnerable to multiple tokens generation\n* 2 are protected against this","markdown_message":"\u003cp\u003eLet me update statistics one more time. I\u0026#39;ve tested 5 more OAuth providers (in addition to previous research):\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e3 are vulnerable to multiple tokens generation\u003c/li\u003e\n\u003cli\u003e2 are protected against this\u003c/li\u003e\n\u003c/ul\u003e\n","automated_response":false,"created_at":"2015-04-13T23:49:48.463Z","updated_at":"2015-04-13T23:49:48.463Z","actor":{"username":"dor1s","cleared":false,"url":"/dor1s","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/017/930/63baa5788d9952bc13497da61518a8902db31756_original.gif/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"internet","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":386080,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"More updates and statistics summary at the moment:\n* 27 OAuth2 providers had been tested, of which\n* 21 had Race Condition bugs\n* 15 affected with multiple valid access tokens generated via Race Condition exploitation\n* 9   had authorization flaws caused by inappropriate access revocation processing after Race Condition exploitation","markdown_message":"\u003cp\u003eMore updates and statistics summary at the moment:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e27 OAuth2 providers had been tested, of which\u003c/li\u003e\n\u003cli\u003e21 had Race Condition bugs\u003c/li\u003e\n\u003cli\u003e15 affected with multiple valid access tokens generated via Race Condition exploitation\u003c/li\u003e\n\u003cli\u003e9   had authorization flaws caused by inappropriate access revocation processing after Race Condition exploitation\u003c/li\u003e\n\u003c/ul\u003e\n","automated_response":false,"created_at":"2015-04-21T01:15:23.322Z","updated_at":"2015-04-21T01:15:23.322Z","actor":{"username":"dor1s","cleared":false,"url":"/dor1s","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/017/930/63baa5788d9952bc13497da61518a8902db31756_original.gif/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"internet","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":386637,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"I was referring OAuth2.0 RFC, but not posted direct requirements which are violated by exploitable Race Condition vulnerability. Here it is:\n\n1) [https://tools.ietf.org/html/rfc6749#section-4.1.2](https://tools.ietf.org/html/rfc6749#section-4.1.2) :\n```\n                        If an authorization code is used more than\n   once, the authorization server MUST deny the request and SHOULD\n   revoke (when possible) all tokens previously issued based on\n   that authorization code.  The authorization code is bound to\n   the client identifier and redirection URI.\n```\n2) [https://tools.ietf.org/html/rfc6749#section-10.5](https://tools.ietf.org/html/rfc6749#section-10.5) :\n```\n   Authorization codes MUST be short lived and single-use.  If the\n   authorization server observes multiple attempts to exchange an\n   authorization code for an access token, the authorization server\n   SHOULD attempt to revoke all access tokens already granted based on\n   the compromised authorization code.\n```","markdown_message":"\u003cp\u003eI was referring OAuth2.0 RFC, but not posted direct requirements which are violated by exploitable Race Condition vulnerability. Here it is:\u003c/p\u003e\n\n\u003cp\u003e1) \u003ca href=\"/redirect?url=https%3A%2F%2Ftools.ietf.org%2Fhtml%2Frfc6749%23section-4.1.2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://tools.ietf.org/html/rfc6749#section-4.1.2\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e :\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e                        If an authorization code is used more than\n   once, the authorization server MUST deny the request and SHOULD\n   revoke (when possible) all tokens previously issued based on\n   that authorization code.  The authorization code is bound to\n   the client identifier and redirection URI.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e2) \u003ca href=\"/redirect?url=https%3A%2F%2Ftools.ietf.org%2Fhtml%2Frfc6749%23section-10.5\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://tools.ietf.org/html/rfc6749#section-10.5\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e :\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e   Authorization codes MUST be short lived and single-use.  If the\n   authorization server observes multiple attempts to exchange an\n   authorization code for an access token, the authorization server\n   SHOULD attempt to revoke all access tokens already granted based on\n   the compromised authorization code.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","automated_response":false,"created_at":"2015-04-21T19:06:35.115Z","updated_at":"2015-04-21T19:06:35.115Z","actor":{"username":"dor1s","cleared":false,"url":"/dor1s","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/017/930/63baa5788d9952bc13497da61518a8902db31756_original.gif/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"internet","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":386701,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"I continue my research of OAuth2 implementations and found one more wide-spread attack vector. It is related to inappropriate access revocation too, so let me describe it here in comments.\n\nDetails:\n----------\nOAuth2 API makes it possible for users to grant access to their accounts to some third-side applications. Of course, users are able to manage such applications' access to their accounts and may deny access for any application. When some user denies access for the application, all `access_token`s (and `refresh_tokens` if it used) are being revoked and become invalid. But not only `access_token`s should be revoked, authorization `code`s (it is intermediate token used in OAuth2 Authorization Flow) must be revoked too. Currently most of OAuth2 API implementations do not revoke authorization `code` during access revocation. It may be exploited to restore access to user's account by malicious application after access revocation.\n\nStatistics at the moment\n-----------------------------------\n* 21 OAuth2 providers had been tested, of which\n* 11 affected with missing invalidation for authorization code after access revocation\n* 10 invalidate all authorization codes granted for certain pair of user and application\n\nProof of Concept\n------------------------\n1) Open the link for OAuth2 authorization for some application\n2) Log into your account (if needed) and click **Allow** (or **Authorize**)\n3) Copy `code` value from callback url\n4) Use `code` value to obtain `access_token`\n5) Check validity of `access_token` by sending some API request\n6) Repeat steps 1 and 2 (for most of implementations user is automatically redirected to callback page if once access granted)\n7) Copy `code` value from callback url and save it for future usage\n8) Go to account security (or *connected applications*) settings\n9) **Delete** or **Disconnect** the application used during the PoC\n10) To ensure that access is denied, repeat step 5\n11) Use `code` value from step 7 and exchange it for `access_token`\n12) Check validity of `access_token`\n\nIf `access_token` is valid, OAuth2 Provider is affected by the vulnerability.\n\nImportant notice\n------------------------\nFor real attack scenario it is important to mention the following:\na) it seems that step 6 requires interaction with user, actually it is not necessary\nb) authorization `code` obtained via callback has certain lifetime, but it is not problem too\n\nMalicious application which does not want to lose access to the user's account just need to place on its web site something like:\n```\n\u003chtml\u003e\n\t\u003cimg src=\"https://OAUTH2-PROVIDER-DOMAIN/oauth2/authorize?client_id=%CLIENT_ID%\u0026response_type=code\u0026redirect_uri=https://avuln.com/callback\u0026state=0123456789abcdef\"\u003e\n\u003c/html\u003e\n```\n\nSuch code will \"silently\" produce new authorization code each time it has been loaded by the user:\n```\nroot@avuln:/var/log/nginx# tail -f access.log\n\u003c...\u003e\n\u003cIP hidden\u003e - - [16/Apr/2015:13:08:56 +0000] \"GET /callback?state=0123456789abcdef\u0026code=xlDxVYdnJlsAAAAAAAAFQDUmzla7P8Jg9fM2rNxwP8U HTTP/1.1\" 200 14 \"-\" \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.118 Safari/537.36\"\n```\n\nImpact\n======\nThe vulnerability allows an malicious application to keep its access active to a victim's account even after access revocation. This is not only authorization bypass, but it also deprives a victim ability to manage access for an application.\n\nMitigation\n========\nFor access revocation processing all authorization `code` issued for certain pair of user and application should be invalidated (as it usually being done for `access_token` values).\n","markdown_message":"\u003cp\u003eI continue my research of OAuth2 implementations and found one more wide-spread attack vector. It is related to inappropriate access revocation too, so let me describe it here in comments.\u003c/p\u003e\n\n\u003ch2 id=\"details\"\u003eDetails:\u003c/h2\u003e\n\n\u003cp\u003eOAuth2 API makes it possible for users to grant access to their accounts to some third-side applications. Of course, users are able to manage such applications\u0026#39; access to their accounts and may deny access for any application. When some user denies access for the application, all \u003ccode\u003eaccess_token\u003c/code\u003es (and \u003ccode\u003erefresh_tokens\u003c/code\u003e if it used) are being revoked and become invalid. But not only \u003ccode\u003eaccess_token\u003c/code\u003es should be revoked, authorization \u003ccode\u003ecode\u003c/code\u003es (it is intermediate token used in OAuth2 Authorization Flow) must be revoked too. Currently most of OAuth2 API implementations do not revoke authorization \u003ccode\u003ecode\u003c/code\u003e during access revocation. It may be exploited to restore access to user\u0026#39;s account by malicious application after access revocation.\u003c/p\u003e\n\n\u003ch2 id=\"statistics-at-the-moment\"\u003eStatistics at the moment\u003c/h2\u003e\n\n\u003cul\u003e\n\u003cli\u003e21 OAuth2 providers had been tested, of which\u003c/li\u003e\n\u003cli\u003e11 affected with missing invalidation for authorization code after access revocation\u003c/li\u003e\n\u003cli\u003e10 invalidate all authorization codes granted for certain pair of user and application\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"proof-of-concept\"\u003eProof of Concept\u003c/h2\u003e\n\n\u003cp\u003e1) Open the link for OAuth2 authorization for some application\u003cbr\u003e\n2) Log into your account (if needed) and click \u003cstrong\u003eAllow\u003c/strong\u003e (or \u003cstrong\u003eAuthorize\u003c/strong\u003e)\u003cbr\u003e\n3) Copy \u003ccode\u003ecode\u003c/code\u003e value from callback url\u003cbr\u003e\n4) Use \u003ccode\u003ecode\u003c/code\u003e value to obtain \u003ccode\u003eaccess_token\u003c/code\u003e\u003cbr\u003e\n5) Check validity of \u003ccode\u003eaccess_token\u003c/code\u003e by sending some API request\u003cbr\u003e\n6) Repeat steps 1 and 2 (for most of implementations user is automatically redirected to callback page if once access granted)\u003cbr\u003e\n7) Copy \u003ccode\u003ecode\u003c/code\u003e value from callback url and save it for future usage\u003cbr\u003e\n8) Go to account security (or \u003cem\u003econnected applications\u003c/em\u003e) settings\u003cbr\u003e\n9) \u003cstrong\u003eDelete\u003c/strong\u003e or \u003cstrong\u003eDisconnect\u003c/strong\u003e the application used during the PoC\u003cbr\u003e\n10) To ensure that access is denied, repeat step 5\u003cbr\u003e\n11) Use \u003ccode\u003ecode\u003c/code\u003e value from step 7 and exchange it for \u003ccode\u003eaccess_token\u003c/code\u003e\u003cbr\u003e\n12) Check validity of \u003ccode\u003eaccess_token\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eIf \u003ccode\u003eaccess_token\u003c/code\u003e is valid, OAuth2 Provider is affected by the vulnerability.\u003c/p\u003e\n\n\u003ch2 id=\"important-notice\"\u003eImportant notice\u003c/h2\u003e\n\n\u003cp\u003eFor real attack scenario it is important to mention the following:\u003cbr\u003e\na) it seems that step 6 requires interaction with user, actually it is not necessary\u003cbr\u003e\nb) authorization \u003ccode\u003ecode\u003c/code\u003e obtained via callback has certain lifetime, but it is not problem too\u003c/p\u003e\n\n\u003cp\u003eMalicious application which does not want to lose access to the user\u0026#39;s account just need to place on its web site something like:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight html\"\u003e\u003ccode\u003e\u003cspan class=\"nt\"\u003e\u0026lt;html\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"nt\"\u003e\u0026lt;img\u003c/span\u003e \u003cspan class=\"na\"\u003esrc=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026quot;https://OAUTH2-PROVIDER-DOMAIN/oauth2/authorize?client_id=%CLIENT_ID%\u0026amp;response_type=code\u0026amp;redirect_uri=https://avuln.com/callback\u0026amp;state=0123456789abcdef\u0026quot;\u003c/span\u003e\u003cspan class=\"nt\"\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"nt\"\u003e\u0026lt;/html\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eSuch code will \u0026quot;silently\u0026quot; produce new authorization code each time it has been loaded by the user:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003eroot@avuln:/var/log/nginx# tail -f access.log\n\u0026lt;...\u0026gt;\n\u0026lt;IP hidden\u0026gt; - - [16/Apr/2015:13:08:56 +0000] \u0026quot;GET /callback?state=0123456789abcdef\u0026amp;code=xlDxVYdnJlsAAAAAAAAFQDUmzla7P8Jg9fM2rNxwP8U HTTP/1.1\u0026quot; 200 14 \u0026quot;-\u0026quot; \u0026quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.118 Safari/537.36\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch1 id=\"impact\"\u003eImpact\u003c/h1\u003e\n\n\u003cp\u003eThe vulnerability allows an malicious application to keep its access active to a victim\u0026#39;s account even after access revocation. This is not only authorization bypass, but it also deprives a victim ability to manage access for an application.\u003c/p\u003e\n\n\u003ch1 id=\"mitigation\"\u003eMitigation\u003c/h1\u003e\n\n\u003cp\u003eFor access revocation processing all authorization \u003ccode\u003ecode\u003c/code\u003e issued for certain pair of user and application should be invalidated (as it usually being done for \u003ccode\u003eaccess_token\u003c/code\u003e values).\u003c/p\u003e\n","automated_response":false,"created_at":"2015-04-21T20:20:24.173Z","updated_at":"2015-04-21T20:20:24.173Z","actor":{"username":"dor1s","cleared":false,"url":"/dor1s","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/017/930/63baa5788d9952bc13497da61518a8902db31756_original.gif/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"internet","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":475016,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"I've already prepared detailed write-up with recommendations, but cannot make it public, because not all affected providers had fixed the vulnerabilities yet.\n\nA few updates on statistics:\n\nRace Condition issue\n----------------------------------------\n* **28** OAuth providers tested\n* **23** of **28** had race condition bug, of them:\n* **5** providers produced the same `access_token` value for successful competing requests -\u0026gt; good behavior\n* **1** provider produce different `access_token` values, but only one value is valid -\u0026gt; not bad behavior too\n* **17** providers produce different `access_token` values and all of them are valid -\u0026gt; bad behaviour: **RFC violated** + **unexpected flaws** caused by multiple tokens/contexts generation **are possible**\n* **10** of **17** providers had problems with revocation of access (step 8 from PoC succeeded for them) -\u0026gt; **the worst case**: a victim sees that access is revoked, but actually *malicious* application still has access to a victim's account\n\n\nMissing revocation of Authorization Code\n-------------------------------------------------------\n* **25** OAuth providers tested\n* **14** of **25** had the vulnerability\n\n3 OAuth providers from statistics for the first issue are not included in the second one (**28 - 25 = 3**), because they have problems with revocation - it is not implemented at all or is inaccessible for user.\n","markdown_message":"\u003cp\u003eI\u0026#39;ve already prepared detailed write-up with recommendations, but cannot make it public, because not all affected providers had fixed the vulnerabilities yet.\u003c/p\u003e\n\n\u003cp\u003eA few updates on statistics:\u003c/p\u003e\n\n\u003ch2 id=\"race-condition-issue\"\u003eRace Condition issue\u003c/h2\u003e\n\n\u003cul\u003e\n\u003cli\u003e\n\u003cstrong\u003e28\u003c/strong\u003e OAuth providers tested\u003c/li\u003e\n\u003cli\u003e\n\u003cstrong\u003e23\u003c/strong\u003e of \u003cstrong\u003e28\u003c/strong\u003e had race condition bug, of them:\u003c/li\u003e\n\u003cli\u003e\n\u003cstrong\u003e5\u003c/strong\u003e providers produced the same \u003ccode\u003eaccess_token\u003c/code\u003e value for successful competing requests -\u0026gt; good behavior\u003c/li\u003e\n\u003cli\u003e\n\u003cstrong\u003e1\u003c/strong\u003e provider produce different \u003ccode\u003eaccess_token\u003c/code\u003e values, but only one value is valid -\u0026gt; not bad behavior too\u003c/li\u003e\n\u003cli\u003e\n\u003cstrong\u003e17\u003c/strong\u003e providers produce different \u003ccode\u003eaccess_token\u003c/code\u003e values and all of them are valid -\u0026gt; bad behaviour: \u003cstrong\u003eRFC violated\u003c/strong\u003e + \u003cstrong\u003eunexpected flaws\u003c/strong\u003e caused by multiple tokens/contexts generation \u003cstrong\u003eare possible\u003c/strong\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cstrong\u003e10\u003c/strong\u003e of \u003cstrong\u003e17\u003c/strong\u003e providers had problems with revocation of access (step 8 from PoC succeeded for them) -\u0026gt; \u003cstrong\u003ethe worst case\u003c/strong\u003e: a victim sees that access is revoked, but actually \u003cem\u003emalicious\u003c/em\u003e application still has access to a victim\u0026#39;s account\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"missing-revocation-of-authorization-code\"\u003eMissing revocation of Authorization Code\u003c/h2\u003e\n\n\u003cul\u003e\n\u003cli\u003e\n\u003cstrong\u003e25\u003c/strong\u003e OAuth providers tested\u003c/li\u003e\n\u003cli\u003e\n\u003cstrong\u003e14\u003c/strong\u003e of \u003cstrong\u003e25\u003c/strong\u003e had the vulnerability\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e3 OAuth providers from statistics for the first issue are not included in the second one (\u003cstrong\u003e28 - 25 = 3\u003c/strong\u003e), because they have problems with revocation - it is not implemented at all or is inaccessible for user.\u003c/p\u003e\n","automated_response":false,"created_at":"2015-06-17T09:48:26.415Z","updated_at":"2015-06-17T09:49:15.770Z","actor":{"username":"dor1s","cleared":false,"url":"/dor1s","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/017/930/63baa5788d9952bc13497da61518a8902db31756_original.gif/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"internet","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":498983,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Two more targets tested, both have race condition, one has problem with code revocation. The issue is very widely spread :)","markdown_message":"\u003cp\u003eTwo more targets tested, both have race condition, one has problem with code revocation. The issue is very widely spread :)\u003c/p\u003e\n","automated_response":false,"created_at":"2015-07-03T10:19:44.919Z","updated_at":"2015-07-03T10:19:44.919Z","actor":{"username":"dor1s","cleared":false,"url":"/dor1s","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/017/930/63baa5788d9952bc13497da61518a8902db31756_original.gif/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"internet","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":1029282,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Any chance to get a response here? :)","markdown_message":"\u003cp\u003eAny chance to get a response here? :)\u003c/p\u003e\n","automated_response":false,"created_at":"2016-06-22T21:48:54.769Z","updated_at":"2016-06-22T21:48:54.769Z","actor":{"username":"dor1s","cleared":false,"url":"/dor1s","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/017/930/63baa5788d9952bc13497da61518a8902db31756_original.gif/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"internet","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":1709718,"is_internal":false,"editable":false,"type":"Activities::ReportSeverityUpdated","message":"","markdown_message":"","automated_response":false,"created_at":"2017-05-30T14:49:30.954Z","updated_at":"2017-05-30T14:49:30.954Z","additional_data":{"old_severity":null,"new_severity":"Medium","old_severity_id":null,"new_severity_id":45772},"actor":{"username":"arice","cleared":false,"url":"/arice","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/020/83152cb2d070f3f6a63c1b61bae47257722b5ad2_original.jpeg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":true},"genius_execution_id":null,"team_handle":"internet","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":1709721,"is_internal":false,"editable":false,"type":"Activities::BountyAwarded","message":"","markdown_message":"","automated_response":false,"created_at":"2017-05-30T14:49:40.130Z","updated_at":"2017-05-30T14:49:40.130Z","actor":{"url":"/internet","ibb":true,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/020/e3e1c58882b2645d9108ec102731a354cbf5852e_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"The Internet"}},"bounty_amount":"2500.0","bounty_currency":"usd","bonus_amount":"0.0","genius_execution_id":null,"team_handle":"internet","collaborator":{"username":"dor1s","url":"/dor1s"},"actor_is_team_member":false,"actor_is_concealed_member":false},{"id":1709723,"is_internal":false,"editable":false,"type":"Activities::BugResolved","message":"Thank you!","markdown_message":"\u003cp\u003eThank you!\u003c/p\u003e\n","automated_response":false,"created_at":"2017-05-30T14:49:50.654Z","updated_at":"2017-05-30T14:49:50.654Z","actor":{"username":"arice","cleared":false,"url":"/arice","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/020/83152cb2d070f3f6a63c1b61bae47257722b5ad2_original.jpeg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":true},"reporter":{"username":"dor1s","url":"/dor1s"},"genius_execution_id":null,"team_handle":"internet","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":2003432,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"Finally published the blog post: https://blog.avuln.com/article/4 :)","markdown_message":"\u003cp\u003eFinally published the blog post: \u003ca title=\"https://blog.avuln.com/article/4\" href=\"/redirect?url=https%3A%2F%2Fblog.avuln.com%2Farticle%2F4\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://blog.avuln.com/article/4\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e :)\u003c/p\u003e\n","automated_response":false,"created_at":"2017-09-18T14:10:46.002Z","updated_at":"2017-09-18T14:10:46.002Z","first_to_agree":true,"actor":{"username":"dor1s","cleared":false,"url":"/dor1s","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/017/930/63baa5788d9952bc13497da61518a8902db31756_original.gif/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"internet","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":2006546,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","markdown_message":"","automated_response":false,"created_at":"2017-09-19T17:40:28.050Z","updated_at":"2017-09-19T17:40:28.050Z","actor":{"username":"arice","cleared":false,"url":"/arice","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/020/83152cb2d070f3f6a63c1b61bae47257722b5ad2_original.jpeg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":true},"genius_execution_id":null,"team_handle":"internet","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":2006547,"is_internal":false,"editable":false,"type":"Activities::ReportBecamePublic","message":"","markdown_message":"","automated_response":false,"created_at":"2017-09-19T17:40:28.099Z","updated_at":"2017-09-19T17:40:28.099Z","actor":{"username":"arice","cleared":false,"url":"/arice","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/020/83152cb2d070f3f6a63c1b61bae47257722b5ad2_original.jpeg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":true},"genius_execution_id":null,"team_handle":"internet","actor_is_team_member":false,"actor_is_concealed_member":false}],"activity_page_count":1,"activity_page_number":1,"summaries":[{"category":"team","can_view?":true,"can_create?":false},{"category":"researcher","can_view?":true,"can_create?":false}]}