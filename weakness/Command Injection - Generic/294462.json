{"id":294462,"global_id":"Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8yOTQ0NjI=","url":"https://hackerone.com/reports/294462","title":"NET::Ftp allows command injection in filenames","state":"Closed","substate":"resolved","severity_rating":"low","readable_substate":"Resolved","created_at":"2017-12-02T11:33:02.750Z","submitted_at":"2017-12-02T11:33:02.750Z","is_member_of_team?":false,"reporter":{"disabled":false,"username":"staaldraad","url":"/staaldraad","profile_picture_urls":{"small":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"is_me?":false,"cleared":false,"hackerone_triager":false,"hacker_mediation":false},"team":{"id":7724,"url":"https://hackerone.com/ruby","handle":"ruby","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/007/724/bb067434deef370d6a0b16c2cbbc030b57c75e92_original.png/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a","medium":"https://profile-photos.hackerone-user-content.com/variants/000/007/724/bb067434deef370d6a0b16c2cbbc030b57c75e92_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"permissions":[],"submission_state":"open","default_currency":"usd","awards_miles":false,"offers_bounties":true,"state":"public_mode","only_cleared_hackers":false,"profile":{"name":"Ruby","twitter_handle":"","website":"https://www.ruby-lang.org","about":"A Programmer's Best Friend"}},"has_bounty?":true,"in_validation?":false,"rejected_anc_report_that_can_be_sent_back_to_anc_triagers?":false,"can_view_team":true,"can_view_report":true,"is_external_bug":false,"is_published":false,"is_participant":false,"stage":4,"public":true,"visibility":"full","cve_ids":["CVE-2017-17405"],"singular_disclosure_disabled":false,"disclosed_at":"2017-12-19T06:25:23.383Z","bug_reporter_agreed_on_going_public_at":"2017-12-19T06:25:23.266Z","team_member_agreed_on_going_public_at":"2017-12-19T01:02:52.091Z","comments_closed?":false,"facebook_team?":false,"team_private?":false,"vulnerability_information":"Hi\n\nWhile using NET::Ftp I realised you could get command execution through \"malicious\" file names. \n\nThe problem lies in the `gettextfile(remotefile, localfile = File.basename(remotefile))` method.\nWhen looking at the source code, you'll note:\n```\ndef gettextfile(remotefile, localfile = File.basename(remotefile),\n                \u0026block) # :yield: line\n  f = nil\n  result = nil\n  if localfile\n    f = open(localfile, \"w\") # Vulnerable code here. open(\"| os command\",\"w\")\n  elsif !block_given?\n    result = String.new\n  end\n```\nThe `localfile` value will trigger command execution if the value is `| os command`. In general use, most users would likely provide their own localfile value and would not rely on the default of `File.basename(remotefile)`; however, in some situations, such as listing and downloading all files in a FTP share, the `remotefile` value would be controlled by the remote host and could thus be manipulated into causing RCE. Since the file path is simply a string returned by the server (either `ls -l` style for the `LIST` command, or filenames for `NLIST`), there is no need/guarantee that filename will be a valid filename.\n\nI have attached a sample server that can be used to trigger this vulnerability, as well as a sample client which is vulnerable.\n\n**Usage:**\nChange the `host` and `port` values in both *ftpserver.rb* and *client.rb*\n\nStart the server: `ruby ftpserver.rb`\nRun the client: `ruby client.rb`\n\nObserve that a new file has been created in the CWD of the *client.rb*. The file will be called `pang` and contain the output of the `id` command. As seen in screenshot1.png\n\nThe provided attack example is a little contrived and assumes the user is accepting the file names provided by the server, rather than their own. However, since there is no clear indication in the documentation or an expectation that filenames could lead to RCE, users may be caught unaware. It would probably be best to not use `open` in NET::Ftp, but rather something like `File.open`, maintaining both expected behaviour and security.\n\n## Impact\n\nRemote code execution through command injection. As a user of the NET::Ftp is expecting normal file creation behaviour, they might not be sanitising file paths.","vulnerability_information_html":"\u003cp\u003eHi\u003c/p\u003e\n\n\u003cp\u003eWhile using NET::Ftp I realised you could get command execution through \u0026quot;malicious\u0026quot; file names. \u003c/p\u003e\n\n\u003cp\u003eThe problem lies in the \u003ccode\u003egettextfile(remotefile, localfile = File.basename(remotefile))\u003c/code\u003e method.\u003cbr\u003e\nWhen looking at the source code, you\u0026#39;ll note:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003edef gettextfile(remotefile, localfile = File.basename(remotefile),\n                \u0026amp;block) # :yield: line\n  f = nil\n  result = nil\n  if localfile\n    f = open(localfile, \u0026quot;w\u0026quot;) # Vulnerable code here. open(\u0026quot;| os command\u0026quot;,\u0026quot;w\u0026quot;)\n  elsif !block_given?\n    result = String.new\n  end\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe \u003ccode\u003elocalfile\u003c/code\u003e value will trigger command execution if the value is \u003ccode\u003e| os command\u003c/code\u003e. In general use, most users would likely provide their own localfile value and would not rely on the default of \u003ccode\u003eFile.basename(remotefile)\u003c/code\u003e; however, in some situations, such as listing and downloading all files in a FTP share, the \u003ccode\u003eremotefile\u003c/code\u003e value would be controlled by the remote host and could thus be manipulated into causing RCE. Since the file path is simply a string returned by the server (either \u003ccode\u003els -l\u003c/code\u003e style for the \u003ccode\u003eLIST\u003c/code\u003e command, or filenames for \u003ccode\u003eNLIST\u003c/code\u003e), there is no need/guarantee that filename will be a valid filename.\u003c/p\u003e\n\n\u003cp\u003eI have attached a sample server that can be used to trigger this vulnerability, as well as a sample client which is vulnerable.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eUsage:\u003c/strong\u003e\u003cbr\u003e\nChange the \u003ccode\u003ehost\u003c/code\u003e and \u003ccode\u003eport\u003c/code\u003e values in both \u003cem\u003eftpserver.rb\u003c/em\u003e and \u003cem\u003eclient.rb\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eStart the server: \u003ccode\u003eruby ftpserver.rb\u003c/code\u003e\u003cbr\u003e\nRun the client: \u003ccode\u003eruby client.rb\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eObserve that a new file has been created in the CWD of the \u003cem\u003eclient.rb\u003c/em\u003e. The file will be called \u003ccode\u003epang\u003c/code\u003e and contain the output of the \u003ccode\u003eid\u003c/code\u003e command. As seen in screenshot1.png\u003c/p\u003e\n\n\u003cp\u003eThe provided attack example is a little contrived and assumes the user is accepting the file names provided by the server, rather than their own. However, since there is no clear indication in the documentation or an expectation that filenames could lead to RCE, users may be caught unaware. It would probably be best to not use \u003ccode\u003eopen\u003c/code\u003e in NET::Ftp, but rather something like \u003ccode\u003eFile.open\u003c/code\u003e, maintaining both expected behaviour and security.\u003c/p\u003e\n\n\u003ch2 id=\"impact\"\u003eImpact\u003c/h2\u003e\n\n\u003cp\u003eRemote code execution through command injection. As a user of the NET::Ftp is expecting normal file creation behaviour, they might not be sanitising file paths.\u003c/p\u003e\n","bounty_amount":"1000.0","formatted_bounty":"$1,000","weakness":{"id":58,"name":"Command Injection - Generic"},"original_report_id":null,"original_report_url":null,"attachments":[{"id":243804,"file_name":"screenshot1.png","expiring_url":"https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/000/243/804/08ba0d27cb425a39626462b7467cdefae4d6eba7/screenshot1.png?response-content-disposition=attachment%3B%20filename%3D%22screenshot1.png%22%3B%20filename%2A%3DUTF-8%27%27screenshot1.png\u0026response-content-type=image%2Fpng\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\u0026X-Amz-Credential=ASIAQGK6FURQR2ZO7R4K%2F20201229%2Fus-west-2%2Fs3%2Faws4_request\u0026X-Amz-Date=20201229T052633Z\u0026X-Amz-Expires=3600\u0026X-Amz-SignedHeaders=host\u0026X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJ3%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIGl53Fw9OoAeZDdXqNqIaPWdVjolNnalaCHAwbXpszPSAiEAwdHCK3x2n8ED7sSzsn1sTIqS3bguKd2LFUdH90SxxboqtAMIVhABGgwwMTM2MTkyNzQ4NDkiDFnQ3ZZHIU4UMAvXOCqRA3wF0%2FhaPHMfYMs5a29VvIgRVY2eUJjhO2ZyE9nrbvBw99qQYURMnfpjG6qzK9RhUhaxnystL8FSjs1I9wVhv7kK6fGlwNHgR0S%2FwzzOYB4EaUAuHPPjDIaplYQHDQfhD3Jzk627x6y1whtGyRm1%2FbLU%2FMLC%2FEl2Y0VF3B2XYbmjMyMbEo%2F3JA2NhxILkWnIEx9Dc5OuLgUgvtMmXd8zqzlhwWk%2Fkbzt%2FA4PPw5G1805sqkgAV2ZtRMBvyI%2FHqrdrdjVcpE0L%2Fb3v3BTHE1AxOXymRI68r5QkUXAwvQReRh0UHKevdP2OKVlaJqNW4QPWf8V9sf08LOD6%2FIWFP2z6T0Ge7kmECxaLuqLfuqbJATPZaoduqk5WANfTo41R4vwOd0PfkzuCu4ENGZautDQdqCTqc5v4f3nC%2FmEA3lzVbD2GfnKNN5i6QTsolJiL8iHwoY3qRGnqUpWe6styqCssbnT2On6kImCyLv8PqTQIgD5tzKTZ%2Bk7rSp%2FUGyNQ%2Fzf7CwFfbirN8%2BZ0cy8FDVRQPOIMNrtqv8FOusBG5VJhuS959dYt8SgxT1B5qInUKkmqkB9xSwqpRIrJhHLlMpiW9hAt%2BdMLFZZhmn8J5%2BdfXBiq%2FwOuwlyUwREyyNiqFLd5q%2F2oDa1jv2FMMsir1my4yAqcT0R%2BuM9KWMCRIN%2F27CpS4%2BgKGfRpQrYqZnwFoh5vyTAfyKuQbQpvNQ5z0%2F7hQPQ1Fud3gWbMbKSBMyuMEkDvn42ZK0k1WvIYPRa53VXsGPwtTo7PZ2laExqLJsXRcULDGCx08GryRt%2B5IBSaDHktFU1HTGALrwf1yRufEBKHtOimqOWitGuYxfwQnKZ1ht%2BjmX2WQ%3D%3D\u0026X-Amz-Signature=d001921ebd5f6c75038ee3b416c42002b9d6d13b44711a90d0337f6804bcd628","file_size":299568,"type":"image/png"},{"id":243806,"file_name":"client.rb","expiring_url":"https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/000/243/806/9281dfc72b12cf50de83c3b59e6f88bf46ee2d1b/client.rb?response-content-disposition=attachment%3B%20filename%3D%22client.rb%22%3B%20filename%2A%3DUTF-8%27%27client.rb\u0026response-content-type=text%2Fplain\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\u0026X-Amz-Credential=ASIAQGK6FURQR2ZO7R4K%2F20201229%2Fus-west-2%2Fs3%2Faws4_request\u0026X-Amz-Date=20201229T052633Z\u0026X-Amz-Expires=3600\u0026X-Amz-SignedHeaders=host\u0026X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJ3%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIGl53Fw9OoAeZDdXqNqIaPWdVjolNnalaCHAwbXpszPSAiEAwdHCK3x2n8ED7sSzsn1sTIqS3bguKd2LFUdH90SxxboqtAMIVhABGgwwMTM2MTkyNzQ4NDkiDFnQ3ZZHIU4UMAvXOCqRA3wF0%2FhaPHMfYMs5a29VvIgRVY2eUJjhO2ZyE9nrbvBw99qQYURMnfpjG6qzK9RhUhaxnystL8FSjs1I9wVhv7kK6fGlwNHgR0S%2FwzzOYB4EaUAuHPPjDIaplYQHDQfhD3Jzk627x6y1whtGyRm1%2FbLU%2FMLC%2FEl2Y0VF3B2XYbmjMyMbEo%2F3JA2NhxILkWnIEx9Dc5OuLgUgvtMmXd8zqzlhwWk%2Fkbzt%2FA4PPw5G1805sqkgAV2ZtRMBvyI%2FHqrdrdjVcpE0L%2Fb3v3BTHE1AxOXymRI68r5QkUXAwvQReRh0UHKevdP2OKVlaJqNW4QPWf8V9sf08LOD6%2FIWFP2z6T0Ge7kmECxaLuqLfuqbJATPZaoduqk5WANfTo41R4vwOd0PfkzuCu4ENGZautDQdqCTqc5v4f3nC%2FmEA3lzVbD2GfnKNN5i6QTsolJiL8iHwoY3qRGnqUpWe6styqCssbnT2On6kImCyLv8PqTQIgD5tzKTZ%2Bk7rSp%2FUGyNQ%2Fzf7CwFfbirN8%2BZ0cy8FDVRQPOIMNrtqv8FOusBG5VJhuS959dYt8SgxT1B5qInUKkmqkB9xSwqpRIrJhHLlMpiW9hAt%2BdMLFZZhmn8J5%2BdfXBiq%2FwOuwlyUwREyyNiqFLd5q%2F2oDa1jv2FMMsir1my4yAqcT0R%2BuM9KWMCRIN%2F27CpS4%2BgKGfRpQrYqZnwFoh5vyTAfyKuQbQpvNQ5z0%2F7hQPQ1Fud3gWbMbKSBMyuMEkDvn42ZK0k1WvIYPRa53VXsGPwtTo7PZ2laExqLJsXRcULDGCx08GryRt%2B5IBSaDHktFU1HTGALrwf1yRufEBKHtOimqOWitGuYxfwQnKZ1ht%2BjmX2WQ%3D%3D\u0026X-Amz-Signature=368130a7e6b197ffd6a875d364b9d4217bc6eaa4c49d73d06c64021c9065fd69","file_size":221,"type":"text/plain"},{"id":243807,"file_name":"ftpserv.rb","expiring_url":"https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/000/243/807/6a3e1b11c646d59f0d26aed28c3fff6765dc9a59/ftpserv.rb?response-content-disposition=attachment%3B%20filename%3D%22ftpserv.rb%22%3B%20filename%2A%3DUTF-8%27%27ftpserv.rb\u0026response-content-type=text%2Fx-ruby\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\u0026X-Amz-Credential=ASIAQGK6FURQR2ZO7R4K%2F20201229%2Fus-west-2%2Fs3%2Faws4_request\u0026X-Amz-Date=20201229T052633Z\u0026X-Amz-Expires=3600\u0026X-Amz-SignedHeaders=host\u0026X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJ3%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIGl53Fw9OoAeZDdXqNqIaPWdVjolNnalaCHAwbXpszPSAiEAwdHCK3x2n8ED7sSzsn1sTIqS3bguKd2LFUdH90SxxboqtAMIVhABGgwwMTM2MTkyNzQ4NDkiDFnQ3ZZHIU4UMAvXOCqRA3wF0%2FhaPHMfYMs5a29VvIgRVY2eUJjhO2ZyE9nrbvBw99qQYURMnfpjG6qzK9RhUhaxnystL8FSjs1I9wVhv7kK6fGlwNHgR0S%2FwzzOYB4EaUAuHPPjDIaplYQHDQfhD3Jzk627x6y1whtGyRm1%2FbLU%2FMLC%2FEl2Y0VF3B2XYbmjMyMbEo%2F3JA2NhxILkWnIEx9Dc5OuLgUgvtMmXd8zqzlhwWk%2Fkbzt%2FA4PPw5G1805sqkgAV2ZtRMBvyI%2FHqrdrdjVcpE0L%2Fb3v3BTHE1AxOXymRI68r5QkUXAwvQReRh0UHKevdP2OKVlaJqNW4QPWf8V9sf08LOD6%2FIWFP2z6T0Ge7kmECxaLuqLfuqbJATPZaoduqk5WANfTo41R4vwOd0PfkzuCu4ENGZautDQdqCTqc5v4f3nC%2FmEA3lzVbD2GfnKNN5i6QTsolJiL8iHwoY3qRGnqUpWe6styqCssbnT2On6kImCyLv8PqTQIgD5tzKTZ%2Bk7rSp%2FUGyNQ%2Fzf7CwFfbirN8%2BZ0cy8FDVRQPOIMNrtqv8FOusBG5VJhuS959dYt8SgxT1B5qInUKkmqkB9xSwqpRIrJhHLlMpiW9hAt%2BdMLFZZhmn8J5%2BdfXBiq%2FwOuwlyUwREyyNiqFLd5q%2F2oDa1jv2FMMsir1my4yAqcT0R%2BuM9KWMCRIN%2F27CpS4%2BgKGfRpQrYqZnwFoh5vyTAfyKuQbQpvNQ5z0%2F7hQPQ1Fud3gWbMbKSBMyuMEkDvn42ZK0k1WvIYPRa53VXsGPwtTo7PZ2laExqLJsXRcULDGCx08GryRt%2B5IBSaDHktFU1HTGALrwf1yRufEBKHtOimqOWitGuYxfwQnKZ1ht%2BjmX2WQ%3D%3D\u0026X-Amz-Signature=ef29e60cdaac2b6c4e3a9a13aee4b7b50650943265fd53326764bed572c4e6c3","file_size":1084,"type":"text/x-ruby"}],"allow_singular_disclosure_at":"2018-01-18T01:02:52.210Z","allow_singular_disclosure_after":-92982221.2861815,"singular_disclosure_allowed":true,"vote_count":26,"voters":["jokebookservice1","gpike","kapytein","secator","foobar7","hunter","0ways","xyodh","eveeez","an0nym0us","and 16 more..."],"severity":{"rating":"low","author_type":"User"},"structured_scope":null,"abilities":{"assignable_team_members":[],"assignable_team_member_groups":[]},"can_edit_custom_fields_attributes":false,"activities":[{"id":2195752,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Hello, thank you for the report. The team members are investigating the situation.","markdown_message":"\u003cp\u003eHello, thank you for the report. The team members are investigating the situation.\u003c/p\u003e\n","automated_response":false,"created_at":"2017-12-02T12:58:30.202Z","updated_at":"2017-12-02T12:58:30.202Z","actor":{"username":"shyouhei","cleared":false,"url":"/shyouhei","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":2195848,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Thanks for your report.\n\nWe consider this issue a vulnerability and will fix it using File.open as you suggested.\nFurthermore we will check whether other libraries have the same vulnerability.","markdown_message":"\u003cp\u003eThanks for your report.\u003c/p\u003e\n\n\u003cp\u003eWe consider this issue a vulnerability and will fix it using File.open as you suggested.\u003cbr\u003e\nFurthermore we will check whether other libraries have the same vulnerability.\u003c/p\u003e\n","automated_response":false,"created_at":"2017-12-02T14:13:33.840Z","updated_at":"2017-12-02T14:13:33.840Z","actor":{"username":"shugo","cleared":false,"url":"/shugo","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/076/177/c63f990ae1ef62a77c2ff1e5b2db5e4dd3db2557_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":2195857,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Wow, that was super quick! \n\nI started looking into it, after posting this report, just a basic grep of lib/ and there were a few libraries that popped up. I haven't had time to dig into it yet, but at first glance `CSV::open` seems like it might be the most likely one where users would be passing in filenames that may be externally controlled.\nThere are a few other libs such as WEBrick that have open(filename) but that all occurs in initialization code, so it would be \"self command injection\" :)\n\nI'll keep looking into it! ","markdown_message":"\u003cp\u003eWow, that was super quick! \u003c/p\u003e\n\n\u003cp\u003eI started looking into it, after posting this report, just a basic grep of lib/ and there were a few libraries that popped up. I haven\u0026#39;t had time to dig into it yet, but at first glance \u003ccode\u003eCSV::open\u003c/code\u003e seems like it might be the most likely one where users would be passing in filenames that may be externally controlled.\u003cbr\u003e\nThere are a few other libs such as WEBrick that have open(filename) but that all occurs in initialization code, so it would be \u0026quot;self command injection\u0026quot; :)\u003c/p\u003e\n\n\u003cp\u003eI\u0026#39;ll keep looking into it! \u003c/p\u003e\n","automated_response":false,"created_at":"2017-12-02T14:23:08.013Z","updated_at":"2017-12-02T14:23:08.013Z","actor":{"username":"staaldraad","cleared":false,"url":"/staaldraad","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":2195973,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Thanks for your suggestion.\n\nFile.read, File.binread, File.write, and File.binwrite (technically they are IO's methods) also have the same risk,\nso we'll check their invocations too.\n\nAs to Net::FTP, we're going to apply the following patch:\n\n```\ndiff --git a/lib/net/ftp.rb b/lib/net/ftp.rb\nindex cfd72ee4e0..a75470c705 100644\n--- a/lib/net/ftp.rb\n+++ b/lib/net/ftp.rb\n@@ -748,10 +748,10 @@ def getbinaryfile(remotefile, localfile = File.basename(remotefile),\n       if localfile\n         if @resume\n           rest_offset = File.size?(localfile)\n-          f = open(localfile, \"a\")\n+          f = File.open(localfile, \"a\")\n         else\n           rest_offset = nil\n-          f = open(localfile, \"w\")\n+          f = File.open(localfile, \"w\")\n         end\n       elsif !block_given?\n         result = String.new\n@@ -781,7 +781,7 @@ def gettextfile(remotefile, localfile = File.basename(remotefile),\n       f = nil\n       result = nil\n       if localfile\n-        f = open(localfile, \"w\")\n+        f = File.open(localfile, \"w\")\n       elsif !block_given?\n         result = String.new\n       end\n@@ -827,7 +827,7 @@ def putbinaryfile(localfile, remotefile = File.basename(localfile),\n       else\n         rest_offset = nil\n       end\n-      f = open(localfile)\n+      f = File.open(localfile)\n       begin\n         f.binmode\n         if rest_offset\n@@ -846,7 +846,7 @@ def putbinaryfile(localfile, remotefile = File.basename(localfile),\n     # passing in the transmitted data one line at a time.\n     #\n     def puttextfile(localfile, remotefile = File.basename(localfile), \u0026block) # :yield: line\n-      f = open(localfile)\n+      f = File.open(localfile)\n       begin\n         storlines(\"STOR #{remotefile}\", f, \u0026block)\n       ensure\ndiff --git a/test/net/ftp/test_ftp.rb b/test/net/ftp/test_ftp.rb\nindex 6f726e1090..c220f40cd1 100644\n--- a/test/net/ftp/test_ftp.rb\n+++ b/test/net/ftp/test_ftp.rb\n@@ -5,6 +5,7 @@\n require \"ostruct\"\n require \"stringio\"\n require \"tempfile\"\n+require \"tmpdir\"\n \n class FTPTest \u003c Test::Unit::TestCase\n   SERVER_NAME = \"localhost\"\n@@ -2136,6 +2137,227 @@ def test_abort_tls\n     end\n   end\n \n+  def test_getbinaryfile_command_injection\n+    skip \"| is not allowed in filename on Windows\" if windows?\n+    [false, true].each do |resume|\n+      commands = []\n+      binary_data = (0..0xff).map {|i| i.chr}.join * 4 * 3\n+      server = create_ftp_server { |sock|\n+        sock.print(\"220 (test_ftp).\\r\\n\")\n+        commands.push(sock.gets)\n+        sock.print(\"331 Please specify the password.\\r\\n\")\n+        commands.push(sock.gets)\n+        sock.print(\"230 Login successful.\\r\\n\")\n+        commands.push(sock.gets)\n+        sock.print(\"200 Switching to Binary mode.\\r\\n\")\n+        line = sock.gets\n+        commands.push(line)\n+        host, port = process_port_or_eprt(sock, line)\n+        commands.push(sock.gets)\n+        sock.print(\"150 Opening BINARY mode data connection for |echo hello (#{binary_data.size} bytes)\\r\\n\")\n+        conn = TCPSocket.new(host, port)\n+        binary_data.scan(/.{1,1024}/nm) do |s|\n+          conn.print(s)\n+        end\n+        conn.shutdown(Socket::SHUT_WR)\n+        conn.read\n+        conn.close\n+        sock.print(\"226 Transfer complete.\\r\\n\")\n+      }\n+      begin\n+        chdir_to_tmpdir do\n+          begin\n+            ftp = Net::FTP.new\n+            ftp.resume = resume\n+            ftp.read_timeout = 0.2\n+            ftp.connect(SERVER_ADDR, server.port)\n+            ftp.login\n+            assert_match(/\\AUSER /, commands.shift)\n+            assert_match(/\\APASS /, commands.shift)\n+            assert_equal(\"TYPE I\\r\\n\", commands.shift)\n+            ftp.getbinaryfile(\"|echo hello\")\n+            assert_equal(binary_data, File.binread(\"./|echo hello\"))\n+            assert_match(/\\A(PORT|EPRT) /, commands.shift)\n+            assert_equal(\"RETR |echo hello\\r\\n\", commands.shift)\n+            assert_equal(nil, commands.shift)\n+          ensure\n+            ftp.close if ftp\n+          end\n+        end\n+      ensure\n+        server.close\n+      end\n+    end\n+  end\n+\n+  def test_gettextfile_command_injection\n+    skip \"| is not allowed in filename on Windows\" if windows?\n+    commands = []\n+    text_data = \u003c\u003cEOF.gsub(/\\n/, \"\\r\\n\")\n+foo\n+bar\n+baz\n+EOF\n+    server = create_ftp_server { |sock|\n+      sock.print(\"220 (test_ftp).\\r\\n\")\n+      commands.push(sock.gets)\n+      sock.print(\"331 Please specify the password.\\r\\n\")\n+      commands.push(sock.gets)\n+      sock.print(\"230 Login successful.\\r\\n\")\n+      commands.push(sock.gets)\n+      sock.print(\"200 Switching to Binary mode.\\r\\n\")\n+      commands.push(sock.gets)\n+      sock.print(\"200 Switching to ASCII mode.\\r\\n\")\n+      line = sock.gets\n+      commands.push(line)\n+      host, port = process_port_or_eprt(sock, line)\n+      commands.push(sock.gets)\n+      sock.print(\"150 Opening TEXT mode data connection for |echo hello (#{text_data.size} bytes)\\r\\n\")\n+      conn = TCPSocket.new(host, port)\n+      text_data.each_line do |l|\n+        conn.print(l)\n+      end\n+      conn.shutdown(Socket::SHUT_WR)\n+      conn.read\n+      conn.close\n+      sock.print(\"226 Transfer complete.\\r\\n\")\n+      commands.push(sock.gets)\n+      sock.print(\"200 Switching to Binary mode.\\r\\n\")\n+    }\n+    begin\n+      chdir_to_tmpdir do\n+        begin\n+          ftp = Net::FTP.new\n+          ftp.connect(SERVER_ADDR, server.port)\n+          ftp.login\n+          assert_match(/\\AUSER /, commands.shift)\n+          assert_match(/\\APASS /, commands.shift)\n+          assert_equal(\"TYPE I\\r\\n\", commands.shift)\n+          ftp.gettextfile(\"|echo hello\")\n+          assert_equal(text_data.gsub(/\\r\\n/, \"\\n\"),\n+                       File.binread(\"./|echo hello\"))\n+          assert_equal(\"TYPE A\\r\\n\", commands.shift)\n+          assert_match(/\\A(PORT|EPRT) /, commands.shift)\n+          assert_equal(\"RETR |echo hello\\r\\n\", commands.shift)\n+          assert_equal(\"TYPE I\\r\\n\", commands.shift)\n+          assert_equal(nil, commands.shift)\n+        ensure\n+          ftp.close if ftp\n+        end\n+      end\n+    ensure\n+      server.close\n+    end\n+  end\n+\n+  def test_putbinaryfile_command_injection\n+    skip \"| is not allowed in filename on Windows\" if windows?\n+    commands = []\n+    binary_data = (0..0xff).map {|i| i.chr}.join * 4 * 3\n+    received_data = nil\n+    server = create_ftp_server { |sock|\n+      sock.print(\"220 (test_ftp).\\r\\n\")\n+      commands.push(sock.gets)\n+      sock.print(\"331 Please specify the password.\\r\\n\")\n+      commands.push(sock.gets)\n+      sock.print(\"230 Login successful.\\r\\n\")\n+      commands.push(sock.gets)\n+      sock.print(\"200 Switching to Binary mode.\\r\\n\")\n+      line = sock.gets\n+      commands.push(line)\n+      host, port = process_port_or_eprt(sock, line)\n+      commands.push(sock.gets)\n+      sock.print(\"150 Opening BINARY mode data connection for |echo hello (#{binary_data.size} bytes)\\r\\n\")\n+      conn = TCPSocket.new(host, port)\n+      received_data = conn.read\n+      conn.close\n+      sock.print(\"226 Transfer complete.\\r\\n\")\n+    }\n+    begin\n+      chdir_to_tmpdir do\n+        File.binwrite(\"./|echo hello\", binary_data)\n+        begin\n+          ftp = Net::FTP.new\n+          ftp.read_timeout = 0.2\n+          ftp.connect(SERVER_ADDR, server.port)\n+          ftp.login\n+          assert_match(/\\AUSER /, commands.shift)\n+          assert_match(/\\APASS /, commands.shift)\n+          assert_equal(\"TYPE I\\r\\n\", commands.shift)\n+          ftp.putbinaryfile(\"|echo hello\")\n+          assert_equal(binary_data, received_data)\n+          assert_match(/\\A(PORT|EPRT) /, commands.shift)\n+          assert_equal(\"STOR |echo hello\\r\\n\", commands.shift)\n+          assert_equal(nil, commands.shift)\n+        ensure\n+          ftp.close if ftp\n+        end\n+      end\n+    ensure\n+      server.close\n+    end\n+  end\n+\n+  def test_puttextfile_command_injection\n+    skip \"| is not allowed in filename on Windows\" if windows?\n+    commands = []\n+    received_data = nil\n+    server = create_ftp_server { |sock|\n+      sock.print(\"220 (test_ftp).\\r\\n\")\n+      commands.push(sock.gets)\n+      sock.print(\"331 Please specify the password.\\r\\n\")\n+      commands.push(sock.gets)\n+      sock.print(\"230 Login successful.\\r\\n\")\n+      commands.push(sock.gets)\n+      sock.print(\"200 Switching to Binary mode.\\r\\n\")\n+      commands.push(sock.gets)\n+      sock.print(\"200 Switching to ASCII mode.\\r\\n\")\n+      line = sock.gets\n+      commands.push(line)\n+      host, port = process_port_or_eprt(sock, line)\n+      commands.push(sock.gets)\n+      sock.print(\"150 Opening TEXT mode data connection for |echo hello\\r\\n\")\n+      conn = TCPSocket.new(host, port)\n+      received_data = conn.read\n+      conn.close\n+      sock.print(\"226 Transfer complete.\\r\\n\")\n+      commands.push(sock.gets)\n+      sock.print(\"200 Switching to Binary mode.\\r\\n\")\n+    }\n+    begin\n+      chdir_to_tmpdir do\n+        File.open(\"|echo hello\", \"w\") do |f|\n+          f.puts(\"foo\")\n+          f.puts(\"bar\")\n+          f.puts(\"baz\")\n+        end\n+        begin\n+          ftp = Net::FTP.new\n+          ftp.connect(SERVER_ADDR, server.port)\n+          ftp.login\n+          assert_match(/\\AUSER /, commands.shift)\n+          assert_match(/\\APASS /, commands.shift)\n+          assert_equal(\"TYPE I\\r\\n\", commands.shift)\n+          ftp.puttextfile(\"|echo hello\")\n+          assert_equal(\u003c\u003cEOF.gsub(/\\n/, \"\\r\\n\"), received_data)\n+foo\n+bar\n+baz\n+EOF\n+          assert_equal(\"TYPE A\\r\\n\", commands.shift)\n+          assert_match(/\\A(PORT|EPRT) /, commands.shift)\n+          assert_equal(\"STOR |echo hello\\r\\n\", commands.shift)\n+          assert_equal(\"TYPE I\\r\\n\", commands.shift)\n+          assert_equal(nil, commands.shift)\n+        ensure\n+          ftp.close if ftp\n+        end\n+      end\n+    ensure\n+      server.close\n+    end\n+  end\n+\n   private\n \n   def create_ftp_server(sleep_time = nil)\n@@ -2232,4 +2454,16 @@ def create_data_connection_server(sock)\n     end\n     return data_server\n   end\n+\n+  def chdir_to_tmpdir\n+    Dir.mktmpdir do |dir|\n+      pwd = Dir.pwd\n+      Dir.chdir(dir)\n+      begin\n+        yield\n+      ensure\n+        Dir.chdir(pwd)\n+      end\n+    end\n+  end\n end\n```\n","markdown_message":"\u003cp\u003eThanks for your suggestion.\u003c/p\u003e\n\n\u003cp\u003eFile.read, File.binread, File.write, and File.binwrite (technically they are IO\u0026#39;s methods) also have the same risk,\u003cbr\u003e\nso we\u0026#39;ll check their invocations too.\u003c/p\u003e\n\n\u003cp\u003eAs to Net::FTP, we\u0026#39;re going to apply the following patch:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight diff\"\u003e\u003ccode\u003e\u003cspan class=\"gh\"\u003ediff --git a/lib/net/ftp.rb b/lib/net/ftp.rb\nindex cfd72ee4e0..a75470c705 100644\n\u003c/span\u003e\u003cspan class=\"gd\"\u003e--- a/lib/net/ftp.rb\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+++ b/lib/net/ftp.rb\n\u003c/span\u003e\u003cspan class=\"p\"\u003e@@ -748,10 +748,10 @@\u003c/span\u003e def getbinaryfile(remotefile, localfile = File.basename(remotefile),\n       if localfile\n         if @resume\n           rest_offset = File.size?(localfile)\n\u003cspan class=\"gd\"\u003e-          f = open(localfile, \u0026quot;a\u0026quot;)\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+          f = File.open(localfile, \u0026quot;a\u0026quot;)\n\u003c/span\u003e         else\n           rest_offset = nil\n\u003cspan class=\"gd\"\u003e-          f = open(localfile, \u0026quot;w\u0026quot;)\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+          f = File.open(localfile, \u0026quot;w\u0026quot;)\n\u003c/span\u003e         end\n       elsif !block_given?\n         result = String.new\n\u003cspan class=\"p\"\u003e@@ -781,7 +781,7 @@\u003c/span\u003e def gettextfile(remotefile, localfile = File.basename(remotefile),\n       f = nil\n       result = nil\n       if localfile\n\u003cspan class=\"gd\"\u003e-        f = open(localfile, \u0026quot;w\u0026quot;)\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+        f = File.open(localfile, \u0026quot;w\u0026quot;)\n\u003c/span\u003e       elsif !block_given?\n         result = String.new\n       end\n\u003cspan class=\"p\"\u003e@@ -827,7 +827,7 @@\u003c/span\u003e def putbinaryfile(localfile, remotefile = File.basename(localfile),\n       else\n         rest_offset = nil\n       end\n\u003cspan class=\"gd\"\u003e-      f = open(localfile)\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+      f = File.open(localfile)\n\u003c/span\u003e       begin\n         f.binmode\n         if rest_offset\n\u003cspan class=\"p\"\u003e@@ -846,7 +846,7 @@\u003c/span\u003e def putbinaryfile(localfile, remotefile = File.basename(localfile),\n     # passing in the transmitted data one line at a time.\n     #\n     def puttextfile(localfile, remotefile = File.basename(localfile), \u0026amp;block) # :yield: line\n\u003cspan class=\"gd\"\u003e-      f = open(localfile)\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+      f = File.open(localfile)\n\u003c/span\u003e       begin\n         storlines(\u0026quot;STOR #{remotefile}\u0026quot;, f, \u0026amp;block)\n       ensure\n\u003cspan class=\"gh\"\u003ediff --git a/test/net/ftp/test_ftp.rb b/test/net/ftp/test_ftp.rb\nindex 6f726e1090..c220f40cd1 100644\n\u003c/span\u003e\u003cspan class=\"gd\"\u003e--- a/test/net/ftp/test_ftp.rb\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+++ b/test/net/ftp/test_ftp.rb\n\u003c/span\u003e\u003cspan class=\"p\"\u003e@@ -5,6 +5,7 @@\u003c/span\u003e\n require \u0026quot;ostruct\u0026quot;\n require \u0026quot;stringio\u0026quot;\n require \u0026quot;tempfile\u0026quot;\n\u003cspan class=\"gi\"\u003e+require \u0026quot;tmpdir\u0026quot;\n\u003c/span\u003e\n class FTPTest \u0026lt; Test::Unit::TestCase\n   SERVER_NAME = \u0026quot;localhost\u0026quot;\n\u003cspan class=\"p\"\u003e@@ -2136,6 +2137,227 @@\u003c/span\u003e def test_abort_tls\n     end\n   end\n\n+  def test_getbinaryfile_command_injection\n\u003cspan class=\"gi\"\u003e+    skip \u0026quot;| is not allowed in filename on Windows\u0026quot; if windows?\n+    [false, true].each do |resume|\n+      commands = []\n+      binary_data = (0..0xff).map {|i| i.chr}.join * 4 * 3\n+      server = create_ftp_server { |sock|\n+        sock.print(\u0026quot;220 (test_ftp).\\r\\n\u0026quot;)\n+        commands.push(sock.gets)\n+        sock.print(\u0026quot;331 Please specify the password.\\r\\n\u0026quot;)\n+        commands.push(sock.gets)\n+        sock.print(\u0026quot;230 Login successful.\\r\\n\u0026quot;)\n+        commands.push(sock.gets)\n+        sock.print(\u0026quot;200 Switching to Binary mode.\\r\\n\u0026quot;)\n+        line = sock.gets\n+        commands.push(line)\n+        host, port = process_port_or_eprt(sock, line)\n+        commands.push(sock.gets)\n+        sock.print(\u0026quot;150 Opening BINARY mode data connection for |echo hello (#{binary_data.size} bytes)\\r\\n\u0026quot;)\n+        conn = TCPSocket.new(host, port)\n+        binary_data.scan(/.{1,1024}/nm) do |s|\n+          conn.print(s)\n+        end\n+        conn.shutdown(Socket::SHUT_WR)\n+        conn.read\n+        conn.close\n+        sock.print(\u0026quot;226 Transfer complete.\\r\\n\u0026quot;)\n+      }\n+      begin\n+        chdir_to_tmpdir do\n+          begin\n+            ftp = Net::FTP.new\n+            ftp.resume = resume\n+            ftp.read_timeout = 0.2\n+            ftp.connect(SERVER_ADDR, server.port)\n+            ftp.login\n+            assert_match(/\\AUSER /, commands.shift)\n+            assert_match(/\\APASS /, commands.shift)\n+            assert_equal(\u0026quot;TYPE I\\r\\n\u0026quot;, commands.shift)\n+            ftp.getbinaryfile(\u0026quot;|echo hello\u0026quot;)\n+            assert_equal(binary_data, File.binread(\u0026quot;./|echo hello\u0026quot;))\n+            assert_match(/\\A(PORT|EPRT) /, commands.shift)\n+            assert_equal(\u0026quot;RETR |echo hello\\r\\n\u0026quot;, commands.shift)\n+            assert_equal(nil, commands.shift)\n+          ensure\n+            ftp.close if ftp\n+          end\n+        end\n+      ensure\n+        server.close\n+      end\n+    end\n+  end\n+\n+  def test_gettextfile_command_injection\n+    skip \u0026quot;| is not allowed in filename on Windows\u0026quot; if windows?\n+    commands = []\n+    text_data = \u0026lt;\u0026lt;EOF.gsub(/\\n/, \u0026quot;\\r\\n\u0026quot;)\n+foo\n+bar\n+baz\n+EOF\n+    server = create_ftp_server { |sock|\n+      sock.print(\u0026quot;220 (test_ftp).\\r\\n\u0026quot;)\n+      commands.push(sock.gets)\n+      sock.print(\u0026quot;331 Please specify the password.\\r\\n\u0026quot;)\n+      commands.push(sock.gets)\n+      sock.print(\u0026quot;230 Login successful.\\r\\n\u0026quot;)\n+      commands.push(sock.gets)\n+      sock.print(\u0026quot;200 Switching to Binary mode.\\r\\n\u0026quot;)\n+      commands.push(sock.gets)\n+      sock.print(\u0026quot;200 Switching to ASCII mode.\\r\\n\u0026quot;)\n+      line = sock.gets\n+      commands.push(line)\n+      host, port = process_port_or_eprt(sock, line)\n+      commands.push(sock.gets)\n+      sock.print(\u0026quot;150 Opening TEXT mode data connection for |echo hello (#{text_data.size} bytes)\\r\\n\u0026quot;)\n+      conn = TCPSocket.new(host, port)\n+      text_data.each_line do |l|\n+        conn.print(l)\n+      end\n+      conn.shutdown(Socket::SHUT_WR)\n+      conn.read\n+      conn.close\n+      sock.print(\u0026quot;226 Transfer complete.\\r\\n\u0026quot;)\n+      commands.push(sock.gets)\n+      sock.print(\u0026quot;200 Switching to Binary mode.\\r\\n\u0026quot;)\n+    }\n+    begin\n+      chdir_to_tmpdir do\n+        begin\n+          ftp = Net::FTP.new\n+          ftp.connect(SERVER_ADDR, server.port)\n+          ftp.login\n+          assert_match(/\\AUSER /, commands.shift)\n+          assert_match(/\\APASS /, commands.shift)\n+          assert_equal(\u0026quot;TYPE I\\r\\n\u0026quot;, commands.shift)\n+          ftp.gettextfile(\u0026quot;|echo hello\u0026quot;)\n+          assert_equal(text_data.gsub(/\\r\\n/, \u0026quot;\\n\u0026quot;),\n+                       File.binread(\u0026quot;./|echo hello\u0026quot;))\n+          assert_equal(\u0026quot;TYPE A\\r\\n\u0026quot;, commands.shift)\n+          assert_match(/\\A(PORT|EPRT) /, commands.shift)\n+          assert_equal(\u0026quot;RETR |echo hello\\r\\n\u0026quot;, commands.shift)\n+          assert_equal(\u0026quot;TYPE I\\r\\n\u0026quot;, commands.shift)\n+          assert_equal(nil, commands.shift)\n+        ensure\n+          ftp.close if ftp\n+        end\n+      end\n+    ensure\n+      server.close\n+    end\n+  end\n+\n+  def test_putbinaryfile_command_injection\n+    skip \u0026quot;| is not allowed in filename on Windows\u0026quot; if windows?\n+    commands = []\n+    binary_data = (0..0xff).map {|i| i.chr}.join * 4 * 3\n+    received_data = nil\n+    server = create_ftp_server { |sock|\n+      sock.print(\u0026quot;220 (test_ftp).\\r\\n\u0026quot;)\n+      commands.push(sock.gets)\n+      sock.print(\u0026quot;331 Please specify the password.\\r\\n\u0026quot;)\n+      commands.push(sock.gets)\n+      sock.print(\u0026quot;230 Login successful.\\r\\n\u0026quot;)\n+      commands.push(sock.gets)\n+      sock.print(\u0026quot;200 Switching to Binary mode.\\r\\n\u0026quot;)\n+      line = sock.gets\n+      commands.push(line)\n+      host, port = process_port_or_eprt(sock, line)\n+      commands.push(sock.gets)\n+      sock.print(\u0026quot;150 Opening BINARY mode data connection for |echo hello (#{binary_data.size} bytes)\\r\\n\u0026quot;)\n+      conn = TCPSocket.new(host, port)\n+      received_data = conn.read\n+      conn.close\n+      sock.print(\u0026quot;226 Transfer complete.\\r\\n\u0026quot;)\n+    }\n+    begin\n+      chdir_to_tmpdir do\n+        File.binwrite(\u0026quot;./|echo hello\u0026quot;, binary_data)\n+        begin\n+          ftp = Net::FTP.new\n+          ftp.read_timeout = 0.2\n+          ftp.connect(SERVER_ADDR, server.port)\n+          ftp.login\n+          assert_match(/\\AUSER /, commands.shift)\n+          assert_match(/\\APASS /, commands.shift)\n+          assert_equal(\u0026quot;TYPE I\\r\\n\u0026quot;, commands.shift)\n+          ftp.putbinaryfile(\u0026quot;|echo hello\u0026quot;)\n+          assert_equal(binary_data, received_data)\n+          assert_match(/\\A(PORT|EPRT) /, commands.shift)\n+          assert_equal(\u0026quot;STOR |echo hello\\r\\n\u0026quot;, commands.shift)\n+          assert_equal(nil, commands.shift)\n+        ensure\n+          ftp.close if ftp\n+        end\n+      end\n+    ensure\n+      server.close\n+    end\n+  end\n+\n+  def test_puttextfile_command_injection\n+    skip \u0026quot;| is not allowed in filename on Windows\u0026quot; if windows?\n+    commands = []\n+    received_data = nil\n+    server = create_ftp_server { |sock|\n+      sock.print(\u0026quot;220 (test_ftp).\\r\\n\u0026quot;)\n+      commands.push(sock.gets)\n+      sock.print(\u0026quot;331 Please specify the password.\\r\\n\u0026quot;)\n+      commands.push(sock.gets)\n+      sock.print(\u0026quot;230 Login successful.\\r\\n\u0026quot;)\n+      commands.push(sock.gets)\n+      sock.print(\u0026quot;200 Switching to Binary mode.\\r\\n\u0026quot;)\n+      commands.push(sock.gets)\n+      sock.print(\u0026quot;200 Switching to ASCII mode.\\r\\n\u0026quot;)\n+      line = sock.gets\n+      commands.push(line)\n+      host, port = process_port_or_eprt(sock, line)\n+      commands.push(sock.gets)\n+      sock.print(\u0026quot;150 Opening TEXT mode data connection for |echo hello\\r\\n\u0026quot;)\n+      conn = TCPSocket.new(host, port)\n+      received_data = conn.read\n+      conn.close\n+      sock.print(\u0026quot;226 Transfer complete.\\r\\n\u0026quot;)\n+      commands.push(sock.gets)\n+      sock.print(\u0026quot;200 Switching to Binary mode.\\r\\n\u0026quot;)\n+    }\n+    begin\n+      chdir_to_tmpdir do\n+        File.open(\u0026quot;|echo hello\u0026quot;, \u0026quot;w\u0026quot;) do |f|\n+          f.puts(\u0026quot;foo\u0026quot;)\n+          f.puts(\u0026quot;bar\u0026quot;)\n+          f.puts(\u0026quot;baz\u0026quot;)\n+        end\n+        begin\n+          ftp = Net::FTP.new\n+          ftp.connect(SERVER_ADDR, server.port)\n+          ftp.login\n+          assert_match(/\\AUSER /, commands.shift)\n+          assert_match(/\\APASS /, commands.shift)\n+          assert_equal(\u0026quot;TYPE I\\r\\n\u0026quot;, commands.shift)\n+          ftp.puttextfile(\u0026quot;|echo hello\u0026quot;)\n+          assert_equal(\u0026lt;\u0026lt;EOF.gsub(/\\n/, \u0026quot;\\r\\n\u0026quot;), received_data)\n+foo\n+bar\n+baz\n+EOF\n+          assert_equal(\u0026quot;TYPE A\\r\\n\u0026quot;, commands.shift)\n+          assert_match(/\\A(PORT|EPRT) /, commands.shift)\n+          assert_equal(\u0026quot;STOR |echo hello\\r\\n\u0026quot;, commands.shift)\n+          assert_equal(\u0026quot;TYPE I\\r\\n\u0026quot;, commands.shift)\n+          assert_equal(nil, commands.shift)\n+        ensure\n+          ftp.close if ftp\n+        end\n+      end\n+    ensure\n+      server.close\n+    end\n+  end\n+\n\u003c/span\u003e   private\n\n   def create_ftp_server(sleep_time = nil)\n\u003cspan class=\"p\"\u003e@@ -2232,4 +2454,16 @@\u003c/span\u003e def create_data_connection_server(sock)\n     end\n     return data_server\n   end\n\u003cspan class=\"gi\"\u003e+\n+  def chdir_to_tmpdir\n+    Dir.mktmpdir do |dir|\n+      pwd = Dir.pwd\n+      Dir.chdir(dir)\n+      begin\n+        yield\n+      ensure\n+        Dir.chdir(pwd)\n+      end\n+    end\n+  end\n\u003c/span\u003e end\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","automated_response":false,"created_at":"2017-12-02T17:04:40.953Z","updated_at":"2017-12-02T17:04:40.953Z","actor":{"username":"shugo","cleared":false,"url":"/shugo","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/076/177/c63f990ae1ef62a77c2ff1e5b2db5e4dd3db2557_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":2199492,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"I believe the patch solves the issue :)\nOut of curiosity, do you have a patch timeframe? ","markdown_message":"\u003cp\u003eI believe the patch solves the issue :)\u003cbr\u003e\nOut of curiosity, do you have a patch timeframe? \u003c/p\u003e\n","automated_response":false,"created_at":"2017-12-04T18:33:02.790Z","updated_at":"2017-12-04T18:33:02.790Z","actor":{"username":"staaldraad","cleared":false,"url":"/staaldraad","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":2200775,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Thanks for your confirmation.\n\nWe are planning to make releases on this month, if possible, before the release of 2.5 scheduled on Dec 25.\n","markdown_message":"\u003cp\u003eThanks for your confirmation.\u003c/p\u003e\n\n\u003cp\u003eWe are planning to make releases on this month, if possible, before the release of 2.5 scheduled on Dec 25.\u003c/p\u003e\n","automated_response":false,"created_at":"2017-12-05T01:38:10.216Z","updated_at":"2017-12-05T01:38:10.216Z","actor":{"username":"shugo","cleared":false,"url":"/shugo","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/076/177/c63f990ae1ef62a77c2ff1e5b2db5e4dd3db2557_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":2200896,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Here's an announcement draft.  Could you check the Credit?\n\n# Command injection vulnerability in Net::FTP\nThere is a command injection vulnerability in Net::FTP bundled with Ruby.  This vulnerability has been assigned the CVE identifier CVE-2017-XXXXX.\n\n## Details\nNet::FTP#get, getbinaryfile, gettextfile, put, putbinaryfile, and puttextfile use Kernel#open to open a local file.  If the `localfile` argument starts with the pipe character `\"|\"`, the command following the pipe character is executed.  The default value of `localfile` is `File.basename(remotefile)`, so malicious FTP servers could cause arbitrary command execution.\n\nAll users running an affected release should upgrade immediately.\n\n## Affected Versions\nRuby 2.2 series: 2.2.8 and earlier\nRuby 2.3 series: 2.3.5 and earlier\nRuby 2.4 series: 2.4.2 and earlier\nRuby 2.5 series: 2.5.0-preview1\nprior to trunk revision rXXXXX\n\n## Credit\nThanks to Etienne Stalmans for reporting this issue.\n\n## History\n* Originally published at 2017-12-XX XX:XX:XX (UTC)\n","markdown_message":"\u003cp\u003eHere\u0026#39;s an announcement draft.  Could you check the Credit?\u003c/p\u003e\n\n\u003ch1 id=\"command-injection-vulnerability-in-net-ftp\"\u003eCommand injection vulnerability in Net::FTP\u003c/h1\u003e\n\n\u003cp\u003eThere is a command injection vulnerability in Net::FTP bundled with Ruby.  This vulnerability has been assigned the CVE identifier CVE-2017-XXXXX.\u003c/p\u003e\n\n\u003ch2 id=\"details\"\u003eDetails\u003c/h2\u003e\n\n\u003cp\u003eNet::FTP#get, getbinaryfile, gettextfile, put, putbinaryfile, and puttextfile use Kernel#open to open a local file.  If the \u003ccode\u003elocalfile\u003c/code\u003e argument starts with the pipe character \u003ccode\u003e\u0026quot;|\u0026quot;\u003c/code\u003e, the command following the pipe character is executed.  The default value of \u003ccode\u003elocalfile\u003c/code\u003e is \u003ccode\u003eFile.basename(remotefile)\u003c/code\u003e, so malicious FTP servers could cause arbitrary command execution.\u003c/p\u003e\n\n\u003cp\u003eAll users running an affected release should upgrade immediately.\u003c/p\u003e\n\n\u003ch2 id=\"affected-versions\"\u003eAffected Versions\u003c/h2\u003e\n\n\u003cp\u003eRuby 2.2 series: 2.2.8 and earlier\u003cbr\u003e\nRuby 2.3 series: 2.3.5 and earlier\u003cbr\u003e\nRuby 2.4 series: 2.4.2 and earlier\u003cbr\u003e\nRuby 2.5 series: 2.5.0-preview1\u003cbr\u003e\nprior to trunk revision rXXXXX\u003c/p\u003e\n\n\u003ch2 id=\"credit\"\u003eCredit\u003c/h2\u003e\n\n\u003cp\u003eThanks to Etienne Stalmans for reporting this issue.\u003c/p\u003e\n\n\u003ch2 id=\"history\"\u003eHistory\u003c/h2\u003e\n\n\u003cul\u003e\n\u003cli\u003eOriginally published at 2017-12-XX XX:XX:XX (UTC)\u003c/li\u003e\n\u003c/ul\u003e\n","automated_response":false,"created_at":"2017-12-05T04:14:00.674Z","updated_at":"2017-12-05T04:14:00.674Z","actor":{"username":"shugo","cleared":false,"url":"/shugo","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/076/177/c63f990ae1ef62a77c2ff1e5b2db5e4dd3db2557_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":2201061,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"FYI: CVE-2017-17405 is assigned.\n","markdown_message":"\u003cp\u003eFYI: CVE-2017-17405 is assigned.\u003c/p\u003e\n","automated_response":false,"created_at":"2017-12-05T07:42:16.571Z","updated_at":"2017-12-05T07:42:16.571Z","actor":{"username":"shugo","cleared":false,"url":"/shugo","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/076/177/c63f990ae1ef62a77c2ff1e5b2db5e4dd3db2557_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":2201070,"is_internal":false,"editable":false,"type":"Activities::CveIdAdded","message":"","markdown_message":"","automated_response":false,"created_at":"2017-12-05T07:47:42.488Z","updated_at":"2017-12-05T07:47:42.488Z","cve_ids":["CVE-2017-17405"],"actor":{"username":"reed","cleared":false,"url":"/reed","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/003/132/66d7eadcea16b878bb67bfd697b9542250a801a7_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":true},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":2201242,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Thanks for update and the CVE, that is brilliant news :)\n\nCould we make the credit:\nThanks to Etienne Stalmans from the Heroku product security team for reporting the issue.\n\nBest,\nEtienne","markdown_message":"\u003cp\u003eThanks for update and the CVE, that is brilliant news :)\u003c/p\u003e\n\n\u003cp\u003eCould we make the credit:\u003cbr\u003e\nThanks to Etienne Stalmans from the Heroku product security team for reporting the issue.\u003c/p\u003e\n\n\u003cp\u003eBest,\u003cbr\u003e\nEtienne\u003c/p\u003e\n","automated_response":false,"created_at":"2017-12-05T09:54:47.404Z","updated_at":"2017-12-05T09:54:47.404Z","actor":{"username":"staaldraad","cleared":false,"url":"/staaldraad","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":2203180,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Thanks for you confirmation.\nWe'll make the credit as you suggested.\n","markdown_message":"\u003cp\u003eThanks for you confirmation.\u003cbr\u003e\nWe\u0026#39;ll make the credit as you suggested.\u003c/p\u003e\n","automated_response":false,"created_at":"2017-12-06T01:40:22.067Z","updated_at":"2017-12-06T01:40:22.067Z","actor":{"username":"shugo","cleared":false,"url":"/shugo","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/076/177/c63f990ae1ef62a77c2ff1e5b2db5e4dd3db2557_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":2224850,"is_internal":false,"editable":false,"type":"Activities::BugResolved","message":"We've released fixed versions and disclosed the vulnerability:\n\nhttp://www.ruby-lang.org/en/news/2017/12/14/net-ftp-command-injection-cve-2017-17405/\n\nThank you!\n","markdown_message":"\u003cp\u003eWe\u0026#39;ve released fixed versions and disclosed the vulnerability:\u003c/p\u003e\n\n\u003cp\u003e\u003ca title=\"http://www.ruby-lang.org/en/news/2017/12/14/net-ftp-command-injection-cve-2017-17405/\" href=\"/redirect?url=http%3A%2F%2Fwww.ruby-lang.org%2Fen%2Fnews%2F2017%2F12%2F14%2Fnet-ftp-command-injection-cve-2017-17405%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttp://www.ruby-lang.org/en/news/2017/12/14/net-ftp-command-injection-cve-2017-17405/\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eThank you!\u003c/p\u003e\n","automated_response":false,"created_at":"2017-12-15T04:01:51.604Z","updated_at":"2017-12-15T04:01:51.604Z","actor":{"username":"shugo","cleared":false,"url":"/shugo","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/076/177/c63f990ae1ef62a77c2ff1e5b2db5e4dd3db2557_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"reporter":{"username":"staaldraad","url":"/staaldraad"},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":2224851,"is_internal":false,"editable":false,"type":"Activities::BountyAwarded","message":"","markdown_message":"","automated_response":false,"created_at":"2017-12-15T04:08:41.806Z","updated_at":"2017-12-15T04:08:41.806Z","actor":{"url":"/ruby","ibb":true,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/007/724/bb067434deef370d6a0b16c2cbbc030b57c75e92_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"Ruby"}},"bounty_amount":"1000.0","bounty_currency":"usd","bonus_amount":"0.0","genius_execution_id":null,"team_handle":"ruby","collaborator":{"username":"staaldraad","url":"/staaldraad"},"actor_is_team_member":true,"actor_is_concealed_member":false},{"id":2225059,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Thanks @shugo! Such a great turn around time on this and it's been a smooth disclosure process. \nHopefully (for me) I'll be back with another report in the future :)","markdown_message":"\u003cp\u003eThanks \u003ca href=\"/shugo\"\u003e@shugo\u003c/a\u003e! Such a great turn around time on this and it\u0026#39;s been a smooth disclosure process. \u003cbr\u003e\nHopefully (for me) I\u0026#39;ll be back with another report in the future :)\u003c/p\u003e\n","automated_response":false,"created_at":"2017-12-15T07:49:53.740Z","updated_at":"2017-12-15T07:49:53.740Z","actor":{"username":"staaldraad","cleared":false,"url":"/staaldraad","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":2233334,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","markdown_message":"","automated_response":false,"created_at":"2017-12-19T01:02:52.119Z","updated_at":"2017-12-19T01:02:52.119Z","first_to_agree":true,"actor":{"username":"hsbt","cleared":false,"url":"/hsbt","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/051/808/c3eeedf7f0d1a3c3eead4e0106bbcc4441e0d9f5_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":2233657,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","markdown_message":"","automated_response":false,"created_at":"2017-12-19T06:25:23.313Z","updated_at":"2017-12-19T06:25:23.313Z","actor":{"username":"staaldraad","cleared":false,"url":"/staaldraad","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":2233658,"is_internal":false,"editable":false,"type":"Activities::ReportBecamePublic","message":"","markdown_message":"","automated_response":false,"created_at":"2017-12-19T06:25:23.411Z","updated_at":"2017-12-19T06:25:23.411Z","actor":{"username":"staaldraad","cleared":false,"url":"/staaldraad","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":false,"actor_is_concealed_member":false}],"activity_page_count":1,"activity_page_number":1,"summaries":[{"category":"team","can_view?":true,"can_create?":false},{"category":"researcher","can_view?":true,"can_create?":false}]}