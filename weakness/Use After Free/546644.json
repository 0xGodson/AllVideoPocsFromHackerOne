{"id":546644,"global_id":"Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC81NDY2NDQ=","url":"https://hackerone.com/reports/546644","title":"Two heap use-after-free errors in IMAP operations","state":"Closed","substate":"resolved","severity_rating":"medium","readable_substate":"Resolved","created_at":"2019-04-23T05:04:17.560Z","submitted_at":"2019-04-23T05:04:17.560Z","is_member_of_team?":false,"reporter":{"disabled":false,"username":"nick_roessler","url":"/nick_roessler","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/577/276/39ba4fb54ca9bc03bb59a9360be99caf8f832882_original.png/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a"},"is_me?":false,"cleared":false,"hackerone_triager":false,"hacker_mediation":false},"team":{"id":8906,"url":"https://hackerone.com/open-xchange","handle":"open-xchange","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/JtYLEsu5yRZxGitSmAjeAFtK/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a","medium":"https://profile-photos.hackerone-user-content.com/variants/JtYLEsu5yRZxGitSmAjeAFtK/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"permissions":[],"submission_state":"open","default_currency":"usd","awards_miles":false,"offers_bounties":true,"state":"public_mode","only_cleared_hackers":false,"profile":{"name":"Open-Xchange","twitter_handle":"openxchange","website":"https://www.open-xchange.com/","about":"Messaging, collaboration and office productivity software for service providers"}},"has_bounty?":true,"in_validation?":false,"rejected_anc_report_that_can_be_sent_back_to_anc_triagers?":false,"can_view_team":true,"can_view_report":true,"is_external_bug":false,"is_published":false,"is_participant":false,"stage":4,"public":true,"visibility":"full","cve_ids":[],"singular_disclosure_disabled":true,"disclosed_at":"2020-01-08T18:23:50.540Z","bug_reporter_agreed_on_going_public_at":"2020-01-08T18:23:50.456Z","team_member_agreed_on_going_public_at":"2020-01-07T11:46:03.543Z","comments_closed?":false,"facebook_team?":false,"team_private?":false,"vulnerability_information":"Summary\n=======\nWe’ve found two heap use-after-free errors, one in lib-storage/index/index-storage.c: index_copy_cache_fields() and one in lib-index/mail-index-sync-update.c: mail_index_sync_record_real(). \n\nError 1: index_copy_cache_fields()\n----------------------------------------------\n\nThis error involves two functions, shown below:\n\nIn src/lib-storage/index/index-storage.c:\n```\nvoid index_copy_cache_fields(struct mail_save_context *ctx,\n                 struct mail *src_mail, uint32_t dest_seq)\n{\n    T_BEGIN {\n        struct mailbox_metadata src_metadata, dest_metadata;\n        const struct mailbox_cache_field *field;\n        buffer_t *buf;\n\n        if (mailbox_get_metadata(src_mail-\u003ebox,\n                     MAILBOX_METADATA_CACHE_FIELDS,\n                     \u0026src_metadata) \u003c 0)\n            i_unreached();\n        /* the only reason we're doing the destination lookup is to\n           make sure that the cache file is opened and the cache\n           decisions are up to date */\n        if (mailbox_get_metadata(ctx-\u003etransaction-\u003ebox,\n                     MAILBOX_METADATA_CACHE_FIELDS,\n                     \u0026dest_metadata) \u003c 0)\n            i_unreached();\n\n        buf = t_buffer_create(1024);\n        array_foreach(src_metadata.cache_fields, field) {\n            mail_copy_cache_field(ctx, src_mail, dest_seq,\n                          field-\u003ename, buf);\n        }\n        index_copy_vsize_extension(ctx, src_mail, dest_seq);\n    } T_END;\n}\n```\nIn src/lib-storage/mail-storage.c\n\n```\nint mailbox_get_metadata(struct mailbox *box, enum mailbox_metadata_items items,\n             struct mailbox_metadata *metadata_r)\n{\n    i_zero(metadata_r);\n    if (mailbox_verify_existing_name(box) \u003c 0)\n        return -1;\n\n    if (box-\u003emetadata_pool != NULL)\n        p_clear(box-\u003emetadata_pool);\n\n    if (box-\u003ev.get_metadata(box, items, metadata_r) \u003c 0)\n        return -1;\n\n    i_assert((items \u0026 MAILBOX_METADATA_GUID) == 0 ||\n         !guid_128_is_empty(metadata_r-\u003eguid));\n    return 0;\n}\n```\nThe error is triggered when a mailbox is selected and a COPY command is issued to the same mailbox. \n\nHere is the flow of events leading up to a use-after-free:\n\n1. We enter index_copy_cache_fields() with src_mail-\u003ebox and ctx-\u003etransaction-\u003ebox pointing to the same mailbox structure. box -\u003e metadata_pool is currently NULL. \n2. We call mailbox_get_metadata() the first time. The pool is currently NULL, which causes us to skip the p_clear() and allocate a pool from the get_metadata() call. The output of the function is stored to the stack-allocated src_metadata, which includes heap pointers to the pool.\n3. We call mailbox_get_metadata() the second time. This time the pool is not NULL, which causes p_clear() to free() the metadata pool and allocate a new pool. However, the stack-allocated src_metadata structure now contains dangling pointers to the freed heap data.\n4. We continue to the array_foreach, in which field is repeatedly set to freed heap data. mail_copy_cache_field() is called and a pointer to the freed data is passed along as an argument. mail_copy_cache_field() is itself complex function that in turn calls many other functions.\n\nWe have seen this error produce illegal reads from 3 places in the source code. Attached are 3 screenshots showing these ASAN errors. \n\nWe’ve observed that MOVE can also trigger this error because it invokes this copy function.  We do not know if other commands are affected.\n\n## Steps to reproduce\n1. Compile Dovecot with ASAN to detect memory errors\n2. Run the following session: \n\na0001 SELECT \"Junk\"\na0002 COPY 1  \"Junk\"\n\nWith an appropriate maildir containing a “Junk” mailbox. To reach some of the deeper ASAN errors, ASAN must be run with halt_on_error=0 so that it doesn’t abort on the first memory error. Both of these memory errors are fragile with respect to the exact command and state of the maildir. If the above session (or random tweaks to it) are not sufficient to reproduce/analyze it, we can supply a sample mail directory that will.\n\n## Fixing\nA local fix is first checking if the two mailboxes are the same, and if they are then skipping the second mailbox_get_metadata() call. Based on the comment there, it looks like the proper cache file should already be opened and the cache decisions should be up to date given the exact same box was already opened. We’re not sure if more global fixes are appropriate---this was caused because the mailboxes are the same, so maybe some commands need additional scrutiny or should be prevented from running if source and dest are the same.\n\nError 2: mail_index_sync_record_real()\n---------------------------------------------------\n\nThe second error occurs in the following code (only relevant portion shown):\nIn src/lib-index/mail-index-sync-update.c:\n```\n    case MAIL_TRANSACTION_EXT_HDR_UPDATE: {\n        const struct mail_transaction_ext_hdr_update *rec;\n        unsigned int i;\n\n        for (i = 0; i \u003c hdr-\u003esize; ) {\n            rec = CONST_PTR_OFFSET(data, i);\n\n            if (i + sizeof(*rec) \u003e hdr-\u003esize ||\n                i + sizeof(*rec) + rec-\u003esize \u003e hdr-\u003esize) {\n                mail_index_sync_set_corrupted(ctx,\n                    \"ext hdr update: invalid record size\");\n                ret = -1;\n                break;\n            }\n\n            ret = mail_index_sync_ext_hdr_update(ctx, rec-\u003eoffset,\n                                 rec-\u003esize, rec + 1);\n            if (ret \u003c= 0)\n                break;\n\n            i += sizeof(*rec) + rec-\u003esize;\n            if ((i % 4) != 0)\n                i += 4 - (i % 4);\n        }\n        break;\n    }\n```\n\nThe error is that the rec object (or rather, the data object) can be freed from inside the call to mail_index_sync_ext_hdr_update(), which leaves the rec pointer dangling. It is used several lines later to access the size field. Attached is a screenshot showing this error from ASAN.\n\nWe were not able to figure out this error detail in the time we allocated for preparing this report.  However, as shown in the screenshot, we do see that rec was freed from mail_transaction_log_file_mmap(). Hopefully this is enough information that the devs can understand what has happened; we are happy to continue helping to resolve this issue if not.\n\n## Example Session\nThe session below was produced from our fuzzer and then manually simplified to the minimum session that still caused the error. As noted above, it may not be enough to reproduce on other configurations. The junk folder has exactly 33 messages and does not have the other folders that are created in the example session.\n\na3 SELECT \"Junk\"\na4 STORE 1:33 FLAGS D FLAGS+INSMALLER TE\na5 STORE 1:33 FLAGS D F8AGS+INSMALLER TE\na6 STORE 1:33 FLAGS D FLAGS+INSMALLER TE\na7 CLOSE\na8 CREATE a\na9 CREATE b\na10 CREATE c\na11 SELECT \"Junk\"\na12 COPY 1 INBOX\na13 COPY 1 \"Junk\"\na14 MOVE 1 \"Junk\"\na15 MOVE 1 \"Junk\"\na16 FETCH 1 (MODSEQ)\n\n## Impact\n\nWe’re not sure about the exploitability of these two errors. Here are some possible attacks that could result from the errors, or side-effects that could be used as a component of other attacks.\n\nFor the first error, if additional heap operations on that memory pool could be triggered, then feasible attack paths could be constructed. If the allocator reallocated that freed memory before it was used by the dangling pointer, then an attacker could gain control of the field pointer or worse might be able to trigger a double free which could lead to full memory corruption. Our fuzzer didn’t find a way to do this and we don’t see a clear path there; however, it is complicated and *many* functions do get called after index_copy_cache_field(), so the possibility is certainly there and this error should be fixed.\n\nFor the second error, an attacker could gain control of this loop in a few ways if the freed object is reused by the allocator. The attacker could trivially control i by controlling the freed memory. Because i changes the control-flow of the program, it could be used to leak bytes from other heap objects: one can simply observe which headers get copied. This could be useful as a component of another more complicated attack (e.g., could be used to break entropy of defenses like ASLR to enable other exploits). Further, the outer loop could be made to run indefinitely by setting rec -\u003e size in such a way to negate the sizeof(rec) so that i does not change values between loop iterations, which could lead to a denial of service of server resources. Finally, because we don’t fully understand this error, we’re not sure if other kinds of double frees or memory corruptions could be caused with appropriate inputs to mail_index_sync_ext_hdr_update().","vulnerability_information_html":"\u003ch1 id=\"summary\"\u003eSummary\u003c/h1\u003e\n\n\u003cp\u003eWe’ve found two heap use-after-free errors, one in lib-storage/index/index-storage.c: index_copy_cache_fields() and one in lib-index/mail-index-sync-update.c: mail_index_sync_record_real(). \u003c/p\u003e\n\n\u003ch2 id=\"error-1-index_copy_cache_fields\"\u003eError 1: index_copy_cache_fields()\u003c/h2\u003e\n\n\u003cp\u003eThis error involves two functions, shown below:\u003c/p\u003e\n\n\u003cp\u003eIn src/lib-storage/index/index-storage.c:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003evoid index_copy_cache_fields(struct mail_save_context *ctx,\n                 struct mail *src_mail, uint32_t dest_seq)\n{\n    T_BEGIN {\n        struct mailbox_metadata src_metadata, dest_metadata;\n        const struct mailbox_cache_field *field;\n        buffer_t *buf;\n\n        if (mailbox_get_metadata(src_mail-\u0026gt;box,\n                     MAILBOX_METADATA_CACHE_FIELDS,\n                     \u0026amp;src_metadata) \u0026lt; 0)\n            i_unreached();\n        /* the only reason we\u0026#39;re doing the destination lookup is to\n           make sure that the cache file is opened and the cache\n           decisions are up to date */\n        if (mailbox_get_metadata(ctx-\u0026gt;transaction-\u0026gt;box,\n                     MAILBOX_METADATA_CACHE_FIELDS,\n                     \u0026amp;dest_metadata) \u0026lt; 0)\n            i_unreached();\n\n        buf = t_buffer_create(1024);\n        array_foreach(src_metadata.cache_fields, field) {\n            mail_copy_cache_field(ctx, src_mail, dest_seq,\n                          field-\u0026gt;name, buf);\n        }\n        index_copy_vsize_extension(ctx, src_mail, dest_seq);\n    } T_END;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eIn src/lib-storage/mail-storage.c\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003eint mailbox_get_metadata(struct mailbox *box, enum mailbox_metadata_items items,\n             struct mailbox_metadata *metadata_r)\n{\n    i_zero(metadata_r);\n    if (mailbox_verify_existing_name(box) \u0026lt; 0)\n        return -1;\n\n    if (box-\u0026gt;metadata_pool != NULL)\n        p_clear(box-\u0026gt;metadata_pool);\n\n    if (box-\u0026gt;v.get_metadata(box, items, metadata_r) \u0026lt; 0)\n        return -1;\n\n    i_assert((items \u0026amp; MAILBOX_METADATA_GUID) == 0 ||\n         !guid_128_is_empty(metadata_r-\u0026gt;guid));\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe error is triggered when a mailbox is selected and a COPY command is issued to the same mailbox. \u003c/p\u003e\n\n\u003cp\u003eHere is the flow of events leading up to a use-after-free:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eWe enter index_copy_cache_fields() with src_mail-\u0026gt;box and ctx-\u0026gt;transaction-\u0026gt;box pointing to the same mailbox structure. box -\u0026gt; metadata_pool is currently NULL. \u003c/li\u003e\n\u003cli\u003eWe call mailbox_get_metadata() the first time. The pool is currently NULL, which causes us to skip the p_clear() and allocate a pool from the get_metadata() call. The output of the function is stored to the stack-allocated src_metadata, which includes heap pointers to the pool.\u003c/li\u003e\n\u003cli\u003eWe call mailbox_get_metadata() the second time. This time the pool is not NULL, which causes p_clear() to free() the metadata pool and allocate a new pool. However, the stack-allocated src_metadata structure now contains dangling pointers to the freed heap data.\u003c/li\u003e\n\u003cli\u003eWe continue to the array_foreach, in which field is repeatedly set to freed heap data. mail_copy_cache_field() is called and a pointer to the freed data is passed along as an argument. mail_copy_cache_field() is itself complex function that in turn calls many other functions.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eWe have seen this error produce illegal reads from 3 places in the source code. Attached are 3 screenshots showing these ASAN errors. \u003c/p\u003e\n\n\u003cp\u003eWe’ve observed that MOVE can also trigger this error because it invokes this copy function.  We do not know if other commands are affected.\u003c/p\u003e\n\n\u003ch2 id=\"steps-to-reproduce\"\u003eSteps to reproduce\u003c/h2\u003e\n\n\u003col\u003e\n\u003cli\u003eCompile Dovecot with ASAN to detect memory errors\u003c/li\u003e\n\u003cli\u003eRun the following session: \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003ea0001 SELECT \u0026quot;Junk\u0026quot;\u003cbr\u003e\na0002 COPY 1  \u0026quot;Junk\u0026quot;\u003c/p\u003e\n\n\u003cp\u003eWith an appropriate maildir containing a “Junk” mailbox. To reach some of the deeper ASAN errors, ASAN must be run with halt_on_error=0 so that it doesn’t abort on the first memory error. Both of these memory errors are fragile with respect to the exact command and state of the maildir. If the above session (or random tweaks to it) are not sufficient to reproduce/analyze it, we can supply a sample mail directory that will.\u003c/p\u003e\n\n\u003ch2 id=\"fixing\"\u003eFixing\u003c/h2\u003e\n\n\u003cp\u003eA local fix is first checking if the two mailboxes are the same, and if they are then skipping the second mailbox_get_metadata() call. Based on the comment there, it looks like the proper cache file should already be opened and the cache decisions should be up to date given the exact same box was already opened. We’re not sure if more global fixes are appropriate---this was caused because the mailboxes are the same, so maybe some commands need additional scrutiny or should be prevented from running if source and dest are the same.\u003c/p\u003e\n\n\u003ch2 id=\"error-2-mail_index_sync_record_real\"\u003eError 2: mail_index_sync_record_real()\u003c/h2\u003e\n\n\u003cp\u003eThe second error occurs in the following code (only relevant portion shown):\u003cbr\u003e\nIn src/lib-index/mail-index-sync-update.c:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e    case MAIL_TRANSACTION_EXT_HDR_UPDATE: {\n        const struct mail_transaction_ext_hdr_update *rec;\n        unsigned int i;\n\n        for (i = 0; i \u0026lt; hdr-\u0026gt;size; ) {\n            rec = CONST_PTR_OFFSET(data, i);\n\n            if (i + sizeof(*rec) \u0026gt; hdr-\u0026gt;size ||\n                i + sizeof(*rec) + rec-\u0026gt;size \u0026gt; hdr-\u0026gt;size) {\n                mail_index_sync_set_corrupted(ctx,\n                    \u0026quot;ext hdr update: invalid record size\u0026quot;);\n                ret = -1;\n                break;\n            }\n\n            ret = mail_index_sync_ext_hdr_update(ctx, rec-\u0026gt;offset,\n                                 rec-\u0026gt;size, rec + 1);\n            if (ret \u0026lt;= 0)\n                break;\n\n            i += sizeof(*rec) + rec-\u0026gt;size;\n            if ((i % 4) != 0)\n                i += 4 - (i % 4);\n        }\n        break;\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe error is that the rec object (or rather, the data object) can be freed from inside the call to mail_index_sync_ext_hdr_update(), which leaves the rec pointer dangling. It is used several lines later to access the size field. Attached is a screenshot showing this error from ASAN.\u003c/p\u003e\n\n\u003cp\u003eWe were not able to figure out this error detail in the time we allocated for preparing this report.  However, as shown in the screenshot, we do see that rec was freed from mail_transaction_log_file_mmap(). Hopefully this is enough information that the devs can understand what has happened; we are happy to continue helping to resolve this issue if not.\u003c/p\u003e\n\n\u003ch2 id=\"example-session\"\u003eExample Session\u003c/h2\u003e\n\n\u003cp\u003eThe session below was produced from our fuzzer and then manually simplified to the minimum session that still caused the error. As noted above, it may not be enough to reproduce on other configurations. The junk folder has exactly 33 messages and does not have the other folders that are created in the example session.\u003c/p\u003e\n\n\u003cp\u003ea3 SELECT \u0026quot;Junk\u0026quot;\u003cbr\u003e\na4 STORE 1:33 FLAGS D FLAGS+INSMALLER TE\u003cbr\u003e\na5 STORE 1:33 FLAGS D F8AGS+INSMALLER TE\u003cbr\u003e\na6 STORE 1:33 FLAGS D FLAGS+INSMALLER TE\u003cbr\u003e\na7 CLOSE\u003cbr\u003e\na8 CREATE a\u003cbr\u003e\na9 CREATE b\u003cbr\u003e\na10 CREATE c\u003cbr\u003e\na11 SELECT \u0026quot;Junk\u0026quot;\u003cbr\u003e\na12 COPY 1 INBOX\u003cbr\u003e\na13 COPY 1 \u0026quot;Junk\u0026quot;\u003cbr\u003e\na14 MOVE 1 \u0026quot;Junk\u0026quot;\u003cbr\u003e\na15 MOVE 1 \u0026quot;Junk\u0026quot;\u003cbr\u003e\na16 FETCH 1 (MODSEQ)\u003c/p\u003e\n\n\u003ch2 id=\"impact\"\u003eImpact\u003c/h2\u003e\n\n\u003cp\u003eWe’re not sure about the exploitability of these two errors. Here are some possible attacks that could result from the errors, or side-effects that could be used as a component of other attacks.\u003c/p\u003e\n\n\u003cp\u003eFor the first error, if additional heap operations on that memory pool could be triggered, then feasible attack paths could be constructed. If the allocator reallocated that freed memory before it was used by the dangling pointer, then an attacker could gain control of the field pointer or worse might be able to trigger a double free which could lead to full memory corruption. Our fuzzer didn’t find a way to do this and we don’t see a clear path there; however, it is complicated and \u003cem\u003emany\u003c/em\u003e functions do get called after index_copy_cache_field(), so the possibility is certainly there and this error should be fixed.\u003c/p\u003e\n\n\u003cp\u003eFor the second error, an attacker could gain control of this loop in a few ways if the freed object is reused by the allocator. The attacker could trivially control i by controlling the freed memory. Because i changes the control-flow of the program, it could be used to leak bytes from other heap objects: one can simply observe which headers get copied. This could be useful as a component of another more complicated attack (e.g., could be used to break entropy of defenses like ASLR to enable other exploits). Further, the outer loop could be made to run indefinitely by setting rec -\u0026gt; size in such a way to negate the sizeof(rec) so that i does not change values between loop iterations, which could lead to a denial of service of server resources. Finally, because we don’t fully understand this error, we’re not sure if other kinds of double frees or memory corruptions could be caused with appropriate inputs to mail_index_sync_ext_hdr_update().\u003c/p\u003e\n","bounty_amount":"1200.0","formatted_bounty":"$1,200","weakness":{"id":50,"name":"Use After Free"},"original_report_id":null,"original_report_url":null,"attachments":[{"id":474198,"file_name":"error_1_index_copy_cache_fields.png","expiring_url":"https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/000/474/198/492030c93e8426d6004436a1ba38914424a3d4e8/error_1_index_copy_cache_fields.png?response-content-disposition=attachment%3B%20filename%3D%22error_1_index_copy_cache_fields.png%22%3B%20filename%2A%3DUTF-8%27%27error_1_index_copy_cache_fields.png\u0026response-content-type=image%2Fpng\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\u0026X-Amz-Credential=ASIAQGK6FURQSCEBX24Z%2F20201229%2Fus-west-2%2Fs3%2Faws4_request\u0026X-Amz-Date=20201229T115151Z\u0026X-Amz-Expires=3600\u0026X-Amz-SignedHeaders=host\u0026X-Amz-Security-Token=IQoJb3JpZ2luX2VjEKH%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQDbbNRdndKEP43iUDjmnvgiykgaCqJTHblmGRuP2Ec6sAIhAI24g2GqtGOq1FpPu4d%2BZjFGwBk3kFprwfcNIx35R0EKKrQDCFoQARoMMDEzNjE5Mjc0ODQ5Igzz0WYG4PbKwI%2BjK%2F8qkQM6hzwHPCDVH5rah5p%2BP5pR9q43gGOf78CInFxDnQbAMxnC97jILCzKR8dVr4XMfOOUSrEvKDC2Kp%2FZiHbJ0KHRaxvac%2FHsd%2BEsj5RKWF5pbJsH9jm44uxPZJGVUFdO8WhTV0V8b%2F%2BApgNLzvlTFXOZ3t%2FNuPGWsRsXqM4BBHtmbT%2B9tt5UkxTwkBZw4QjBM4jpmXh%2FprQj6CmvnQixj%2B6F9ZI2PCDH50RMoqSjIKUXDQ2kv4Pmn4QNez8tBcAsuAbci%2BNeC%2FnCJQsflwKz%2Bkvr8ViHgjXC7TolU6EiA1ARzZIoI7w7mXv4CQZ6VQRHnHexCAko%2BDJHgp5RcQ3n2P7wHrrqTD28zTFFuXykY07MxbPhDj75QWEWWTwNuZCXuOMfBgsEliRzSlp%2BcRIYO%2BrI2u0XNLmBGp2yNp5vU8kbOrsDRW3a4jmpjts%2B%2F6mT2JzxbGmN5tb1OxCrHsQvr1c8aFUtqyHneTwndeXUfvfVv0LTe%2BE4wirjyJC%2Bh27vBm5s50hWd8MH%2BfWbgmj9fMzWpDCE26v%2FBTrqAZWpzemdsxU%2BeFAPzyvrNyTSPKRutxT6xpFo99iWhwxJpFJYijcCO9T2NGPspnqL8%2FEx%2FfxrAM%2BOs6%2B6jHatpIa%2FbYkAJ%2F6qO27SA9j%2BIwa%2F0MaMay99zfrEbrG7vK6MSZTuojTpflRVaxq9JXK6Ncm7B67ttMi7m4CL8A6VHat0IAKfh5u664A6oN1VOlkLdLPySJOKeQfe6BhQ3cTsAsFYimJW6Mv6Hn6mbX85r9CGrc4tUKBXXX0JHcnAhT0wjW4zKF4mtCyEkt7Qa%2FBD2DoEOJV5alkNW%2Ffpd0sFocbYZU0w97tG59JXNw%3D%3D\u0026X-Amz-Signature=dca661fb9d11cb37dd067622fbf3c3ccdac1fdd0563a727a2ed2aace1f1bed99","file_size":273348,"type":"image/png"},{"id":474199,"file_name":"error_1_mail_copy_cache_field.png","expiring_url":"https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/000/474/199/3f3b796799dbf20e82a2a36f0c09903ec2641879/error_1_mail_copy_cache_field.png?response-content-disposition=attachment%3B%20filename%3D%22error_1_mail_copy_cache_field.png%22%3B%20filename%2A%3DUTF-8%27%27error_1_mail_copy_cache_field.png\u0026response-content-type=image%2Fpng\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\u0026X-Amz-Credential=ASIAQGK6FURQSCEBX24Z%2F20201229%2Fus-west-2%2Fs3%2Faws4_request\u0026X-Amz-Date=20201229T115151Z\u0026X-Amz-Expires=3600\u0026X-Amz-SignedHeaders=host\u0026X-Amz-Security-Token=IQoJb3JpZ2luX2VjEKH%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQDbbNRdndKEP43iUDjmnvgiykgaCqJTHblmGRuP2Ec6sAIhAI24g2GqtGOq1FpPu4d%2BZjFGwBk3kFprwfcNIx35R0EKKrQDCFoQARoMMDEzNjE5Mjc0ODQ5Igzz0WYG4PbKwI%2BjK%2F8qkQM6hzwHPCDVH5rah5p%2BP5pR9q43gGOf78CInFxDnQbAMxnC97jILCzKR8dVr4XMfOOUSrEvKDC2Kp%2FZiHbJ0KHRaxvac%2FHsd%2BEsj5RKWF5pbJsH9jm44uxPZJGVUFdO8WhTV0V8b%2F%2BApgNLzvlTFXOZ3t%2FNuPGWsRsXqM4BBHtmbT%2B9tt5UkxTwkBZw4QjBM4jpmXh%2FprQj6CmvnQixj%2B6F9ZI2PCDH50RMoqSjIKUXDQ2kv4Pmn4QNez8tBcAsuAbci%2BNeC%2FnCJQsflwKz%2Bkvr8ViHgjXC7TolU6EiA1ARzZIoI7w7mXv4CQZ6VQRHnHexCAko%2BDJHgp5RcQ3n2P7wHrrqTD28zTFFuXykY07MxbPhDj75QWEWWTwNuZCXuOMfBgsEliRzSlp%2BcRIYO%2BrI2u0XNLmBGp2yNp5vU8kbOrsDRW3a4jmpjts%2B%2F6mT2JzxbGmN5tb1OxCrHsQvr1c8aFUtqyHneTwndeXUfvfVv0LTe%2BE4wirjyJC%2Bh27vBm5s50hWd8MH%2BfWbgmj9fMzWpDCE26v%2FBTrqAZWpzemdsxU%2BeFAPzyvrNyTSPKRutxT6xpFo99iWhwxJpFJYijcCO9T2NGPspnqL8%2FEx%2FfxrAM%2BOs6%2B6jHatpIa%2FbYkAJ%2F6qO27SA9j%2BIwa%2F0MaMay99zfrEbrG7vK6MSZTuojTpflRVaxq9JXK6Ncm7B67ttMi7m4CL8A6VHat0IAKfh5u664A6oN1VOlkLdLPySJOKeQfe6BhQ3cTsAsFYimJW6Mv6Hn6mbX85r9CGrc4tUKBXXX0JHcnAhT0wjW4zKF4mtCyEkt7Qa%2FBD2DoEOJV5alkNW%2Ffpd0sFocbYZU0w97tG59JXNw%3D%3D\u0026X-Amz-Signature=cff31a95cba277d843b2f716a826a7a2d55100de17a2a8837455771237562033","file_size":283754,"type":"image/png"},{"id":474200,"file_name":"error_1_strcase_hash.png","expiring_url":"https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/000/474/200/55be97a0ad425a9a1e1a7177f002a2431e43d13e/error_1_strcase_hash.png?response-content-disposition=attachment%3B%20filename%3D%22error_1_strcase_hash.png%22%3B%20filename%2A%3DUTF-8%27%27error_1_strcase_hash.png\u0026response-content-type=image%2Fpng\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\u0026X-Amz-Credential=ASIAQGK6FURQSCEBX24Z%2F20201229%2Fus-west-2%2Fs3%2Faws4_request\u0026X-Amz-Date=20201229T115151Z\u0026X-Amz-Expires=3600\u0026X-Amz-SignedHeaders=host\u0026X-Amz-Security-Token=IQoJb3JpZ2luX2VjEKH%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQDbbNRdndKEP43iUDjmnvgiykgaCqJTHblmGRuP2Ec6sAIhAI24g2GqtGOq1FpPu4d%2BZjFGwBk3kFprwfcNIx35R0EKKrQDCFoQARoMMDEzNjE5Mjc0ODQ5Igzz0WYG4PbKwI%2BjK%2F8qkQM6hzwHPCDVH5rah5p%2BP5pR9q43gGOf78CInFxDnQbAMxnC97jILCzKR8dVr4XMfOOUSrEvKDC2Kp%2FZiHbJ0KHRaxvac%2FHsd%2BEsj5RKWF5pbJsH9jm44uxPZJGVUFdO8WhTV0V8b%2F%2BApgNLzvlTFXOZ3t%2FNuPGWsRsXqM4BBHtmbT%2B9tt5UkxTwkBZw4QjBM4jpmXh%2FprQj6CmvnQixj%2B6F9ZI2PCDH50RMoqSjIKUXDQ2kv4Pmn4QNez8tBcAsuAbci%2BNeC%2FnCJQsflwKz%2Bkvr8ViHgjXC7TolU6EiA1ARzZIoI7w7mXv4CQZ6VQRHnHexCAko%2BDJHgp5RcQ3n2P7wHrrqTD28zTFFuXykY07MxbPhDj75QWEWWTwNuZCXuOMfBgsEliRzSlp%2BcRIYO%2BrI2u0XNLmBGp2yNp5vU8kbOrsDRW3a4jmpjts%2B%2F6mT2JzxbGmN5tb1OxCrHsQvr1c8aFUtqyHneTwndeXUfvfVv0LTe%2BE4wirjyJC%2Bh27vBm5s50hWd8MH%2BfWbgmj9fMzWpDCE26v%2FBTrqAZWpzemdsxU%2BeFAPzyvrNyTSPKRutxT6xpFo99iWhwxJpFJYijcCO9T2NGPspnqL8%2FEx%2FfxrAM%2BOs6%2B6jHatpIa%2FbYkAJ%2F6qO27SA9j%2BIwa%2F0MaMay99zfrEbrG7vK6MSZTuojTpflRVaxq9JXK6Ncm7B67ttMi7m4CL8A6VHat0IAKfh5u664A6oN1VOlkLdLPySJOKeQfe6BhQ3cTsAsFYimJW6Mv6Hn6mbX85r9CGrc4tUKBXXX0JHcnAhT0wjW4zKF4mtCyEkt7Qa%2FBD2DoEOJV5alkNW%2Ffpd0sFocbYZU0w97tG59JXNw%3D%3D\u0026X-Amz-Signature=7848457471282aace2af734749187b415183b928f47827be1c43dc22c02f72f3","file_size":283294,"type":"image/png"},{"id":474201,"file_name":"error_2.png","expiring_url":"https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/000/474/201/fd79d35244e305c5b4917299599cb497529d3933/error_2.png?response-content-disposition=attachment%3B%20filename%3D%22error_2.png%22%3B%20filename%2A%3DUTF-8%27%27error_2.png\u0026response-content-type=image%2Fpng\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\u0026X-Amz-Credential=ASIAQGK6FURQSCEBX24Z%2F20201229%2Fus-west-2%2Fs3%2Faws4_request\u0026X-Amz-Date=20201229T115151Z\u0026X-Amz-Expires=3600\u0026X-Amz-SignedHeaders=host\u0026X-Amz-Security-Token=IQoJb3JpZ2luX2VjEKH%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQDbbNRdndKEP43iUDjmnvgiykgaCqJTHblmGRuP2Ec6sAIhAI24g2GqtGOq1FpPu4d%2BZjFGwBk3kFprwfcNIx35R0EKKrQDCFoQARoMMDEzNjE5Mjc0ODQ5Igzz0WYG4PbKwI%2BjK%2F8qkQM6hzwHPCDVH5rah5p%2BP5pR9q43gGOf78CInFxDnQbAMxnC97jILCzKR8dVr4XMfOOUSrEvKDC2Kp%2FZiHbJ0KHRaxvac%2FHsd%2BEsj5RKWF5pbJsH9jm44uxPZJGVUFdO8WhTV0V8b%2F%2BApgNLzvlTFXOZ3t%2FNuPGWsRsXqM4BBHtmbT%2B9tt5UkxTwkBZw4QjBM4jpmXh%2FprQj6CmvnQixj%2B6F9ZI2PCDH50RMoqSjIKUXDQ2kv4Pmn4QNez8tBcAsuAbci%2BNeC%2FnCJQsflwKz%2Bkvr8ViHgjXC7TolU6EiA1ARzZIoI7w7mXv4CQZ6VQRHnHexCAko%2BDJHgp5RcQ3n2P7wHrrqTD28zTFFuXykY07MxbPhDj75QWEWWTwNuZCXuOMfBgsEliRzSlp%2BcRIYO%2BrI2u0XNLmBGp2yNp5vU8kbOrsDRW3a4jmpjts%2B%2F6mT2JzxbGmN5tb1OxCrHsQvr1c8aFUtqyHneTwndeXUfvfVv0LTe%2BE4wirjyJC%2Bh27vBm5s50hWd8MH%2BfWbgmj9fMzWpDCE26v%2FBTrqAZWpzemdsxU%2BeFAPzyvrNyTSPKRutxT6xpFo99iWhwxJpFJYijcCO9T2NGPspnqL8%2FEx%2FfxrAM%2BOs6%2B6jHatpIa%2FbYkAJ%2F6qO27SA9j%2BIwa%2F0MaMay99zfrEbrG7vK6MSZTuojTpflRVaxq9JXK6Ncm7B67ttMi7m4CL8A6VHat0IAKfh5u664A6oN1VOlkLdLPySJOKeQfe6BhQ3cTsAsFYimJW6Mv6Hn6mbX85r9CGrc4tUKBXXX0JHcnAhT0wjW4zKF4mtCyEkt7Qa%2FBD2DoEOJV5alkNW%2Ffpd0sFocbYZU0w97tG59JXNw%3D%3D\u0026X-Amz-Signature=993e70da42a1cdf5131168b1089240acd3c13a344204722ccabfe70812e0104e","file_size":291524,"type":"image/png"}],"allow_singular_disclosure_at":null,"vote_count":26,"voters":["mashoud1122","bl4de","mygf","ihsinme","cr4xerbik4sh","b039f6018eb9056011859b0","pycycle","zimmer75","dademurphyzc","cryptographer","and 16 more..."],"severity":{"rating":"medium","author_type":"User"},"structured_scope":{"databaseId":42899,"asset_type":"SOURCE_CODE","asset_identifier":"https://github.com/dovecot/core","max_severity":"critical"},"abilities":{"assignable_team_members":[],"assignable_team_member_groups":[]},"can_edit_custom_fields_attributes":false,"activities":[{"id":4623289,"is_internal":false,"editable":false,"type":"Activities::ReportCollaboratorInvited","message":null,"markdown_message":"","automated_response":false,"created_at":"2019-04-23T05:04:48.761Z","updated_at":"2019-04-23T05:04:48.761Z","actor":{"username":"nick_roessler","cleared":false,"url":"/nick_roessler","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/577/276/39ba4fb54ca9bc03bb59a9360be99caf8f832882_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":null},"email":"rafiy","genius_execution_id":null,"team_handle":"open-xchange","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":4624718,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Thanks! We'll look into these.","markdown_message":"\u003cp\u003eThanks! We\u0026#39;ll look into these.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-04-23T09:21:31.351Z","updated_at":"2019-04-23T09:21:31.351Z","actor":{"username":"akituomi","cleared":false,"url":"/akituomi","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/060/216/805d230879c8e3757d37eedddaadf9efed0a8094_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"open-xchange","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":4630370,"is_internal":false,"editable":false,"type":"Activities::ReportCollaboratorJoined","message":"","markdown_message":"","automated_response":false,"created_at":"2019-04-23T22:21:47.670Z","updated_at":"2019-04-23T22:21:47.670Z","actor":{"username":"rafiy","cleared":false,"url":"/rafiy","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"open-xchange","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":4631490,"is_internal":false,"editable":false,"type":"Activities::BugTriaged","message":"","markdown_message":"","automated_response":false,"created_at":"2019-04-24T06:04:54.851Z","updated_at":"2019-04-24T06:04:54.851Z","actor":{"username":"akituomi","cleared":false,"url":"/akituomi","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/060/216/805d230879c8e3757d37eedddaadf9efed0a8094_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"open-xchange","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":4631517,"is_internal":false,"editable":false,"type":"Activities::BountyAwarded","message":"Awarding $600 per bug.","markdown_message":"\u003cp\u003eAwarding $600 per bug.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-04-24T06:14:23.255Z","updated_at":"2019-04-24T06:14:23.255Z","actor":{"url":"/open-xchange","ibb":false,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/JtYLEsu5yRZxGitSmAjeAFtK/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"Open-Xchange"}},"bounty_amount":"600.0","bounty_currency":"usd","bonus_amount":"0.0","genius_execution_id":null,"team_handle":"open-xchange","collaborator":{"username":"rafiy","url":"/rafiy"},"actor_is_team_member":true,"actor_is_concealed_member":false},{"id":4631518,"is_internal":false,"editable":false,"type":"Activities::BountyAwarded","message":"Awarding $600 per bug.","markdown_message":"\u003cp\u003eAwarding $600 per bug.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-04-24T06:14:23.773Z","updated_at":"2019-04-24T06:14:23.773Z","actor":{"url":"/open-xchange","ibb":false,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/JtYLEsu5yRZxGitSmAjeAFtK/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"Open-Xchange"}},"bounty_amount":"600.0","bounty_currency":"usd","bonus_amount":"0.0","genius_execution_id":null,"team_handle":"open-xchange","collaborator":{"username":"nick_roessler","url":"/nick_roessler"},"actor_is_team_member":true,"actor_is_concealed_member":false},{"id":4632689,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Thanks.","markdown_message":"\u003cp\u003eThanks.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-04-24T08:39:36.699Z","updated_at":"2019-04-24T08:39:36.699Z","actor":{"username":"rafiy","cleared":false,"url":"/rafiy","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"open-xchange","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6707318,"is_internal":false,"editable":false,"type":"Activities::BugResolved","message":"Will be fixed in 2.3.10.","markdown_message":"\u003cp\u003eWill be fixed in 2.3.10.\u003c/p\u003e\n","automated_response":false,"created_at":"2020-01-07T11:45:35.664Z","updated_at":"2020-01-07T11:45:35.664Z","actor":{"username":"akituomi","cleared":false,"url":"/akituomi","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/060/216/805d230879c8e3757d37eedddaadf9efed0a8094_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"reporter":{"username":"nick_roessler","url":"/nick_roessler"},"genius_execution_id":null,"team_handle":"open-xchange","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":6707319,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","markdown_message":"","automated_response":false,"created_at":"2020-01-07T11:46:03.566Z","updated_at":"2020-01-07T11:46:03.566Z","first_to_agree":true,"actor":{"username":"akituomi","cleared":false,"url":"/akituomi","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/060/216/805d230879c8e3757d37eedddaadf9efed0a8094_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"open-xchange","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":6719972,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"Sounds good!","markdown_message":"\u003cp\u003eSounds good!\u003c/p\u003e\n","automated_response":false,"created_at":"2020-01-08T18:23:50.482Z","updated_at":"2020-01-08T18:23:50.482Z","actor":{"username":"nick_roessler","cleared":false,"url":"/nick_roessler","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/577/276/39ba4fb54ca9bc03bb59a9360be99caf8f832882_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"open-xchange","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6719973,"is_internal":false,"editable":false,"type":"Activities::ReportBecamePublic","message":"","markdown_message":"","automated_response":false,"created_at":"2020-01-08T18:23:50.563Z","updated_at":"2020-01-08T18:23:50.563Z","actor":{"username":"nick_roessler","cleared":false,"url":"/nick_roessler","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/577/276/39ba4fb54ca9bc03bb59a9360be99caf8f832882_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"open-xchange","actor_is_team_member":false,"actor_is_concealed_member":false}],"activity_page_count":1,"activity_page_number":1,"summaries":[{"category":"team","can_view?":true,"can_create?":false},{"category":"researcher","can_view?":true,"can_create?":false}]}