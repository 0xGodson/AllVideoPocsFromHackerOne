{"id":43443,"global_id":"Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC80MzQ0Mw==","url":"https://hackerone.com/reports/43443","title":"PyUnicode_FromFormatV crasher","state":"Closed","substate":"resolved","readable_substate":"Resolved","created_at":"2014-12-15T00:00:00.000Z","submitted_at":"2014-12-15T00:00:00.000Z","is_member_of_team?":false,"reporter":{"disabled":false,"username":"guido","url":"/guido","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/002/983/e55b0b2324777fb7efc2de4212fd8d337ca816bd_original.jpg/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a"},"is_me?":false,"cleared":false,"hackerone_triager":false,"hacker_mediation":false},"team":{"id":27,"url":"https://hackerone.com/ibb-python","handle":"ibb-python","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/000/027/c46b79d4c73a7b34d61a717ed19ae719a0b67b2e_original.png/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a","medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/027/c46b79d4c73a7b34d61a717ed19ae719a0b67b2e_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"permissions":[],"submission_state":"open","default_currency":"usd","awards_miles":false,"offers_bounties":true,"state":"public_mode","only_cleared_hackers":false,"profile":{"name":"Python (IBB)","twitter_handle":"","website":"http://www.python.org/news/security","about":""}},"has_bounty?":true,"in_validation?":false,"rejected_anc_report_that_can_be_sent_back_to_anc_triagers?":false,"can_view_team":true,"can_view_report":true,"is_external_bug":false,"is_published":false,"is_participant":false,"stage":4,"public":true,"visibility":"full","cve_ids":[],"singular_disclosure_disabled":false,"disclosed_at":"2014-12-15T00:00:00.000Z","bug_reporter_agreed_on_going_public_at":null,"team_member_agreed_on_going_public_at":"2014-12-15T00:00:00.000Z","comments_closed?":false,"facebook_team?":false,"team_private?":false,"vulnerability_information":"IBB panel,\n\nPlease note: this was initially sent (only) to security@python.org. After a short conversation, Guido van Rossum sent me this:\n\n\u003e I created http://bugs.python.org/issue23055 for this. I don't believe there's much of a security risk in revealing this on the tracker. Someone pleas e review the code and the tests. (Guido, if you can suggest additional tests that would be great.)\n\nMeaning it's public now. Here is the original bug report. Please let me know whether this is eligible under the IBB's Python bounty program.\n\n---------\nDear all,\n\nThere's a bug in Python 2's C API function PyUnicode_FromFormatV() (and indirectly in its wrapper PyUnicode_FromFormat()) in Objects/unicodeobject.c which can lead to overflowing both a stack-based and a heap-based buffer.\n\nThis happens because the code that ought to compute the size of two buffers, fails to execute. This is the size computation routine:\n\n```\n 760     /* step 3: figure out how large a buffer we need */\n 761     for (f = format; *f; f++) {\n 762         if (*f == '%') {\n 763             const char* p = f;\n 764             width = 0;\n 765             while (isdigit((unsigned)*f))\n 766                 width = (width*10) + *f++ - '0';\n 767             while (*++f \u0026\u0026 *f != '%' \u0026\u0026 !isalpha((unsigned)*f))\n```\n\nThe expressions on line 762 and line 765 can never both be true; if *f == '%', isdigit((unsigned)%f) can not evaluate as true. Even if it would execute, there's still code that computes the precision component of the format specifier. Later on, in the loop that actually processes the individual format specifiers, the code is done right:\n\n```\n 917             const char* p = f++;\n 918             int longflag = 0;\n 919             int size_tflag = 0;\n 920             zeropad = (*f == '0');\n 921             /* parse the width.precision part */\n 922             width = 0;\n 923             while (isdigit((unsigned)*f))\n 924                 width = (width*10) + *f++ - '0';\n 925             precision = 0;\n 926             if (*f == '.') {\n 927                 f++;\n 928                 while (isdigit((unsigned)*f))\n 929                     precision = (precision*10) + *f++ - '0';\n 930             }\n```\n\nThe actual, current bug comes down to this: both types of padding parameters (width and precision) in the format specifier are ignored when computing the size of the buffers designated to hold sprintf's output, while in the actual calls to sprintf, these are accounted for.\n\n```\n 947             case 'd':\n 948                 makefmt(fmt, longflag, size_tflag, zeropad, width, precision, 'd');\n 949                 if (longflag)\n 950                     sprintf(realbuffer, fmt, va_arg(vargs, long));\n 951                 else if (size_tflag)\n 952                     sprintf(realbuffer, fmt, va_arg(vargs, Py_ssize_t));\n 953                 else\n 954                     sprintf(realbuffer, fmt, va_arg(vargs, int));\n 955                 appendstring(realbuffer);\n 956                 break;\n 957             case 'u':\n 958                 makefmt(fmt, longflag, size_tflag, zeropad, width, precision, 'u');\n 959                 if (longflag)\n 960                     sprintf(realbuffer, fmt, va_arg(vargs, unsigned long));\n 961                 else if (size_tflag)\n 962                     sprintf(realbuffer, fmt, va_arg(vargs, size_t));\n 963                 else\n 964                     sprintf(realbuffer, fmt, va_arg(vargs, unsigned int));\n 965                 appendstring(realbuffer);\n 966                 break;\n 967             case 'i':\n 968                 makefmt(fmt, 0, 0, zeropad, width, precision, 'i');\n 969                 sprintf(realbuffer, fmt, va_arg(vargs, int));\n 970                 appendstring(realbuffer);\n 971                 break;\n 972             case 'x':\n 973                 makefmt(fmt, 0, 0, zeropad, width, precision, 'x');\n 974                 sprintf(realbuffer, fmt, va_arg(vargs, int));\n 975                 appendstring(realbuffer);\n 976                 break;\n```\n\nmakefmt constructs a format specifier string based on width, precision and other parameters. Subsequently, this format specifier string is supplied to sprintf which will write a padded string to 'realbuffer' as requested. Since realbuffer points to the stack-based 'char buffer[21]', this will cause a stack-based overwrite:\n\n```\n 894     if (abuffersize \u003e 20) {\n 895         abuffer = PyObject_Malloc(abuffersize);\n 896         if (!abuffer) {\n 897             PyErr_NoMemory();\n 898             goto fail;\n 899         }\n 900         realbuffer = abuffer;\n 901     }\n 902     else\n 903         realbuffer = buffer;\n```\n\nThe 'abuffersize \u003e 20' condition can never be true, since 'abuffersize' is defined earlier on as:\n\n```\n 808                 if (width \u003c 20)\n 809                     width = 20;\n 810                 n += width;\n 811                 if (abuffersize \u003c width)\n 812                     abuffersize = width;\n```\n\nwhich will always cause abuffersize to be 20, since width is always 0, since the code that ought to compute 'width' never runs.\n\nAfter the sprintf, which causes the stack-based buffer overflow, there's this:\n\n```\n 955                 appendstring(realbuffer);\n\n 693 #define appendstring(string) \\\n 694     do { \\\n 695         for (copy = string;*copy; copy++) { \\\n 696             *s++ = (unsigned char)*copy; \\\n 697         } \\\n 698     } while (0)\n```\n\n's' is space allocated based on 'n':\n\n```\n 908     string = PyUnicode_FromUnicode(NULL, n);\n 909     if (!string)\n 910         goto fail;\n 911\n 912     s = PyUnicode_AS_UNICODE(string);\n 913     callresult = callresults;\n```\n\nand 'n' never accounts for any width or precision parameters either, so 's' is always too small if width and optionally precision parameters are present. Thus, appendstring(realbuffer); results in a heap-based overflow.\n\nHere's a patch:\n\n```\ndiff -r baa5258bef22 Objects/unicodeobject.c\n--- a/Objects/unicodeobject.c    Sat Dec 13 16:06:19 2014 -0500\n+++ b/Objects/unicodeobject.c    Sun Dec 14 22:14:39 2014 +0100\n@@ -760,12 +760,18 @@\n     /* step 3: figure out how large a buffer we need */\n     for (f = format; *f; f++) {\n         if (*f == '%') {\n-            const char* p = f;\n+            const char* p = f++;\n             width = 0;\n+            precision = 0;\n             while (isdigit((unsigned)*f))\n                 width = (width*10) + *f++ - '0';\n-            while (*++f \u0026\u0026 *f != '%' \u0026\u0026 !isalpha((unsigned)*f))\n-                ;\n+            if (*f == '.') {\n+                f++;\n+                while (isdigit((unsigned)*f))\n+                    precision = (precision*10) + *f++ - '0';\n+            }\n+            while (*f \u0026\u0026 *f != '%' \u0026\u0026 !isalpha((unsigned)*f))\n+                f++;\n```\n \n```\n             /* skip the 'l' or 'z' in {%ld, %zd, %lu, %zu} since\n              * they don't affect the amount of space we reserve.\n@@ -805,11 +811,9 @@\n                    This isn't enough for octal.\n                    If a width is specified we need more\n                    (which we allocate later). */\n-                if (width \u003c 20)\n-                    width = 20;\n-                n += width;\n-                if (abuffersize \u003c width)\n-                    abuffersize = width;\n+                n += (width + precision) \u003c 20 ? 20 : (width + precision);\n+                if (abuffersize \u003c (width + precision) )\n+                    abuffersize = width + precision;\n                 break;\n             case 's':\n             {\n```\n\nAside from general memory corruption errors caused by this bug, there's the additional danger of code execution in instances where a user or entity can control the 'format' parameter of the PyUnicode_FromFormat()/PyUnicode_FromFormatV functions, and of sidetracking audits of code that uses these functions because of the unexpected behavior it can entail.\n","vulnerability_information_html":"\u003cp\u003eIBB panel,\u003c/p\u003e\n\n\u003cp\u003ePlease note: this was initially sent (only) to \u003ca title=\"security@python.org\" href=\"mailto:security@python.org\" rel=\"nofollow noopener noreferrer\"\u003esecurity@python.org\u003c/a\u003e. After a short conversation, Guido van Rossum sent me this:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eI created \u003ca title=\"http://bugs.python.org/issue23055\" href=\"/redirect?url=http%3A%2F%2Fbugs.python.org%2Fissue23055\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttp://bugs.python.org/issue23055\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e for this. I don\u0026#39;t believe there\u0026#39;s much of a security risk in revealing this on the tracker. Someone pleas e review the code and the tests. (Guido, if you can suggest additional tests that would be great.)\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eMeaning it\u0026#39;s public now. Here is the original bug report. Please let me know whether this is eligible under the IBB\u0026#39;s Python bounty program.\u003c/p\u003e\n\n\u003chr\u003e\n\n\u003cp\u003eDear all,\u003c/p\u003e\n\n\u003cp\u003eThere\u0026#39;s a bug in Python 2\u0026#39;s C API function PyUnicode_FromFormatV() (and indirectly in its wrapper PyUnicode_FromFormat()) in Objects/unicodeobject.c which can lead to overflowing both a stack-based and a heap-based buffer.\u003c/p\u003e\n\n\u003cp\u003eThis happens because the code that ought to compute the size of two buffers, fails to execute. This is the size computation routine:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e 760     /* step 3: figure out how large a buffer we need */\n 761     for (f = format; *f; f++) {\n 762         if (*f == \u0026#39;%\u0026#39;) {\n 763             const char* p = f;\n 764             width = 0;\n 765             while (isdigit((unsigned)*f))\n 766                 width = (width*10) + *f++ - \u0026#39;0\u0026#39;;\n 767             while (*++f \u0026amp;\u0026amp; *f != \u0026#39;%\u0026#39; \u0026amp;\u0026amp; !isalpha((unsigned)*f))\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe expressions on line 762 and line 765 can never both be true; if *f == \u0026#39;%\u0026#39;, isdigit((unsigned)%f) can not evaluate as true. Even if it would execute, there\u0026#39;s still code that computes the precision component of the format specifier. Later on, in the loop that actually processes the individual format specifiers, the code is done right:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e 917             const char* p = f++;\n 918             int longflag = 0;\n 919             int size_tflag = 0;\n 920             zeropad = (*f == \u0026#39;0\u0026#39;);\n 921             /* parse the width.precision part */\n 922             width = 0;\n 923             while (isdigit((unsigned)*f))\n 924                 width = (width*10) + *f++ - \u0026#39;0\u0026#39;;\n 925             precision = 0;\n 926             if (*f == \u0026#39;.\u0026#39;) {\n 927                 f++;\n 928                 while (isdigit((unsigned)*f))\n 929                     precision = (precision*10) + *f++ - \u0026#39;0\u0026#39;;\n 930             }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe actual, current bug comes down to this: both types of padding parameters (width and precision) in the format specifier are ignored when computing the size of the buffers designated to hold sprintf\u0026#39;s output, while in the actual calls to sprintf, these are accounted for.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e 947             case \u0026#39;d\u0026#39;:\n 948                 makefmt(fmt, longflag, size_tflag, zeropad, width, precision, \u0026#39;d\u0026#39;);\n 949                 if (longflag)\n 950                     sprintf(realbuffer, fmt, va_arg(vargs, long));\n 951                 else if (size_tflag)\n 952                     sprintf(realbuffer, fmt, va_arg(vargs, Py_ssize_t));\n 953                 else\n 954                     sprintf(realbuffer, fmt, va_arg(vargs, int));\n 955                 appendstring(realbuffer);\n 956                 break;\n 957             case \u0026#39;u\u0026#39;:\n 958                 makefmt(fmt, longflag, size_tflag, zeropad, width, precision, \u0026#39;u\u0026#39;);\n 959                 if (longflag)\n 960                     sprintf(realbuffer, fmt, va_arg(vargs, unsigned long));\n 961                 else if (size_tflag)\n 962                     sprintf(realbuffer, fmt, va_arg(vargs, size_t));\n 963                 else\n 964                     sprintf(realbuffer, fmt, va_arg(vargs, unsigned int));\n 965                 appendstring(realbuffer);\n 966                 break;\n 967             case \u0026#39;i\u0026#39;:\n 968                 makefmt(fmt, 0, 0, zeropad, width, precision, \u0026#39;i\u0026#39;);\n 969                 sprintf(realbuffer, fmt, va_arg(vargs, int));\n 970                 appendstring(realbuffer);\n 971                 break;\n 972             case \u0026#39;x\u0026#39;:\n 973                 makefmt(fmt, 0, 0, zeropad, width, precision, \u0026#39;x\u0026#39;);\n 974                 sprintf(realbuffer, fmt, va_arg(vargs, int));\n 975                 appendstring(realbuffer);\n 976                 break;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003emakefmt constructs a format specifier string based on width, precision and other parameters. Subsequently, this format specifier string is supplied to sprintf which will write a padded string to \u0026#39;realbuffer\u0026#39; as requested. Since realbuffer points to the stack-based \u0026#39;char buffer[21]\u0026#39;, this will cause a stack-based overwrite:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e 894     if (abuffersize \u0026gt; 20) {\n 895         abuffer = PyObject_Malloc(abuffersize);\n 896         if (!abuffer) {\n 897             PyErr_NoMemory();\n 898             goto fail;\n 899         }\n 900         realbuffer = abuffer;\n 901     }\n 902     else\n 903         realbuffer = buffer;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe \u0026#39;abuffersize \u0026gt; 20\u0026#39; condition can never be true, since \u0026#39;abuffersize\u0026#39; is defined earlier on as:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e 808                 if (width \u0026lt; 20)\n 809                     width = 20;\n 810                 n += width;\n 811                 if (abuffersize \u0026lt; width)\n 812                     abuffersize = width;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003ewhich will always cause abuffersize to be 20, since width is always 0, since the code that ought to compute \u0026#39;width\u0026#39; never runs.\u003c/p\u003e\n\n\u003cp\u003eAfter the sprintf, which causes the stack-based buffer overflow, there\u0026#39;s this:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e 955                 appendstring(realbuffer);\n\n 693 #define appendstring(string) \\\n 694     do { \\\n 695         for (copy = string;*copy; copy++) { \\\n 696             *s++ = (unsigned char)*copy; \\\n 697         } \\\n 698     } while (0)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e\u0026#39;s\u0026#39; is space allocated based on \u0026#39;n\u0026#39;:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e 908     string = PyUnicode_FromUnicode(NULL, n);\n 909     if (!string)\n 910         goto fail;\n 911\n 912     s = PyUnicode_AS_UNICODE(string);\n 913     callresult = callresults;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eand \u0026#39;n\u0026#39; never accounts for any width or precision parameters either, so \u0026#39;s\u0026#39; is always too small if width and optionally precision parameters are present. Thus, appendstring(realbuffer); results in a heap-based overflow.\u003c/p\u003e\n\n\u003cp\u003eHere\u0026#39;s a patch:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight diff\"\u003e\u003ccode\u003e\u003cspan class=\"gh\"\u003ediff -r baa5258bef22 Objects/unicodeobject.c\n\u003c/span\u003e\u003cspan class=\"gd\"\u003e--- a/Objects/unicodeobject.c    Sat Dec 13 16:06:19 2014 -0500\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+++ b/Objects/unicodeobject.c    Sun Dec 14 22:14:39 2014 +0100\n\u003c/span\u003e\u003cspan class=\"p\"\u003e@@ -760,12 +760,18 @@\u003c/span\u003e\n     /* step 3: figure out how large a buffer we need */\n     for (f = format; *f; f++) {\n         if (*f == \u0026#39;%\u0026#39;) {\n\u003cspan class=\"gd\"\u003e-            const char* p = f;\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+            const char* p = f++;\n\u003c/span\u003e             width = 0;\n\u003cspan class=\"gi\"\u003e+            precision = 0;\n\u003c/span\u003e             while (isdigit((unsigned)*f))\n                 width = (width*10) + *f++ - \u0026#39;0\u0026#39;;\n\u003cspan class=\"gd\"\u003e-            while (*++f \u0026amp;\u0026amp; *f != \u0026#39;%\u0026#39; \u0026amp;\u0026amp; !isalpha((unsigned)*f))\n-                ;\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+            if (*f == \u0026#39;.\u0026#39;) {\n+                f++;\n+                while (isdigit((unsigned)*f))\n+                    precision = (precision*10) + *f++ - \u0026#39;0\u0026#39;;\n+            }\n+            while (*f \u0026amp;\u0026amp; *f != \u0026#39;%\u0026#39; \u0026amp;\u0026amp; !isalpha((unsigned)*f))\n+                f++;\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e             /* skip the \u0026#39;l\u0026#39; or \u0026#39;z\u0026#39; in {%ld, %zd, %lu, %zu} since\n              * they don\u0026#39;t affect the amount of space we reserve.\n@@ -805,11 +811,9 @@\n                    This isn\u0026#39;t enough for octal.\n                    If a width is specified we need more\n                    (which we allocate later). */\n-                if (width \u0026lt; 20)\n-                    width = 20;\n-                n += width;\n-                if (abuffersize \u0026lt; width)\n-                    abuffersize = width;\n+                n += (width + precision) \u0026lt; 20 ? 20 : (width + precision);\n+                if (abuffersize \u0026lt; (width + precision) )\n+                    abuffersize = width + precision;\n                 break;\n             case \u0026#39;s\u0026#39;:\n             {\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eAside from general memory corruption errors caused by this bug, there\u0026#39;s the additional danger of code execution in instances where a user or entity can control the \u0026#39;format\u0026#39; parameter of the PyUnicode_FromFormat()/PyUnicode_FromFormatV functions, and of sidetracking audits of code that uses these functions because of the unexpected behavior it can entail.\u003c/p\u003e\n","bounty_amount":"1000.0","formatted_bounty":"$1,000","original_report_id":null,"original_report_url":null,"attachments":[],"allow_singular_disclosure_at":null,"vote_count":0,"voters":[],"structured_scope":null,"abilities":{"assignable_team_members":[],"assignable_team_member_groups":[]},"can_edit_custom_fields_attributes":false,"activities":[{"id":308668,"is_internal":false,"editable":false,"type":"Activities::BountyAwarded","message":"","markdown_message":"","automated_response":false,"created_at":"2015-01-12T06:14:46.724Z","updated_at":"2015-01-12T06:14:46.724Z","actor":{"url":"/ibb-python","ibb":true,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/027/c46b79d4c73a7b34d61a717ed19ae719a0b67b2e_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"Python (IBB)"}},"bounty_amount":"1000.0","bounty_currency":"usd","genius_execution_id":null,"team_handle":"ibb-python","collaborator":{"username":"guido","url":"/guido"},"actor_is_team_member":false,"actor_is_concealed_member":false},{"id":1196182,"is_internal":false,"editable":false,"type":"Activities::BugResolved","message":null,"markdown_message":"","automated_response":false,"created_at":"2015-01-12T06:14:46.724Z","updated_at":"2016-09-15T13:29:30.658Z","actor":{"url":"/ibb-python","ibb":true,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/027/c46b79d4c73a7b34d61a717ed19ae719a0b67b2e_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"Python (IBB)"}},"reporter":{"username":"guido","url":"/guido"},"genius_execution_id":null,"team_handle":"ibb-python","actor_is_team_member":false,"actor_is_concealed_member":false}],"activity_page_count":1,"activity_page_number":1,"summaries":[{"category":"team","can_view?":true,"can_create?":false},{"category":"researcher","can_view?":true,"can_create?":false}]}