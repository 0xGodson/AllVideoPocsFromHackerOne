{"id":713321,"global_id":"Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC83MTMzMjE=","url":"https://hackerone.com/reports/713321","title":"Exploiting Network and Timing Side-Channels to Break Monero Receiver Anonymity","state":"Closed","substate":"resolved","severity_rating":"medium","readable_substate":"Resolved","created_at":"2019-10-13T21:29:56.876Z","submitted_at":"2019-10-13T21:29:56.876Z","is_member_of_team?":false,"reporter":{"disabled":false,"username":"ftramer","url":"/ftramer","profile_picture_urls":{"small":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"is_me?":false,"cleared":false,"hackerone_triager":false,"hacker_mediation":false},"team":{"id":7731,"url":"https://hackerone.com/monero","handle":"monero","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/007/731/55634f7fcd917725c7a5771cc6e7c9b4d5fe0c22_original.png/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a","medium":"https://profile-photos.hackerone-user-content.com/variants/000/007/731/55634f7fcd917725c7a5771cc6e7c9b4d5fe0c22_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"permissions":[],"submission_state":"open","default_currency":"usd","awards_miles":false,"offers_bounties":false,"state":"public_mode","only_cleared_hackers":false,"profile":{"name":"Monero","twitter_handle":"monero","website":"https://getmonero.org","about":" Monero: the secure, private, untraceable cryptocurrency"}},"has_bounty?":false,"in_validation?":false,"rejected_anc_report_that_can_be_sent_back_to_anc_triagers?":false,"can_view_team":true,"can_view_report":true,"is_external_bug":false,"is_published":false,"is_participant":false,"stage":4,"public":true,"visibility":"full","cve_ids":[],"singular_disclosure_disabled":false,"disclosed_at":"2019-11-15T14:10:41.726Z","bug_reporter_agreed_on_going_public_at":"2019-11-15T14:10:41.678Z","team_member_agreed_on_going_public_at":"2019-11-15T04:28:03.980Z","comments_closed?":false,"facebook_team?":false,"team_private?":false,"vulnerability_information":"## Summary:\nWe present various examples of side-channel leakage in the communication between a Monero wallet and P2P node. Communication patterns and timing leak whether the wallet is the payee of a transaction that is sent into the transaction pool or mined in a block—thereby breaking transaction privacy, as well as enabling linking of stealth addresses. \nIf a user connects their Monero wallet to a remote node, the required leakage in commu- nication patterns and timing is observable by a malicious (yet passive) remote node provider, or by a passive network adversary that monitors the encrypted traffic between a wallet and a trusted node. Even if the wallet and node are both hosted locally and trusted, side-channel leakage can be observed by an active remote attacker with a P2P connection to the node.\n\n## Releases Affected:\n\n  * Current release (v0.14.1.0) and previous ones of the main Monero node and wallet implementations\n\n## Steps To Reproduce:\n\nThe attached report (which we also sent to ric@getmonero.org and luigi1111@getmonero.org via PGP) explains the different vulnerabilities and how they can be exploited.\n\n## Supporting Material/References:\n[list any additional material (e.g. screenshots, logs, etc.)]\n\n  * Vulnerability disclose report\n\n## Housekeeping\n\n1. Be sure to read our policy before submitting\n2. Provide an XMR address within the report if you wish to receive bounty (assuming that the report is valid)\n    - PoC within a report will most likely result in more bounty than not\n\nXMR  address: 45jPGGu9QPYSoNgZPuVpbaMcvrKEJ8TGMd4bPc9VVFKWKqmmfUuzEHDi6sremu2H2idVgySvCmam48RvhKCPRDtBTPj2be3\n\n## Impact\n\nA remote attacker (either in control of a public node, or a network adversary monitoring communication to a remote node, or even a remote P2P participant connected to a wallet's local node) can infer when the wallet is the payee of a transaction added to the mempool or mined in a block.","vulnerability_information_html":"\u003ch2 id=\"summary\"\u003eSummary:\u003c/h2\u003e\n\n\u003cp\u003eWe present various examples of side-channel leakage in the communication between a Monero wallet and P2P node. Communication patterns and timing leak whether the wallet is the payee of a transaction that is sent into the transaction pool or mined in a block—thereby breaking transaction privacy, as well as enabling linking of stealth addresses. \u003cbr\u003e\nIf a user connects their Monero wallet to a remote node, the required leakage in commu- nication patterns and timing is observable by a malicious (yet passive) remote node provider, or by a passive network adversary that monitors the encrypted traffic between a wallet and a trusted node. Even if the wallet and node are both hosted locally and trusted, side-channel leakage can be observed by an active remote attacker with a P2P connection to the node.\u003c/p\u003e\n\n\u003ch2 id=\"releases-affected\"\u003eReleases Affected:\u003c/h2\u003e\n\n\u003cul\u003e\n\u003cli\u003eCurrent release (v0.14.1.0) and previous ones of the main Monero node and wallet implementations\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"steps-to-reproduce\"\u003eSteps To Reproduce:\u003c/h2\u003e\n\n\u003cp\u003eThe attached report (which we also sent to \u003ca title=\"ric@getmonero.org\" href=\"mailto:ric@getmonero.org\" rel=\"nofollow noopener noreferrer\"\u003eric@getmonero.org\u003c/a\u003e and \u003ca title=\"luigi1111@getmonero.org\" href=\"mailto:luigi1111@getmonero.org\" rel=\"nofollow noopener noreferrer\"\u003eluigi1111@getmonero.org\u003c/a\u003e via PGP) explains the different vulnerabilities and how they can be exploited.\u003c/p\u003e\n\n\u003ch2 id=\"supporting-material-references\"\u003eSupporting Material/References:\u003c/h2\u003e\n\n\u003cp\u003e[list any additional material (e.g. screenshots, logs, etc.)]\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eVulnerability disclose report\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"housekeeping\"\u003eHousekeeping\u003c/h2\u003e\n\n\u003col\u003e\n\u003cli\u003eBe sure to read our policy before submitting\u003c/li\u003e\n\u003cli\u003eProvide an XMR address within the report if you wish to receive bounty (assuming that the report is valid)\n\n\u003cul\u003e\n\u003cli\u003ePoC within a report will most likely result in more bounty than not\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eXMR  address: 45jPGGu9QPYSoNgZPuVpbaMcvrKEJ8TGMd4bPc9VVFKWKqmmfUuzEHDi6sremu2H2idVgySvCmam48RvhKCPRDtBTPj2be3\u003c/p\u003e\n\n\u003ch2 id=\"impact\"\u003eImpact\u003c/h2\u003e\n\n\u003cp\u003eA remote attacker (either in control of a public node, or a network adversary monitoring communication to a remote node, or even a remote P2P participant connected to a wallet\u0026#39;s local node) can infer when the wallet is the payee of a transaction added to the mempool or mined in a block.\u003c/p\u003e\n","original_report_id":null,"original_report_url":null,"attachments":[{"id":606755,"file_name":"main.pdf","expiring_url":"https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/zuuHPUi1yycfG7DbrDtaRZXB?response-content-disposition=attachment%3B%20filename%3D%22main.pdf%22%3B%20filename%2A%3DUTF-8%27%27main.pdf\u0026response-content-type=application%2Fpdf\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\u0026X-Amz-Credential=ASIAQGK6FURQWPKTSU4A%2F20201229%2Fus-west-2%2Fs3%2Faws4_request\u0026X-Amz-Date=20201229T064108Z\u0026X-Amz-Expires=3600\u0026X-Amz-SignedHeaders=host\u0026X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJ7%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCICR3Wbqr3QmaXXF3DerXHfL2hl5mL6uGPxa9bL7HxbeqAiEAqWiWv4fNm1cBuTJbNOPDhjMWyvgVYBMfeqSvL3C%2Br5kqtAMIVhABGgwwMTM2MTkyNzQ4NDkiDLWeuL88FcgTd%2BHDFiqRA7sDjduiUr7yrR1bP0fy3jpTtTXARM3Gr8rkIOStwiuzOpvS67rApjBlyTcg901MzVj81BMqg2D%2FoYR3%2FSoNuwT33h6KUwD255ES%2FPaggNJ05ASpUwzUlVyePLw4P7in3wPJpZgw9N8dZGDgg6RxPAgdRMTCMAdlbL23s9IEA0HQY%2FGrR4AsNah2Xjle%2Beki0NqkG2PIPu3eRj3%2BQqZznd3OfS%2F2sVbcGOtcKdRNfVO%2Bms3UlWm2aPpwFiBKtt5yY1oKJr%2BgD%2BF%2FSQXzNSV67TxIzKIjNEaMGEHoDWRX0O4KOc6rsER7d7YcxMm3LHCy5VXT6QRFyFg%2FG4p8jairmeusKiaAs0jSa4nN2Zw3%2BCVW97Ila6RUU7muvv0d6W%2FYI6MJm443s6INDwS%2F0HX%2Bw8e4TOsebeohnSpFhM2ci9Q8tz6Q72ZmyHoSODXtdcyWxmKZOiWjWtpBmasfdIsQkZzxOUEp9TeB9Eaq72Q8%2BcHbJ%2Fn4cBcE%2FhCkABtaY7%2BW80JUqsSXPlI8vt2z0j%2B7EAZZMJT4qv8FOusB53xj88px4LwwmmUwc4%2B73P1hcJQ5adArgpVyBc%2Fvo2mvPbSXp8aV8B1%2BrfMDWuQn5Unmirx7fguBekXWHMyBRZ5m12xEhEj3mDnu3koQSeJRnoNQdEu1tOplrrLMENBFS6mTQ%2BUUBq1sggQqNoyyQNPVrpOTENkW7e%2FKnl%2FHjjMD5ktvCe3RQAaSXnShU%2FFfKQH%2FQlegKj92VkKfFBzGzGJ0gmEIyc6Fl56gBo43TML6rbL9j9QyU%2FpQpXJOVD4OV4s4%2BALvzzN5PLj4E9A%2Bwmv%2FwIgM8BdxFsm0wGfnWsssx3X6cDoUNw7ldQ%3D%3D\u0026X-Amz-Signature=e39ea28e3530dfba1004f37e9421c9fea540e6e4b5b378fdebf28c532bc7638e","file_size":280807,"type":"application/pdf"}],"allow_singular_disclosure_at":"2019-12-15T04:28:04.070Z","allow_singular_disclosure_after":-32839984.595013823,"singular_disclosure_allowed":true,"vote_count":15,"voters":["mashoud1122","itsunixiknowthis","0-1","zayn1337","nessun00x","d3adl0ck","chivopunk","qwertz82","shkhan922","perror","and 5 more..."],"severity":{"rating":"medium","score":6.8,"author_type":"User","metrics":{"attack_vector":"network","attack_complexity":"high","privileges_required":"none","user_interaction":"none","scope":"changed","confidentiality":"high","integrity":"none","availability":"none"}},"structured_scope":null,"abilities":{"assignable_team_members":[],"assignable_team_member_groups":[]},"can_edit_custom_fields_attributes":false,"activities":[{"id":6038534,"is_internal":false,"editable":false,"type":"Activities::BugTriaged","message":"Thank you very much for the well-written report. Please allow us some time to discuss and resolve the issue.","markdown_message":"\u003cp\u003eThank you very much for the well-written report. Please allow us some time to discuss and resolve the issue.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-10-14T22:02:21.467Z","updated_at":"2019-10-14T22:02:21.467Z","actor":{"username":"anonimal","cleared":false,"url":"/anonimal","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/040/857/f23cc3be09a21e17bc43975987c10ba2b6427239_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6048825,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Thanks for the report.\nThe following patches seem to plug the leaks you identified. It might be good to \"standardize\" the refresh rates so the wallet type cannot be fingerprinted, I've not done that here. I'll do more testing tomorrow to see if anything else is still leaking timing. In particular, the random sleep time before checking the once_a_time timeout might be not quite enough to mask the delay. There's also still get_info calls upon a prompt being displayed, after the 30 seconds of cache time. That might need changing as well, not sure whether the cache time should have a random component as well.\n\n```\ncommit 3c47170dd3512411d94fe22ef5107186491ba63d (HEAD -\u003e crash)\nAuthor: moneromooo-monero \u003cmoneromooo-monero@users.noreply.github.com\u003e\nDate:   Tue Oct 15 19:16:13 2019 +0000\n\n    wallet: reuse cached height when set after refresh\n    \n    Refreshing sets cached height, which is otherwise got by calling\n    get_info. Since get_info is called upon needing to display a prompt\n    after a command has finished, it can be used to determine how much\n    time a given command took to run if the cache timeout lapses while\n    the command runs. Refreshing caches the height as a side effect, so\n    get_info will never be called as a result of displaying a prompt\n    after refreshing (and potentially leaking how much time it took to\n    process a set of transactions, therefore leaking whether we got\n    some monero in them).\n\ndiff --git a/src/wallet/node_rpc_proxy.cpp b/src/wallet/node_rpc_proxy.cpp\nindex 1d5078a11..ea47d35da 100644\n--- a/src/wallet/node_rpc_proxy.cpp\n+++ b/src/wallet/node_rpc_proxy.cpp\n@@ -58,6 +58,7 @@ void NodeRPCProxy::invalidate()\n   m_target_height = 0;\n   m_block_weight_limit = 0;\n   m_get_info_time = 0;\n+  m_height_time = 0;\n }\n \n boost::optional\u003cstd::string\u003e NodeRPCProxy::get_rpc_version(uint32_t \u0026rpc_version) const\n@@ -83,6 +84,7 @@ boost::optional\u003cstd::string\u003e NodeRPCProxy::get_rpc_version(uint32_t \u0026rpc_version\n void NodeRPCProxy::set_height(uint64_t h)\n {\n   m_height = h;\n+  m_height_time = time(NULL);\n }\n \n boost::optional\u003cstd::string\u003e NodeRPCProxy::get_info() const\n@@ -106,12 +108,20 @@ boost::optional\u003cstd::string\u003e NodeRPCProxy::get_info() const\n     m_target_height = resp_t.target_height;\n     m_block_weight_limit = resp_t.block_weight_limit ? resp_t.block_weight_limit : resp_t.block_size_limit;\n     m_get_info_time = now;\n+    m_height_time = now;\n   }\n   return boost::optional\u003cstd::string\u003e();\n }\n \n boost::optional\u003cstd::string\u003e NodeRPCProxy::get_height(uint64_t \u0026height) const\n {\n+  const time_t now = time(NULL);\n+  if (now \u003c m_height_time + 30) // re-cache every 30 seconds\n+  {\n+    height = m_height;\n+    return boost::optional\u003cstd::string\u003e();\n+  }\n+\n   auto res = get_info();\n   if (res)\n     return res;\ndiff --git a/src/wallet/node_rpc_proxy.h b/src/wallet/node_rpc_proxy.h\nindex 3b75c8b94..19b5c3f53 100644\n--- a/src/wallet/node_rpc_proxy.h\n+++ b/src/wallet/node_rpc_proxy.h\n@@ -70,6 +70,7 @@ private:\n   mutable uint64_t m_target_height;\n   mutable uint64_t m_block_weight_limit;\n   mutable time_t m_get_info_time;\n+  mutable time_t m_height_time;\n };\n \n }\n\ncommit 046e6ff727e1ac705a1b34081d49d40f74772d9c\nAuthor: moneromooo-monero \u003cmoneromooo-monero@users.noreply.github.com\u003e\nDate:   Tue Oct 15 18:35:11 2019 +0000\n\n    wallet2: fix is_synced checking target height, not height\n    \n    Target height would be appropriate for the daemon, which syncs\n    off other daemons, but the wallet syncs off the daemon it's\n    connected to, and its target is the daemon's current height.\n\ndiff --git a/src/wallet/wallet2.cpp b/src/wallet/wallet2.cpp\nindex 0982aaa19..d78b1473a 100644\n--- a/src/wallet/wallet2.cpp\n+++ b/src/wallet/wallet2.cpp\n@@ -13200,7 +13200,7 @@ uint64_t wallet2::get_blockchain_height_by_date(uint16_t year, uint8_t month, ui\n bool wallet2::is_synced() const\n {\n   uint64_t height;\n-  boost::optional\u003cstd::string\u003e result = m_node_rpc_proxy.get_target_height(height);\n+  boost::optional\u003cstd::string\u003e result = m_node_rpc_proxy.get_height(height);\n   if (result \u0026\u0026 *result != CORE_RPC_STATUS_OK)\n     return false;\n   return get_blockchain_current_height() \u003e= height;\n\ncommit f5b39fb80c04612effae62286855a177a79ed518\nAuthor: moneromooo-monero \u003cmoneromooo-monero@users.noreply.github.com\u003e\nDate:   Tue Oct 15 18:10:29 2019 +0000\n\n    wallet: fix another fact of \"did I get some monero\" information leak\n    \n    We get new pool txes before processing any tx, pool or not.\n    This ensures that if we're asked for a password, this does not\n    cause a measurable delay in the txpool query after the last\n    block query.\n\ndiff --git a/src/simplewallet/simplewallet.cpp b/src/simplewallet/simplewallet.cpp\nindex 2ebecb07d..0518e5231 100644\n--- a/src/simplewallet/simplewallet.cpp\n+++ b/src/simplewallet/simplewallet.cpp\n@@ -8177,7 +8177,11 @@ bool simple_wallet::get_transfers(std::vector\u003cstd::string\u003e\u0026 local_args, std::vec\n       m_in_manual_refresh.store(true, std::memory_order_relaxed);\n       epee::misc_utils::auto_scope_leave_caller scope_exit_handler = epee::misc_utils::create_scope_leave_handler([\u0026](){m_in_manual_refresh.store(false, std::memory_order_relaxed);});\n \n-      m_wallet-\u003eupdate_pool_state();\n+      std::vector\u003cstd::pair\u003ccryptonote::transaction, bool\u003e\u003e process_txs;\n+      m_wallet-\u003eupdate_pool_state(process_txs);\n+      if (!process_txs.empty())\n+        m_wallet-\u003eprocess_pool_state(process_txs);\n+\n       std::list\u003cstd::pair\u003ccrypto::hash, tools::wallet2::pool_payment_details\u003e\u003e payments;\n       m_wallet-\u003eget_unconfirmed_payments(payments, m_current_subaddress_account, subaddr_indices);\n       for (std::list\u003cstd::pair\u003ccrypto::hash, tools::wallet2::pool_payment_details\u003e\u003e::const_iterator i = payments.begin(); i != payments.end(); ++i) {\n@@ -9750,7 +9754,11 @@ bool simple_wallet::show_transfer(const std::vector\u003cstd::string\u003e \u0026args)\n \n   try\n   {\n-    m_wallet-\u003eupdate_pool_state();\n+    std::vector\u003cstd::pair\u003ccryptonote::transaction, bool\u003e\u003e process_txs;\n+    m_wallet-\u003eupdate_pool_state(process_txs);\n+    if (!process_txs.empty())\n+      m_wallet-\u003eprocess_pool_state(process_txs);\n+\n     std::list\u003cstd::pair\u003ccrypto::hash, tools::wallet2::pool_payment_details\u003e\u003e pool_payments;\n     m_wallet-\u003eget_unconfirmed_payments(pool_payments, m_current_subaddress_account);\n     for (std::list\u003cstd::pair\u003ccrypto::hash, tools::wallet2::pool_payment_details\u003e\u003e::const_iterator i = pool_payments.begin(); i != pool_payments.end(); ++i) {\ndiff --git a/src/wallet/wallet2.cpp b/src/wallet/wallet2.cpp\nindex caa76a5f9..0982aaa19 100644\n--- a/src/wallet/wallet2.cpp\n+++ b/src/wallet/wallet2.cpp\n@@ -2825,7 +2825,7 @@ void wallet2::remove_obsolete_pool_txs(const std::vector\u003ccrypto::hash\u003e \u0026tx_hashe\n }\n \n //----------------------------------------------------------------------------------------------------\n-void wallet2::update_pool_state(bool refreshed)\n+void wallet2::update_pool_state(std::vector\u003cstd::pair\u003ccryptonote::transaction, bool\u003e\u003e \u0026process_txs, bool refreshed)\n {\n   MTRACE(\"update_pool_state start\");\n \n@@ -3004,13 +3004,7 @@ void wallet2::update_pool_state(bool refreshed)\n                     [tx_hash](const std::pair\u003ccrypto::hash, bool\u003e \u0026e) { return e.first == tx_hash; });\n                 if (i != txids.end())\n                 {\n-                  process_new_transaction(tx_hash, tx, std::vector\u003cuint64_t\u003e(), 0, 0, time(NULL), false, true, tx_entry.double_spend_seen, {});\n-                  m_scanned_pool_txs[0].insert(tx_hash);\n-                  if (m_scanned_pool_txs[0].size() \u003e 5000)\n-                  {\n-                    std::swap(m_scanned_pool_txs[0], m_scanned_pool_txs[1]);\n-                    m_scanned_pool_txs[0].clear();\n-                  }\n+                  process_txs.push_back(std::make_pair(tx, tx_entry.double_spend_seen));\n                 }\n                 else\n                 {\n@@ -3041,6 +3035,24 @@ void wallet2::update_pool_state(bool refreshed)\n   MTRACE(\"update_pool_state end\");\n }\n //----------------------------------------------------------------------------------------------------\n+void wallet2::process_pool_state(const std::vector\u003cstd::pair\u003ccryptonote::transaction, bool\u003e\u003e \u0026txs)\n+{\n+  const time_t now = time(NULL);\n+  for (const auto \u0026e: txs)\n+  {\n+    const cryptonote::transaction \u0026tx = e.first;\n+    const bool double_spend_seen = e.second;\n+    const crypto::hash tx_hash = get_transaction_hash(tx);\n+    process_new_transaction(tx_hash, tx, std::vector\u003cuint64_t\u003e(), 0, 0, now, false, true, double_spend_seen, {});\n+    m_scanned_pool_txs[0].insert(tx_hash);\n+    if (m_scanned_pool_txs[0].size() \u003e 5000)\n+    {\n+      std::swap(m_scanned_pool_txs[0], m_scanned_pool_txs[1]);\n+      m_scanned_pool_txs[0].clear();\n+    }\n+  }\n+}\n+//----------------------------------------------------------------------------------------------------\n void wallet2::fast_refresh(uint64_t stop_height, uint64_t \u0026blocks_start_height, std::list\u003ccrypto::hash\u003e \u0026short_chain_history, bool force)\n {\n   std::vector\u003ccrypto::hash\u003e hashes;\n@@ -3244,6 +3256,14 @@ void wallet2::refresh(bool trusted_daemon, uint64_t start_height, uint64_t \u0026 blo\n   });\n \n   auto scope_exit_handler_hwdev = epee::misc_utils::create_scope_leave_handler([\u0026](){hwdev.computing_key_images(false);});\n+\n+  // get updated pool state first, but do not process those txes just yet,\n+  // since that might cause a password prompt, which would introduce a data\n+  // leak allowing a passive adversary with traffic analysis capability to\n+  // infer when we get an incoming output\n+  std::vector\u003cstd::pair\u003ccryptonote::transaction, bool\u003e\u003e process_pool_txs;\n+  update_pool_state(process_pool_txs, refreshed);\n+\n   bool first = true, last = false;\n   while(m_run.load(std::memory_order_relaxed))\n   {\n@@ -3362,8 +3382,8 @@ void wallet2::refresh(bool trusted_daemon, uint64_t start_height, uint64_t \u0026 blo\n   try\n   {\n     // If stop() is called we don't need to check pending transactions\n-    if (check_pool \u0026\u0026 m_run.load(std::memory_order_relaxed))\n-      update_pool_state(refreshed);\n+    if (check_pool \u0026\u0026 m_run.load(std::memory_order_relaxed) \u0026\u0026 !process_pool_txs.empty())\n+      process_pool_state(process_pool_txs);\n   }\n   catch (...)\n   {\ndiff --git a/src/wallet/wallet2.h b/src/wallet/wallet2.h\nindex 94d67f622..5a4d4240c 100644\n--- a/src/wallet/wallet2.h\n+++ b/src/wallet/wallet2.h\n@@ -1213,7 +1213,8 @@ private:\n     bool import_key_images(signed_tx_set \u0026 signed_tx, size_t offset=0, bool only_selected_transfers=false);\n     crypto::public_key get_tx_pub_key_from_received_outs(const tools::wallet2::transfer_details \u0026td) const;\n \n-    void update_pool_state(bool refreshed = false);\n+    void update_pool_state(std::vector\u003cstd::pair\u003ccryptonote::transaction, bool\u003e\u003e \u0026process_txs, bool refreshed = false);\n+    void process_pool_state(const std::vector\u003cstd::pair\u003ccryptonote::transaction, bool\u003e\u003e \u0026txs);\n     void remove_obsolete_pool_txs(const std::vector\u003ccrypto::hash\u003e \u0026tx_hashes);\n \n     std::string encrypt(const char *plaintext, size_t len, const crypto::secret_key \u0026skey, bool authenticated = true) const;\ndiff --git a/src/wallet/wallet_rpc_server.cpp b/src/wallet/wallet_rpc_server.cpp\nindex bd79ee981..04f751354 100644\n--- a/src/wallet/wallet_rpc_server.cpp\n+++ b/src/wallet/wallet_rpc_server.cpp\n@@ -2452,7 +2452,10 @@ namespace tools\n \n     if (req.pool)\n     {\n-      m_wallet-\u003eupdate_pool_state();\n+      std::vector\u003cstd::pair\u003ccryptonote::transaction, bool\u003e\u003e process_txs;\n+      m_wallet-\u003eupdate_pool_state(process_txs);\n+      if (!process_txs.empty())\n+        m_wallet-\u003eprocess_pool_state(process_txs);\n \n       std::list\u003cstd::pair\u003ccrypto::hash, tools::wallet2::pool_payment_details\u003e\u003e payments;\n       m_wallet-\u003eget_unconfirmed_payments(payments, account_index, subaddr_indices);\n@@ -2532,7 +2535,10 @@ namespace tools\n       }\n     }\n \n-    m_wallet-\u003eupdate_pool_state();\n+    std::vector\u003cstd::pair\u003ccryptonote::transaction, bool\u003e\u003e process_txs;\n+    m_wallet-\u003eupdate_pool_state(process_txs);\n+    if (!process_txs.empty())\n+      m_wallet-\u003eprocess_pool_state(process_txs);\n \n     std::list\u003cstd::pair\u003ccrypto::hash, tools::wallet2::pool_payment_details\u003e\u003e pool_payments;\n     m_wallet-\u003eget_unconfirmed_payments(pool_payments, req.account_index);\n\ncommit dc8b8dc9b85e66436ad3a3d4a800d7dce354e8c7\nAuthor: moneromooo-monero \u003cmoneromooo-monero@users.noreply.github.com\u003e\nDate:   Tue Oct 15 12:25:26 2019 +0000\n\n    wallet2: do not send an unnecessary last getblocks.bin call on refresh\n    \n    The \"everything refreshed\" state was detected when a refresh call did\n    not return any new blocks. This can be detected without that extra\n    \"empty\" call by comparing the claimed node height to the height of\n    the last block retrieved. Doing this avoids that last call, saves\n    some bandwidth, and makes the common refresh case use only one call\n    rather than two.\n    \n    As a side effect, it prevents an information leak reported by\n    Tramèr et al: if the wallet retrieves a set of blocks which includes\n    an output sent to the refreshing wallet, the wallet will prompt the\n    user for the password to decode the amount and calculate the key\n    image for the new output, and this will delay subsequent calls to\n    getblocks.bin, allowing a passive adversary to note the delay and\n    deduce when the wallet receives at least one output.\n    \n    This can still happen if the wallet downloads more than 1000 blocks,\n    since this will be split in several calls, but then the most the\n    adversary can tell is which 1000 block section the user received\n    some monero (the adversary can estimate the heights of the blocks\n    by calculating how many \"large\" transfers are done, which will be\n    sections of blocks, the last of which will usually be below 1000,\n    but the size of the data should allow the actual number of blocks\n    sent to be determined fairly accurately).\n    \n    This timing trick still be used via the subsequent scan for incoming\n    txes in the txpool, which will be fixed later.\n\ndiff --git a/src/wallet/wallet2.cpp b/src/wallet/wallet2.cpp\nindex c136ff6d8..caa76a5f9 100644\n--- a/src/wallet/wallet2.cpp\n+++ b/src/wallet/wallet2.cpp\n@@ -2531,6 +2531,8 @@ void wallet2::pull_blocks(uint64_t start_height, uint64_t \u0026blocks_start_height,\n   cryptonote::COMMAND_RPC_GET_BLOCKS_FAST::response res = AUTO_VAL_INIT(res);\n   req.block_ids = short_chain_history;\n \n+  MDEBUG(\"Pulling blocks: start_height \" \u003c\u003c start_height);\n+\n   req.prune = true;\n   req.start_height = start_height;\n   req.no_miner_tx = m_refresh_type == RefreshNoCoinbase;\n@@ -2547,6 +2549,9 @@ void wallet2::pull_blocks(uint64_t start_height, uint64_t \u0026blocks_start_height,\n   blocks_start_height = res.start_height;\n   blocks = std::move(res.blocks);\n   o_indices = std::move(res.output_indices);\n+\n+  MDEBUG(\"Pulled blocks: blocks_start_height \" \u003c\u003c blocks_start_height \u003c\u003c \", count \" \u003c\u003c blocks.size()\n+      \u003c\u003c \", height \" \u003c\u003c blocks_start_height + blocks.size() \u003c\u003c \", node height \" \u003c\u003c res.current_height);\n }\n //----------------------------------------------------------------------------------------------------\n void wallet2::pull_hashes(uint64_t start_height, uint64_t \u0026blocks_start_height, const std::list\u003ccrypto::hash\u003e \u0026short_chain_history, std::vector\u003ccrypto::hash\u003e \u0026hashes)\n@@ -2726,9 +2731,10 @@ void wallet2::refresh(bool trusted_daemon, uint64_t start_height, uint64_t \u0026 blo\n   refresh(trusted_daemon, start_height, blocks_fetched, received_money);\n }\n //----------------------------------------------------------------------------------------------------\n-void wallet2::pull_and_parse_next_blocks(uint64_t start_height, uint64_t \u0026blocks_start_height, std::list\u003ccrypto::hash\u003e \u0026short_chain_history, const std::vector\u003ccryptonote::block_complete_entry\u003e \u0026prev_blocks, const std::vector\u003cparsed_block\u003e \u0026prev_parsed_blocks, std::vector\u003ccryptonote::block_complete_entry\u003e \u0026blocks, std::vector\u003cparsed_block\u003e \u0026parsed_blocks, bool \u0026error)\n+void wallet2::pull_and_parse_next_blocks(uint64_t start_height, uint64_t \u0026blocks_start_height, std::list\u003ccrypto::hash\u003e \u0026short_chain_history, const std::vector\u003ccryptonote::block_complete_entry\u003e \u0026prev_blocks, const std::vector\u003cparsed_block\u003e \u0026prev_parsed_blocks, std::vector\u003ccryptonote::block_complete_entry\u003e \u0026blocks, std::vector\u003cparsed_block\u003e \u0026parsed_blocks, bool \u0026last, bool \u0026error)\n {\n   error = false;\n+  last = false;\n \n   try\n   {\n@@ -2783,6 +2789,7 @@ void wallet2::pull_and_parse_next_blocks(uint64_t start_height, uint64_t \u0026blocks\n       }\n     }\n     waiter.wait(\u0026tpool);\n+    last = !blocks.empty() \u0026\u0026 cryptonote::get_block_height(parsed_blocks.back().block) + 1 == blocks_start_height + parsed_blocks.size();\n   }\n   catch(...)\n   {\n@@ -3237,7 +3244,7 @@ void wallet2::refresh(bool trusted_daemon, uint64_t start_height, uint64_t \u0026 blo\n   });\n \n   auto scope_exit_handler_hwdev = epee::misc_utils::create_scope_leave_handler([\u0026](){hwdev.computing_key_images(false);});\n-  bool first = true;\n+  bool first = true, last = false;\n   while(m_run.load(std::memory_order_relaxed))\n   {\n     uint64_t next_blocks_start_height;\n@@ -3256,7 +3263,8 @@ void wallet2::refresh(bool trusted_daemon, uint64_t start_height, uint64_t \u0026 blo\n         refreshed = false;\n         break;\n       }\n-      tpool.submit(\u0026waiter, [\u0026]{pull_and_parse_next_blocks(start_height, next_blocks_start_height, short_chain_history, blocks, parsed_blocks, next_blocks, next_parsed_blocks, error);});\n+      if (!last)\n+        tpool.submit(\u0026waiter, [\u0026]{pull_and_parse_next_blocks(start_height, next_blocks_start_height, short_chain_history, blocks, parsed_blocks, next_blocks, next_parsed_blocks, last, error);});\n \n       if (!first)\n       {\ndiff --git a/src/wallet/wallet2.h b/src/wallet/wallet2.h\nindex b4a0ddf04..94d67f622 100644\n--- a/src/wallet/wallet2.h\n+++ b/src/wallet/wallet2.h\n@@ -1387,7 +1387,7 @@ private:\n     void pull_blocks(uint64_t start_height, uint64_t\u0026 blocks_start_height, const std::list\u003ccrypto::hash\u003e \u0026short_chain_history, std::vector\u003ccryptonote::block_complete_entry\u003e \u0026blocks, std::vector\u003ccryptonote::COMMAND_RPC_GET_BLOCKS_FAST::block_output_indices\u003e \u0026o_indices);\n     void pull_hashes(uint64_t start_height, uint64_t\u0026 blocks_start_height, const std::list\u003ccrypto::hash\u003e \u0026short_chain_history, std::vector\u003ccrypto::hash\u003e \u0026hashes);\n     void fast_refresh(uint64_t stop_height, uint64_t \u0026blocks_start_height, std::list\u003ccrypto::hash\u003e \u0026short_chain_history, bool force = false);\n-    void pull_and_parse_next_blocks(uint64_t start_height, uint64_t \u0026blocks_start_height, std::list\u003ccrypto::hash\u003e \u0026short_chain_history, const std::vector\u003ccryptonote::block_complete_entry\u003e \u0026prev_blocks, const std::vector\u003cparsed_block\u003e \u0026prev_parsed_blocks, std::vector\u003ccryptonote::block_complete_entry\u003e \u0026blocks, std::vector\u003cparsed_block\u003e \u0026parsed_blocks, bool \u0026error);\n+    void pull_and_parse_next_blocks(uint64_t start_height, uint64_t \u0026blocks_start_height, std::list\u003ccrypto::hash\u003e \u0026short_chain_history, const std::vector\u003ccryptonote::block_complete_entry\u003e \u0026prev_blocks, const std::vector\u003cparsed_block\u003e \u0026prev_parsed_blocks, std::vector\u003ccryptonote::block_complete_entry\u003e \u0026blocks, std::vector\u003cparsed_block\u003e \u0026parsed_blocks, bool \u0026last, bool \u0026error);\n     void process_parsed_blocks(uint64_t start_height, const std::vector\u003ccryptonote::block_complete_entry\u003e \u0026blocks, const std::vector\u003cparsed_block\u003e \u0026parsed_blocks, uint64_t\u0026 blocks_added, std::map\u003cstd::pair\u003cuint64_t, uint64_t\u003e, size_t\u003e *output_tracker_cache = NULL);\n     uint64_t select_transfers(uint64_t needed_money, std::vector\u003csize_t\u003e unused_transfers_indices, std::vector\u003csize_t\u003e\u0026 selected_transfers) const;\n     bool prepare_file_names(const std::string\u0026 file_path);\n\ncommit 6413d601606a9642fa8b60c00823364abb7ffc83\nAuthor: moneromooo-monero \u003cmoneromooo-monero@users.noreply.github.com\u003e\nDate:   Tue Oct 15 10:30:50 2019 +0000\n\n    simplewallet: make the idle thread wait times random\n    \n    This prevents direct mapping from time between calls to refresh\n    functions to \"how much time did it take to run a refresh function\",\n    at least modulo one second.\n    The once_a_time class will trigger when its time is up, but it needs\n    to be called often enough to have a chance to trigger close to the\n    ideal trigger time. The current code was calling every T, with T\n    being one second plus whatever time it took to execute the previous\n    idle functions, if any, so typically either 1 second or 1 second\n    plus dt, so this dt becomes observable on the network once an integer\n    number of seconds is subtracted from the delay between two calls to\n    get_blocks.bin.\n    \n    This should help decrease timing side channels found by Tramèr et al.\n\ndiff --git a/src/simplewallet/simplewallet.cpp b/src/simplewallet/simplewallet.cpp\nindex 1a218c6f9..2ebecb07d 100644\n--- a/src/simplewallet/simplewallet.cpp\n+++ b/src/simplewallet/simplewallet.cpp\n@@ -8638,7 +8638,7 @@ void simple_wallet::wallet_idle_thread()\n \n     if (!m_idle_run.load(std::memory_order_relaxed))\n       break;\n-    m_idle_cond.wait_for(lock, boost::chrono::seconds(1));\n+    m_idle_cond.wait_for(lock, boost::chrono::milliseconds(crypto::rand_range\u003cuint32_t\u003e(200, 2000)));\n   }\n }\n //----------------------------------------------------------------------------------------------------\n\ncommit 1fc674ebf1e4ead7f2934d1eca830a136565803b\nAuthor: moneromooo-monero \u003cmoneromooo-monero@users.noreply.github.com\u003e\nDate:   Tue Oct 15 09:12:24 2019 +0000\n\n    wallet2: do not repeatedly ask for pool txes sent to us\n    \n    This lets a passive attacker with access to the network link\n    between node and wallet perform traffic analysis to deduce\n    when an idle wallet receives a transaction.\n    \n    Reported by Tramèr et al.\n\ndiff --git a/src/wallet/wallet2.cpp b/src/wallet/wallet2.cpp\nindex 3314e9297..c136ff6d8 100644\n--- a/src/wallet/wallet2.cpp\n+++ b/src/wallet/wallet2.cpp\n@@ -2963,11 +2963,6 @@ void wallet2::update_pool_state(bool refreshed)\n         LOG_PRINT_L1(\"We sent that one\");\n       }\n     }\n-    else\n-    {\n-      LOG_PRINT_L1(\"Already saw that one, it's for us\");\n-      txids.push_back({txid, true});\n-    }\n   }\n \n   // get those txes\n\n```\n","markdown_message":"\u003cp\u003eThanks for the report.\u003cbr\u003e\nThe following patches seem to plug the leaks you identified. It might be good to \u0026quot;standardize\u0026quot; the refresh rates so the wallet type cannot be fingerprinted, I\u0026#39;ve not done that here. I\u0026#39;ll do more testing tomorrow to see if anything else is still leaking timing. In particular, the random sleep time before checking the once_a_time timeout might be not quite enough to mask the delay. There\u0026#39;s also still get_info calls upon a prompt being displayed, after the 30 seconds of cache time. That might need changing as well, not sure whether the cache time should have a random component as well.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003ecommit 3c47170dd3512411d94fe22ef5107186491ba63d (HEAD -\u0026gt; crash)\nAuthor: moneromooo-monero \u0026lt;moneromooo-monero@users.noreply.github.com\u0026gt;\nDate:   Tue Oct 15 19:16:13 2019 +0000\n\n    wallet: reuse cached height when set after refresh\n\n    Refreshing sets cached height, which is otherwise got by calling\n    get_info. Since get_info is called upon needing to display a prompt\n    after a command has finished, it can be used to determine how much\n    time a given command took to run if the cache timeout lapses while\n    the command runs. Refreshing caches the height as a side effect, so\n    get_info will never be called as a result of displaying a prompt\n    after refreshing (and potentially leaking how much time it took to\n    process a set of transactions, therefore leaking whether we got\n    some monero in them).\n\ndiff --git a/src/wallet/node_rpc_proxy.cpp b/src/wallet/node_rpc_proxy.cpp\nindex 1d5078a11..ea47d35da 100644\n--- a/src/wallet/node_rpc_proxy.cpp\n+++ b/src/wallet/node_rpc_proxy.cpp\n@@ -58,6 +58,7 @@ void NodeRPCProxy::invalidate()\n   m_target_height = 0;\n   m_block_weight_limit = 0;\n   m_get_info_time = 0;\n+  m_height_time = 0;\n }\n\n boost::optional\u0026lt;std::string\u0026gt; NodeRPCProxy::get_rpc_version(uint32_t \u0026amp;rpc_version) const\n@@ -83,6 +84,7 @@ boost::optional\u0026lt;std::string\u0026gt; NodeRPCProxy::get_rpc_version(uint32_t \u0026amp;rpc_version\n void NodeRPCProxy::set_height(uint64_t h)\n {\n   m_height = h;\n+  m_height_time = time(NULL);\n }\n\n boost::optional\u0026lt;std::string\u0026gt; NodeRPCProxy::get_info() const\n@@ -106,12 +108,20 @@ boost::optional\u0026lt;std::string\u0026gt; NodeRPCProxy::get_info() const\n     m_target_height = resp_t.target_height;\n     m_block_weight_limit = resp_t.block_weight_limit ? resp_t.block_weight_limit : resp_t.block_size_limit;\n     m_get_info_time = now;\n+    m_height_time = now;\n   }\n   return boost::optional\u0026lt;std::string\u0026gt;();\n }\n\n boost::optional\u0026lt;std::string\u0026gt; NodeRPCProxy::get_height(uint64_t \u0026amp;height) const\n {\n+  const time_t now = time(NULL);\n+  if (now \u0026lt; m_height_time + 30) // re-cache every 30 seconds\n+  {\n+    height = m_height;\n+    return boost::optional\u0026lt;std::string\u0026gt;();\n+  }\n+\n   auto res = get_info();\n   if (res)\n     return res;\ndiff --git a/src/wallet/node_rpc_proxy.h b/src/wallet/node_rpc_proxy.h\nindex 3b75c8b94..19b5c3f53 100644\n--- a/src/wallet/node_rpc_proxy.h\n+++ b/src/wallet/node_rpc_proxy.h\n@@ -70,6 +70,7 @@ private:\n   mutable uint64_t m_target_height;\n   mutable uint64_t m_block_weight_limit;\n   mutable time_t m_get_info_time;\n+  mutable time_t m_height_time;\n };\n\n }\n\ncommit 046e6ff727e1ac705a1b34081d49d40f74772d9c\nAuthor: moneromooo-monero \u0026lt;moneromooo-monero@users.noreply.github.com\u0026gt;\nDate:   Tue Oct 15 18:35:11 2019 +0000\n\n    wallet2: fix is_synced checking target height, not height\n\n    Target height would be appropriate for the daemon, which syncs\n    off other daemons, but the wallet syncs off the daemon it\u0026#39;s\n    connected to, and its target is the daemon\u0026#39;s current height.\n\ndiff --git a/src/wallet/wallet2.cpp b/src/wallet/wallet2.cpp\nindex 0982aaa19..d78b1473a 100644\n--- a/src/wallet/wallet2.cpp\n+++ b/src/wallet/wallet2.cpp\n@@ -13200,7 +13200,7 @@ uint64_t wallet2::get_blockchain_height_by_date(uint16_t year, uint8_t month, ui\n bool wallet2::is_synced() const\n {\n   uint64_t height;\n-  boost::optional\u0026lt;std::string\u0026gt; result = m_node_rpc_proxy.get_target_height(height);\n+  boost::optional\u0026lt;std::string\u0026gt; result = m_node_rpc_proxy.get_height(height);\n   if (result \u0026amp;\u0026amp; *result != CORE_RPC_STATUS_OK)\n     return false;\n   return get_blockchain_current_height() \u0026gt;= height;\n\ncommit f5b39fb80c04612effae62286855a177a79ed518\nAuthor: moneromooo-monero \u0026lt;moneromooo-monero@users.noreply.github.com\u0026gt;\nDate:   Tue Oct 15 18:10:29 2019 +0000\n\n    wallet: fix another fact of \u0026quot;did I get some monero\u0026quot; information leak\n\n    We get new pool txes before processing any tx, pool or not.\n    This ensures that if we\u0026#39;re asked for a password, this does not\n    cause a measurable delay in the txpool query after the last\n    block query.\n\ndiff --git a/src/simplewallet/simplewallet.cpp b/src/simplewallet/simplewallet.cpp\nindex 2ebecb07d..0518e5231 100644\n--- a/src/simplewallet/simplewallet.cpp\n+++ b/src/simplewallet/simplewallet.cpp\n@@ -8177,7 +8177,11 @@ bool simple_wallet::get_transfers(std::vector\u0026lt;std::string\u0026gt;\u0026amp; local_args, std::vec\n       m_in_manual_refresh.store(true, std::memory_order_relaxed);\n       epee::misc_utils::auto_scope_leave_caller scope_exit_handler = epee::misc_utils::create_scope_leave_handler([\u0026amp;](){m_in_manual_refresh.store(false, std::memory_order_relaxed);});\n\n-      m_wallet-\u0026gt;update_pool_state();\n+      std::vector\u0026lt;std::pair\u0026lt;cryptonote::transaction, bool\u0026gt;\u0026gt; process_txs;\n+      m_wallet-\u0026gt;update_pool_state(process_txs);\n+      if (!process_txs.empty())\n+        m_wallet-\u0026gt;process_pool_state(process_txs);\n+\n       std::list\u0026lt;std::pair\u0026lt;crypto::hash, tools::wallet2::pool_payment_details\u0026gt;\u0026gt; payments;\n       m_wallet-\u0026gt;get_unconfirmed_payments(payments, m_current_subaddress_account, subaddr_indices);\n       for (std::list\u0026lt;std::pair\u0026lt;crypto::hash, tools::wallet2::pool_payment_details\u0026gt;\u0026gt;::const_iterator i = payments.begin(); i != payments.end(); ++i) {\n@@ -9750,7 +9754,11 @@ bool simple_wallet::show_transfer(const std::vector\u0026lt;std::string\u0026gt; \u0026amp;args)\n\n   try\n   {\n-    m_wallet-\u0026gt;update_pool_state();\n+    std::vector\u0026lt;std::pair\u0026lt;cryptonote::transaction, bool\u0026gt;\u0026gt; process_txs;\n+    m_wallet-\u0026gt;update_pool_state(process_txs);\n+    if (!process_txs.empty())\n+      m_wallet-\u0026gt;process_pool_state(process_txs);\n+\n     std::list\u0026lt;std::pair\u0026lt;crypto::hash, tools::wallet2::pool_payment_details\u0026gt;\u0026gt; pool_payments;\n     m_wallet-\u0026gt;get_unconfirmed_payments(pool_payments, m_current_subaddress_account);\n     for (std::list\u0026lt;std::pair\u0026lt;crypto::hash, tools::wallet2::pool_payment_details\u0026gt;\u0026gt;::const_iterator i = pool_payments.begin(); i != pool_payments.end(); ++i) {\ndiff --git a/src/wallet/wallet2.cpp b/src/wallet/wallet2.cpp\nindex caa76a5f9..0982aaa19 100644\n--- a/src/wallet/wallet2.cpp\n+++ b/src/wallet/wallet2.cpp\n@@ -2825,7 +2825,7 @@ void wallet2::remove_obsolete_pool_txs(const std::vector\u0026lt;crypto::hash\u0026gt; \u0026amp;tx_hashe\n }\n\n //----------------------------------------------------------------------------------------------------\n-void wallet2::update_pool_state(bool refreshed)\n+void wallet2::update_pool_state(std::vector\u0026lt;std::pair\u0026lt;cryptonote::transaction, bool\u0026gt;\u0026gt; \u0026amp;process_txs, bool refreshed)\n {\n   MTRACE(\u0026quot;update_pool_state start\u0026quot;);\n\n@@ -3004,13 +3004,7 @@ void wallet2::update_pool_state(bool refreshed)\n                     [tx_hash](const std::pair\u0026lt;crypto::hash, bool\u0026gt; \u0026amp;e) { return e.first == tx_hash; });\n                 if (i != txids.end())\n                 {\n-                  process_new_transaction(tx_hash, tx, std::vector\u0026lt;uint64_t\u0026gt;(), 0, 0, time(NULL), false, true, tx_entry.double_spend_seen, {});\n-                  m_scanned_pool_txs[0].insert(tx_hash);\n-                  if (m_scanned_pool_txs[0].size() \u0026gt; 5000)\n-                  {\n-                    std::swap(m_scanned_pool_txs[0], m_scanned_pool_txs[1]);\n-                    m_scanned_pool_txs[0].clear();\n-                  }\n+                  process_txs.push_back(std::make_pair(tx, tx_entry.double_spend_seen));\n                 }\n                 else\n                 {\n@@ -3041,6 +3035,24 @@ void wallet2::update_pool_state(bool refreshed)\n   MTRACE(\u0026quot;update_pool_state end\u0026quot;);\n }\n //----------------------------------------------------------------------------------------------------\n+void wallet2::process_pool_state(const std::vector\u0026lt;std::pair\u0026lt;cryptonote::transaction, bool\u0026gt;\u0026gt; \u0026amp;txs)\n+{\n+  const time_t now = time(NULL);\n+  for (const auto \u0026amp;e: txs)\n+  {\n+    const cryptonote::transaction \u0026amp;tx = e.first;\n+    const bool double_spend_seen = e.second;\n+    const crypto::hash tx_hash = get_transaction_hash(tx);\n+    process_new_transaction(tx_hash, tx, std::vector\u0026lt;uint64_t\u0026gt;(), 0, 0, now, false, true, double_spend_seen, {});\n+    m_scanned_pool_txs[0].insert(tx_hash);\n+    if (m_scanned_pool_txs[0].size() \u0026gt; 5000)\n+    {\n+      std::swap(m_scanned_pool_txs[0], m_scanned_pool_txs[1]);\n+      m_scanned_pool_txs[0].clear();\n+    }\n+  }\n+}\n+//----------------------------------------------------------------------------------------------------\n void wallet2::fast_refresh(uint64_t stop_height, uint64_t \u0026amp;blocks_start_height, std::list\u0026lt;crypto::hash\u0026gt; \u0026amp;short_chain_history, bool force)\n {\n   std::vector\u0026lt;crypto::hash\u0026gt; hashes;\n@@ -3244,6 +3256,14 @@ void wallet2::refresh(bool trusted_daemon, uint64_t start_height, uint64_t \u0026amp; blo\n   });\n\n   auto scope_exit_handler_hwdev = epee::misc_utils::create_scope_leave_handler([\u0026amp;](){hwdev.computing_key_images(false);});\n+\n+  // get updated pool state first, but do not process those txes just yet,\n+  // since that might cause a password prompt, which would introduce a data\n+  // leak allowing a passive adversary with traffic analysis capability to\n+  // infer when we get an incoming output\n+  std::vector\u0026lt;std::pair\u0026lt;cryptonote::transaction, bool\u0026gt;\u0026gt; process_pool_txs;\n+  update_pool_state(process_pool_txs, refreshed);\n+\n   bool first = true, last = false;\n   while(m_run.load(std::memory_order_relaxed))\n   {\n@@ -3362,8 +3382,8 @@ void wallet2::refresh(bool trusted_daemon, uint64_t start_height, uint64_t \u0026amp; blo\n   try\n   {\n     // If stop() is called we don\u0026#39;t need to check pending transactions\n-    if (check_pool \u0026amp;\u0026amp; m_run.load(std::memory_order_relaxed))\n-      update_pool_state(refreshed);\n+    if (check_pool \u0026amp;\u0026amp; m_run.load(std::memory_order_relaxed) \u0026amp;\u0026amp; !process_pool_txs.empty())\n+      process_pool_state(process_pool_txs);\n   }\n   catch (...)\n   {\ndiff --git a/src/wallet/wallet2.h b/src/wallet/wallet2.h\nindex 94d67f622..5a4d4240c 100644\n--- a/src/wallet/wallet2.h\n+++ b/src/wallet/wallet2.h\n@@ -1213,7 +1213,8 @@ private:\n     bool import_key_images(signed_tx_set \u0026amp; signed_tx, size_t offset=0, bool only_selected_transfers=false);\n     crypto::public_key get_tx_pub_key_from_received_outs(const tools::wallet2::transfer_details \u0026amp;td) const;\n\n-    void update_pool_state(bool refreshed = false);\n+    void update_pool_state(std::vector\u0026lt;std::pair\u0026lt;cryptonote::transaction, bool\u0026gt;\u0026gt; \u0026amp;process_txs, bool refreshed = false);\n+    void process_pool_state(const std::vector\u0026lt;std::pair\u0026lt;cryptonote::transaction, bool\u0026gt;\u0026gt; \u0026amp;txs);\n     void remove_obsolete_pool_txs(const std::vector\u0026lt;crypto::hash\u0026gt; \u0026amp;tx_hashes);\n\n     std::string encrypt(const char *plaintext, size_t len, const crypto::secret_key \u0026amp;skey, bool authenticated = true) const;\ndiff --git a/src/wallet/wallet_rpc_server.cpp b/src/wallet/wallet_rpc_server.cpp\nindex bd79ee981..04f751354 100644\n--- a/src/wallet/wallet_rpc_server.cpp\n+++ b/src/wallet/wallet_rpc_server.cpp\n@@ -2452,7 +2452,10 @@ namespace tools\n\n     if (req.pool)\n     {\n-      m_wallet-\u0026gt;update_pool_state();\n+      std::vector\u0026lt;std::pair\u0026lt;cryptonote::transaction, bool\u0026gt;\u0026gt; process_txs;\n+      m_wallet-\u0026gt;update_pool_state(process_txs);\n+      if (!process_txs.empty())\n+        m_wallet-\u0026gt;process_pool_state(process_txs);\n\n       std::list\u0026lt;std::pair\u0026lt;crypto::hash, tools::wallet2::pool_payment_details\u0026gt;\u0026gt; payments;\n       m_wallet-\u0026gt;get_unconfirmed_payments(payments, account_index, subaddr_indices);\n@@ -2532,7 +2535,10 @@ namespace tools\n       }\n     }\n\n-    m_wallet-\u0026gt;update_pool_state();\n+    std::vector\u0026lt;std::pair\u0026lt;cryptonote::transaction, bool\u0026gt;\u0026gt; process_txs;\n+    m_wallet-\u0026gt;update_pool_state(process_txs);\n+    if (!process_txs.empty())\n+      m_wallet-\u0026gt;process_pool_state(process_txs);\n\n     std::list\u0026lt;std::pair\u0026lt;crypto::hash, tools::wallet2::pool_payment_details\u0026gt;\u0026gt; pool_payments;\n     m_wallet-\u0026gt;get_unconfirmed_payments(pool_payments, req.account_index);\n\ncommit dc8b8dc9b85e66436ad3a3d4a800d7dce354e8c7\nAuthor: moneromooo-monero \u0026lt;moneromooo-monero@users.noreply.github.com\u0026gt;\nDate:   Tue Oct 15 12:25:26 2019 +0000\n\n    wallet2: do not send an unnecessary last getblocks.bin call on refresh\n\n    The \u0026quot;everything refreshed\u0026quot; state was detected when a refresh call did\n    not return any new blocks. This can be detected without that extra\n    \u0026quot;empty\u0026quot; call by comparing the claimed node height to the height of\n    the last block retrieved. Doing this avoids that last call, saves\n    some bandwidth, and makes the common refresh case use only one call\n    rather than two.\n\n    As a side effect, it prevents an information leak reported by\n    Tramèr et al: if the wallet retrieves a set of blocks which includes\n    an output sent to the refreshing wallet, the wallet will prompt the\n    user for the password to decode the amount and calculate the key\n    image for the new output, and this will delay subsequent calls to\n    getblocks.bin, allowing a passive adversary to note the delay and\n    deduce when the wallet receives at least one output.\n\n    This can still happen if the wallet downloads more than 1000 blocks,\n    since this will be split in several calls, but then the most the\n    adversary can tell is which 1000 block section the user received\n    some monero (the adversary can estimate the heights of the blocks\n    by calculating how many \u0026quot;large\u0026quot; transfers are done, which will be\n    sections of blocks, the last of which will usually be below 1000,\n    but the size of the data should allow the actual number of blocks\n    sent to be determined fairly accurately).\n\n    This timing trick still be used via the subsequent scan for incoming\n    txes in the txpool, which will be fixed later.\n\ndiff --git a/src/wallet/wallet2.cpp b/src/wallet/wallet2.cpp\nindex c136ff6d8..caa76a5f9 100644\n--- a/src/wallet/wallet2.cpp\n+++ b/src/wallet/wallet2.cpp\n@@ -2531,6 +2531,8 @@ void wallet2::pull_blocks(uint64_t start_height, uint64_t \u0026amp;blocks_start_height,\n   cryptonote::COMMAND_RPC_GET_BLOCKS_FAST::response res = AUTO_VAL_INIT(res);\n   req.block_ids = short_chain_history;\n\n+  MDEBUG(\u0026quot;Pulling blocks: start_height \u0026quot; \u0026lt;\u0026lt; start_height);\n+\n   req.prune = true;\n   req.start_height = start_height;\n   req.no_miner_tx = m_refresh_type == RefreshNoCoinbase;\n@@ -2547,6 +2549,9 @@ void wallet2::pull_blocks(uint64_t start_height, uint64_t \u0026amp;blocks_start_height,\n   blocks_start_height = res.start_height;\n   blocks = std::move(res.blocks);\n   o_indices = std::move(res.output_indices);\n+\n+  MDEBUG(\u0026quot;Pulled blocks: blocks_start_height \u0026quot; \u0026lt;\u0026lt; blocks_start_height \u0026lt;\u0026lt; \u0026quot;, count \u0026quot; \u0026lt;\u0026lt; blocks.size()\n+      \u0026lt;\u0026lt; \u0026quot;, height \u0026quot; \u0026lt;\u0026lt; blocks_start_height + blocks.size() \u0026lt;\u0026lt; \u0026quot;, node height \u0026quot; \u0026lt;\u0026lt; res.current_height);\n }\n //----------------------------------------------------------------------------------------------------\n void wallet2::pull_hashes(uint64_t start_height, uint64_t \u0026amp;blocks_start_height, const std::list\u0026lt;crypto::hash\u0026gt; \u0026amp;short_chain_history, std::vector\u0026lt;crypto::hash\u0026gt; \u0026amp;hashes)\n@@ -2726,9 +2731,10 @@ void wallet2::refresh(bool trusted_daemon, uint64_t start_height, uint64_t \u0026amp; blo\n   refresh(trusted_daemon, start_height, blocks_fetched, received_money);\n }\n //----------------------------------------------------------------------------------------------------\n-void wallet2::pull_and_parse_next_blocks(uint64_t start_height, uint64_t \u0026amp;blocks_start_height, std::list\u0026lt;crypto::hash\u0026gt; \u0026amp;short_chain_history, const std::vector\u0026lt;cryptonote::block_complete_entry\u0026gt; \u0026amp;prev_blocks, const std::vector\u0026lt;parsed_block\u0026gt; \u0026amp;prev_parsed_blocks, std::vector\u0026lt;cryptonote::block_complete_entry\u0026gt; \u0026amp;blocks, std::vector\u0026lt;parsed_block\u0026gt; \u0026amp;parsed_blocks, bool \u0026amp;error)\n+void wallet2::pull_and_parse_next_blocks(uint64_t start_height, uint64_t \u0026amp;blocks_start_height, std::list\u0026lt;crypto::hash\u0026gt; \u0026amp;short_chain_history, const std::vector\u0026lt;cryptonote::block_complete_entry\u0026gt; \u0026amp;prev_blocks, const std::vector\u0026lt;parsed_block\u0026gt; \u0026amp;prev_parsed_blocks, std::vector\u0026lt;cryptonote::block_complete_entry\u0026gt; \u0026amp;blocks, std::vector\u0026lt;parsed_block\u0026gt; \u0026amp;parsed_blocks, bool \u0026amp;last, bool \u0026amp;error)\n {\n   error = false;\n+  last = false;\n\n   try\n   {\n@@ -2783,6 +2789,7 @@ void wallet2::pull_and_parse_next_blocks(uint64_t start_height, uint64_t \u0026amp;blocks\n       }\n     }\n     waiter.wait(\u0026amp;tpool);\n+    last = !blocks.empty() \u0026amp;\u0026amp; cryptonote::get_block_height(parsed_blocks.back().block) + 1 == blocks_start_height + parsed_blocks.size();\n   }\n   catch(...)\n   {\n@@ -3237,7 +3244,7 @@ void wallet2::refresh(bool trusted_daemon, uint64_t start_height, uint64_t \u0026amp; blo\n   });\n\n   auto scope_exit_handler_hwdev = epee::misc_utils::create_scope_leave_handler([\u0026amp;](){hwdev.computing_key_images(false);});\n-  bool first = true;\n+  bool first = true, last = false;\n   while(m_run.load(std::memory_order_relaxed))\n   {\n     uint64_t next_blocks_start_height;\n@@ -3256,7 +3263,8 @@ void wallet2::refresh(bool trusted_daemon, uint64_t start_height, uint64_t \u0026amp; blo\n         refreshed = false;\n         break;\n       }\n-      tpool.submit(\u0026amp;waiter, [\u0026amp;]{pull_and_parse_next_blocks(start_height, next_blocks_start_height, short_chain_history, blocks, parsed_blocks, next_blocks, next_parsed_blocks, error);});\n+      if (!last)\n+        tpool.submit(\u0026amp;waiter, [\u0026amp;]{pull_and_parse_next_blocks(start_height, next_blocks_start_height, short_chain_history, blocks, parsed_blocks, next_blocks, next_parsed_blocks, last, error);});\n\n       if (!first)\n       {\ndiff --git a/src/wallet/wallet2.h b/src/wallet/wallet2.h\nindex b4a0ddf04..94d67f622 100644\n--- a/src/wallet/wallet2.h\n+++ b/src/wallet/wallet2.h\n@@ -1387,7 +1387,7 @@ private:\n     void pull_blocks(uint64_t start_height, uint64_t\u0026amp; blocks_start_height, const std::list\u0026lt;crypto::hash\u0026gt; \u0026amp;short_chain_history, std::vector\u0026lt;cryptonote::block_complete_entry\u0026gt; \u0026amp;blocks, std::vector\u0026lt;cryptonote::COMMAND_RPC_GET_BLOCKS_FAST::block_output_indices\u0026gt; \u0026amp;o_indices);\n     void pull_hashes(uint64_t start_height, uint64_t\u0026amp; blocks_start_height, const std::list\u0026lt;crypto::hash\u0026gt; \u0026amp;short_chain_history, std::vector\u0026lt;crypto::hash\u0026gt; \u0026amp;hashes);\n     void fast_refresh(uint64_t stop_height, uint64_t \u0026amp;blocks_start_height, std::list\u0026lt;crypto::hash\u0026gt; \u0026amp;short_chain_history, bool force = false);\n-    void pull_and_parse_next_blocks(uint64_t start_height, uint64_t \u0026amp;blocks_start_height, std::list\u0026lt;crypto::hash\u0026gt; \u0026amp;short_chain_history, const std::vector\u0026lt;cryptonote::block_complete_entry\u0026gt; \u0026amp;prev_blocks, const std::vector\u0026lt;parsed_block\u0026gt; \u0026amp;prev_parsed_blocks, std::vector\u0026lt;cryptonote::block_complete_entry\u0026gt; \u0026amp;blocks, std::vector\u0026lt;parsed_block\u0026gt; \u0026amp;parsed_blocks, bool \u0026amp;error);\n+    void pull_and_parse_next_blocks(uint64_t start_height, uint64_t \u0026amp;blocks_start_height, std::list\u0026lt;crypto::hash\u0026gt; \u0026amp;short_chain_history, const std::vector\u0026lt;cryptonote::block_complete_entry\u0026gt; \u0026amp;prev_blocks, const std::vector\u0026lt;parsed_block\u0026gt; \u0026amp;prev_parsed_blocks, std::vector\u0026lt;cryptonote::block_complete_entry\u0026gt; \u0026amp;blocks, std::vector\u0026lt;parsed_block\u0026gt; \u0026amp;parsed_blocks, bool \u0026amp;last, bool \u0026amp;error);\n     void process_parsed_blocks(uint64_t start_height, const std::vector\u0026lt;cryptonote::block_complete_entry\u0026gt; \u0026amp;blocks, const std::vector\u0026lt;parsed_block\u0026gt; \u0026amp;parsed_blocks, uint64_t\u0026amp; blocks_added, std::map\u0026lt;std::pair\u0026lt;uint64_t, uint64_t\u0026gt;, size_t\u0026gt; *output_tracker_cache = NULL);\n     uint64_t select_transfers(uint64_t needed_money, std::vector\u0026lt;size_t\u0026gt; unused_transfers_indices, std::vector\u0026lt;size_t\u0026gt;\u0026amp; selected_transfers) const;\n     bool prepare_file_names(const std::string\u0026amp; file_path);\n\ncommit 6413d601606a9642fa8b60c00823364abb7ffc83\nAuthor: moneromooo-monero \u0026lt;moneromooo-monero@users.noreply.github.com\u0026gt;\nDate:   Tue Oct 15 10:30:50 2019 +0000\n\n    simplewallet: make the idle thread wait times random\n\n    This prevents direct mapping from time between calls to refresh\n    functions to \u0026quot;how much time did it take to run a refresh function\u0026quot;,\n    at least modulo one second.\n    The once_a_time class will trigger when its time is up, but it needs\n    to be called often enough to have a chance to trigger close to the\n    ideal trigger time. The current code was calling every T, with T\n    being one second plus whatever time it took to execute the previous\n    idle functions, if any, so typically either 1 second or 1 second\n    plus dt, so this dt becomes observable on the network once an integer\n    number of seconds is subtracted from the delay between two calls to\n    get_blocks.bin.\n\n    This should help decrease timing side channels found by Tramèr et al.\n\ndiff --git a/src/simplewallet/simplewallet.cpp b/src/simplewallet/simplewallet.cpp\nindex 1a218c6f9..2ebecb07d 100644\n--- a/src/simplewallet/simplewallet.cpp\n+++ b/src/simplewallet/simplewallet.cpp\n@@ -8638,7 +8638,7 @@ void simple_wallet::wallet_idle_thread()\n\n     if (!m_idle_run.load(std::memory_order_relaxed))\n       break;\n-    m_idle_cond.wait_for(lock, boost::chrono::seconds(1));\n+    m_idle_cond.wait_for(lock, boost::chrono::milliseconds(crypto::rand_range\u0026lt;uint32_t\u0026gt;(200, 2000)));\n   }\n }\n //----------------------------------------------------------------------------------------------------\n\ncommit 1fc674ebf1e4ead7f2934d1eca830a136565803b\nAuthor: moneromooo-monero \u0026lt;moneromooo-monero@users.noreply.github.com\u0026gt;\nDate:   Tue Oct 15 09:12:24 2019 +0000\n\n    wallet2: do not repeatedly ask for pool txes sent to us\n\n    This lets a passive attacker with access to the network link\n    between node and wallet perform traffic analysis to deduce\n    when an idle wallet receives a transaction.\n\n    Reported by Tramèr et al.\n\ndiff --git a/src/wallet/wallet2.cpp b/src/wallet/wallet2.cpp\nindex 3314e9297..c136ff6d8 100644\n--- a/src/wallet/wallet2.cpp\n+++ b/src/wallet/wallet2.cpp\n@@ -2963,11 +2963,6 @@ void wallet2::update_pool_state(bool refreshed)\n         LOG_PRINT_L1(\u0026quot;We sent that one\u0026quot;);\n       }\n     }\n-    else\n-    {\n-      LOG_PRINT_L1(\u0026quot;Already saw that one, it\u0026#39;s for us\u0026quot;);\n-      txids.push_back({txid, true});\n-    }\n   }\n\n   // get those txes\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","automated_response":false,"created_at":"2019-10-15T20:38:05.514Z","updated_at":"2019-10-15T20:38:05.514Z","actor":{"username":"moneromooo","cleared":false,"url":"/moneromooo","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":6048957,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Thanks for looking into this. I have some comments about the proposed fixes:\n\n- I don't understand why `update_pool_state` is being split into two functions, one that first gathers all transactions to be processed, and one that then processes all of them. It seems to me that even with this change, the wallet still issues a `\"/gettransactions\"` request for the transactions that pay the wallet, and then processes all of them. I'm not sure what the proposed change is meant to accomplish.\n- Instead of sleeping for a random time before a refresh, a more principled approach could be to always wake up at a 1 second boundary. That is, upon waking up, get the current time `before_refresh` rounded down to the second. After the refresh, get the current time `after_refresh` (at microsecond granularity) and sleep for `before_refresh + 1sec - after_refresh`. This will guarantee that after the first refresh, the wallet always wakes up at the start of a new second, regardless of the duration of the refresh.\n- The changes to `pull_and_parse_next_blocks` seem sound to me.","markdown_message":"\u003cp\u003eThanks for looking into this. I have some comments about the proposed fixes:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eI don\u0026#39;t understand why \u003ccode\u003eupdate_pool_state\u003c/code\u003e is being split into two functions, one that first gathers all transactions to be processed, and one that then processes all of them. It seems to me that even with this change, the wallet still issues a \u003ccode\u003e\u0026quot;/gettransactions\u0026quot;\u003c/code\u003e request for the transactions that pay the wallet, and then processes all of them. I\u0026#39;m not sure what the proposed change is meant to accomplish.\u003c/li\u003e\n\u003cli\u003eInstead of sleeping for a random time before a refresh, a more principled approach could be to always wake up at a 1 second boundary. That is, upon waking up, get the current time \u003ccode\u003ebefore_refresh\u003c/code\u003e rounded down to the second. After the refresh, get the current time \u003ccode\u003eafter_refresh\u003c/code\u003e (at microsecond granularity) and sleep for \u003ccode\u003ebefore_refresh + 1sec - after_refresh\u003c/code\u003e. This will guarantee that after the first refresh, the wallet always wakes up at the start of a new second, regardless of the duration of the refresh.\u003c/li\u003e\n\u003cli\u003eThe changes to \u003ccode\u003epull_and_parse_next_blocks\u003c/code\u003e seem sound to me.\u003c/li\u003e\n\u003c/ul\u003e\n","automated_response":false,"created_at":"2019-10-15T21:13:25.716Z","updated_at":"2019-10-15T21:13:25.716Z","actor":{"username":"ftramer","cleared":false,"url":"/ftramer","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6049602,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"\u003eInstead of sleeping for a random time before a refresh, a more principled approach could be...\n\nYes, I concur, this could work for now.","markdown_message":"\u003cblockquote\u003e\n\u003cp\u003eInstead of sleeping for a random time before a refresh, a more principled approach could be...\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eYes, I concur, this could work for now.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-10-16T00:14:29.440Z","updated_at":"2019-10-16T00:14:29.440Z","actor":{"username":"anonimal","cleared":false,"url":"/anonimal","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/040/857/f23cc3be09a21e17bc43975987c10ba2b6427239_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6049653,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"update_pool_state is split so that you cannot measure a time difference beteen getblocks.bin and update_pool_state, which would leak whether a password was prompted for. The split ensures that any tx is received before any processing/password. Moving the whole first would have had the same problem if the scan was a foreground one, and a password was requested for a txpool tx, in which case the getblocks.bin call would have been late.\n\nFair point about the sleep. The loop currently triggers every second, but I can track the time at which each loop starts, and sleep for as many microseconds as required to get to an integer number of seconds after that. This will have the possible issue that the real time will be not an integer number of seconds but an integer number of seconds plus whatever extra overhead time is spent by the cond var and mutex code after the timeout triggers. Hopefully too small to notice.","markdown_message":"\u003cp\u003eupdate_pool_state is split so that you cannot measure a time difference beteen getblocks.bin and update_pool_state, which would leak whether a password was prompted for. The split ensures that any tx is received before any processing/password. Moving the whole first would have had the same problem if the scan was a foreground one, and a password was requested for a txpool tx, in which case the getblocks.bin call would have been late.\u003c/p\u003e\n\n\u003cp\u003eFair point about the sleep. The loop currently triggers every second, but I can track the time at which each loop starts, and sleep for as many microseconds as required to get to an integer number of seconds after that. This will have the possible issue that the real time will be not an integer number of seconds but an integer number of seconds plus whatever extra overhead time is spent by the cond var and mutex code after the timeout triggers. Hopefully too small to notice.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-10-16T00:34:09.527Z","updated_at":"2019-10-16T00:34:09.527Z","actor":{"username":"moneromooo","cleared":false,"url":"/moneromooo","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":6049655,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"\u003e with this change, the wallet still issues a \"/gettransactions\" request for the transactions that pay the wallet\n\nIt does, but also does for the transactions that do not pay the wallet. The ones that paid the wallet were requested repeatedly, and they are not anymore. Or should not be anyway, unless bug.\n","markdown_message":"\u003cblockquote\u003e\n\u003cp\u003ewith this change, the wallet still issues a \u0026quot;/gettransactions\u0026quot; request for the transactions that pay the wallet\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eIt does, but also does for the transactions that do not pay the wallet. The ones that paid the wallet were requested repeatedly, and they are not anymore. Or should not be anyway, unless bug.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-10-16T00:36:39.765Z","updated_at":"2019-10-16T00:36:39.765Z","actor":{"username":"moneromooo","cleared":false,"url":"/moneromooo","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":6049656,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Got it! That sounds good to me. ","markdown_message":"\u003cp\u003eGot it! That sounds good to me. \u003c/p\u003e\n","automated_response":false,"created_at":"2019-10-16T00:38:03.741Z","updated_at":"2019-10-16T00:38:03.741Z","actor":{"username":"ftramer","cleared":false,"url":"/ftramer","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6062437,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Hi @ftramer - with regards to a disclosure timeline, we're targeting October 31st for the v0.15 release, and November 30th for the network upgrade which would force all remote nodes to be on v0.15. Could we do the disclosure just after the network upgrade, so on like December 1st? Let me know if that works for you or if you're thinking of a different timeline.","markdown_message":"\u003cp\u003eHi \u003ca href=\"/ftramer\"\u003e@ftramer\u003c/a\u003e - with regards to a disclosure timeline, we\u0026#39;re targeting October 31st for the v0.15 release, and November 30th for the network upgrade which would force all remote nodes to be on v0.15. Could we do the disclosure just after the network upgrade, so on like December 1st? Let me know if that works for you or if you\u0026#39;re thinking of a different timeline.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-10-17T09:03:53.633Z","updated_at":"2019-10-17T09:03:53.633Z","actor":{"username":"fluffypony","cleared":false,"url":"/fluffypony","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":6064022,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Further patch to simplewallet, which will replace 6413d601606a9642fa8b60c00823364abb7ffc83.\nNote that the delays must be randomized, since you can't refresh while a password prompt is being displayed.\nAllowing this would require non trivial changes to the wallet refresh code.\nWith this patch, the wallet will refresh on an integer number of seconds after last time, but the number of seconds is randomized within an appropriate range.\n\n```\ncommit 7f359c1029b8d4f3fec1e072e2dcd90fc3cc69fa (HEAD -\u003e crash)\nAuthor: moneromooo-monero \u003cmoneromooo-monero@users.noreply.github.com\u003e\nDate:   Thu Oct 17 12:13:49 2019 +0000\n\n    simplewallet: plug a timing leak\n    \n    As reported by Tramèr et al, timing of refresh requests can be used\n    to see whether a password was requested (and thus at least one output\n    received) since this will induce a delay in subsequent calls.\n    To avoid this, we schedule calls at a given time instead of sleeping\n    for a set time (which would make delays additive).\n    To further avoid a scheduled call being during the time in which a\n    password is prompted, the actual scheduled time is now randomized.\n\ndiff --git a/src/simplewallet/simplewallet.cpp b/src/simplewallet/simplewallet.cpp\nindex 0518e5231..843d8cdcd 100644\n--- a/src/simplewallet/simplewallet.cpp\n+++ b/src/simplewallet/simplewallet.cpp\n@@ -8628,21 +8628,35 @@ void simple_wallet::check_for_messages()\n //----------------------------------------------------------------------------------------------------\n void simple_wallet::wallet_idle_thread()\n {\n+  const boost::posix_time::ptime start_time = boost::posix_time::microsec_clock::universal_time();\n   while (true)\n   {\n     boost::unique_lock\u003cboost::mutex\u003e lock(m_idle_mutex);\n     if (!m_idle_run.load(std::memory_order_relaxed))\n       break;\n \n+    // if another thread was busy (ie, a foreground refresh thread), we'll end up here at\n+    // some random time that's not what we slept for, so we should not call refresh now\n+    // or we'll be leaking that fact through timing\n+    const boost::posix_time::ptime now0 = boost::posix_time::microsec_clock::universal_time();\n+    const auto dt_actual = (now0 - start_time).total_microseconds() % 1000000;\n+    if (dt_actual \u003c 1000) // if less than a millisecond... would a very slow machine always miss it ?\n+    {\n #ifndef _WIN32\n-    m_inactivity_checker.do_call(boost::bind(\u0026simple_wallet::check_inactivity, this));\n+      m_inactivity_checker.do_call(boost::bind(\u0026simple_wallet::check_inactivity, this));\n #endif\n-    m_refresh_checker.do_call(boost::bind(\u0026simple_wallet::check_refresh, this));\n-    m_mms_checker.do_call(boost::bind(\u0026simple_wallet::check_mms, this));\n+      m_refresh_checker.do_call(boost::bind(\u0026simple_wallet::check_refresh, this));\n+      m_mms_checker.do_call(boost::bind(\u0026simple_wallet::check_mms, this));\n \n-    if (!m_idle_run.load(std::memory_order_relaxed))\n-      break;\n-    m_idle_cond.wait_for(lock, boost::chrono::milliseconds(crypto::rand_range\u003cuint32_t\u003e(200, 2000)));\n+      if (!m_idle_run.load(std::memory_order_relaxed))\n+        break;\n+    }\n+\n+    // aim for the next multiple of 1 second\n+    const boost::posix_time::ptime now = boost::posix_time::microsec_clock::universal_time();\n+    const auto dt = (now - start_time).total_microseconds();\n+    const auto wait = 1000000 - dt % 1000000;\n+    m_idle_cond.wait_for(lock, boost::chrono::microseconds(wait));\n   }\n }\n //----------------------------------------------------------------------------------------------------\ndiff --git a/src/simplewallet/simplewallet.h b/src/simplewallet/simplewallet.h\nindex 98195c640..0f7e38967 100644\n--- a/src/simplewallet/simplewallet.h\n+++ b/src/simplewallet/simplewallet.h\n@@ -437,8 +437,8 @@ namespace cryptonote\n     std::atomic\u003cbool\u003e m_in_command;\n \n     epee::math_helper::once_a_time_seconds\u003c1\u003e m_inactivity_checker;\n-    epee::math_helper::once_a_time_seconds\u003c90\u003e m_refresh_checker;\n-    epee::math_helper::once_a_time_seconds\u003c90\u003e m_mms_checker;\n+    epee::math_helper::once_a_time_seconds_range\u003c80, 100\u003e m_refresh_checker;\n+    epee::math_helper::once_a_time_seconds_range\u003c90, 110\u003e m_mms_checker;\n     \n     // MMS\n     mms::message_store\u0026 get_message_store() const { return m_wallet-\u003eget_message_store(); };\n\ncommit fd7b17251b8da8eba46a4a8c65ebba0892ac3635\nAuthor: moneromooo-monero \u003cmoneromooo-monero@users.noreply.github.com\u003e\nDate:   Thu Oct 17 12:13:17 2019 +0000\n\n    epee: allow a random component in once_a_time timeouts\n\ndiff --git a/contrib/epee/include/math_helper.h b/contrib/epee/include/math_helper.h\nindex ddc1f7f4b..3f8e83315 100644\n--- a/contrib/epee/include/math_helper.h\n+++ b/contrib/epee/include/math_helper.h\n@@ -230,7 +230,7 @@ namespace math_helper\n                }\n \n        }\n-       template\u003cuint64_t scale, int default_interval, bool start_immediate = true\u003e\n+       template\u003cuint64_t scale, int default_interval_min, int default_interval_max, bool start_immediate = true\u003e\n        class once_a_time\n        {\n     uint64_t get_time() const\n@@ -251,12 +251,23 @@ namespace math_helper\n #endif\n     }\n \n+    void set_next_interval()\n+    {\n+      m_interval = m_interval_min;\n+      if (m_interval_max \u003e m_interval_min)\n+      {\n+        const float r = (rand() % 65536) / 65536.f /* never reach 1 */; // good enough ?\n+        m_interval += (m_interval_max - m_interval_min + 1) * r;\n+      }\n+    }\n+\n        public:\n-               once_a_time():m_interval(default_interval * scale)\n+               once_a_time():m_interval_min(default_interval_min * scale), m_interval_max(default_interval_max * scale)\n                {\n                        m_last_worked_time = 0;\n       if(!start_immediate)\n         m_last_worked_time = get_time();\n+      set_next_interval();\n                }\n \n                template\u003cclass functor_t\u003e\n@@ -268,6 +279,7 @@ namespace math_helper\n                        {\n                                bool res = functr();\n                                m_last_worked_time = get_time();\n+        set_next_interval();\n                                return res;\n                        }\n                        return true;\n@@ -275,6 +287,8 @@ namespace math_helper\n \n        private:\n                uint64_t m_last_worked_time;\n+               uint64_t m_interval_min;\n+               uint64_t m_interval_max;\n                uint64_t m_interval;\n        };\n \n@@ -282,5 +296,7 @@ namespace math_helper\n   class once_a_time_seconds: public once_a_time\u003c1000000, default_interval, start_immediate\u003e {};\n   template\u003cint default_interval, bool start_immediate = true\u003e\n   class once_a_time_milliseconds: public once_a_time\u003c1000, default_interval, start_immediate\u003e {};\n+  template\u003cint default_interval_min, int default_interval_max, bool start_immediate = true\u003e\n+  class once_a_time_seconds_range: public once_a_time\u003c1000000, default_interval_min, default_interval_max, start_immediate\u003e {};\n }\n }\n\n```","markdown_message":"\u003cp\u003eFurther patch to simplewallet, which will replace 6413d601606a9642fa8b60c00823364abb7ffc83.\u003cbr\u003e\nNote that the delays must be randomized, since you can\u0026#39;t refresh while a password prompt is being displayed.\u003cbr\u003e\nAllowing this would require non trivial changes to the wallet refresh code.\u003cbr\u003e\nWith this patch, the wallet will refresh on an integer number of seconds after last time, but the number of seconds is randomized within an appropriate range.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight diff\"\u003e\u003ccode\u003e\u003cspan class=\"p\"\u003ecommit 7f359c1029b8d4f3fec1e072e2dcd90fc3cc69fa (HEAD -\u0026gt; crash)\nAuthor: moneromooo-monero \u0026lt;moneromooo-monero@users.noreply.github.com\u0026gt;\nDate:   Thu Oct 17 12:13:49 2019 +0000\n\u003c/span\u003e\n    simplewallet: plug a timing leak\n\n    As reported by Tramèr et al, timing of refresh requests can be used\n    to see whether a password was requested (and thus at least one output\n    received) since this will induce a delay in subsequent calls.\n    To avoid this, we schedule calls at a given time instead of sleeping\n    for a set time (which would make delays additive).\n    To further avoid a scheduled call being during the time in which a\n    password is prompted, the actual scheduled time is now randomized.\n\ndiff --git a/src/simplewallet/simplewallet.cpp b/src/simplewallet/simplewallet.cpp\n\u003cspan class=\"gh\"\u003eindex 0518e5231..843d8cdcd 100644\n\u003c/span\u003e\u003cspan class=\"gd\"\u003e--- a/src/simplewallet/simplewallet.cpp\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+++ b/src/simplewallet/simplewallet.cpp\n\u003c/span\u003e\u003cspan class=\"p\"\u003e@@ -8628,21 +8628,35 @@\u003c/span\u003e void simple_wallet::check_for_messages()\n //----------------------------------------------------------------------------------------------------\n void simple_wallet::wallet_idle_thread()\n {\n\u003cspan class=\"gi\"\u003e+  const boost::posix_time::ptime start_time = boost::posix_time::microsec_clock::universal_time();\n\u003c/span\u003e   while (true)\n   {\n     boost::unique_lock\u0026lt;boost::mutex\u0026gt; lock(m_idle_mutex);\n     if (!m_idle_run.load(std::memory_order_relaxed))\n       break;\n\n+    // if another thread was busy (ie, a foreground refresh thread), we\u0026#39;ll end up here at\n\u003cspan class=\"gi\"\u003e+    // some random time that\u0026#39;s not what we slept for, so we should not call refresh now\n+    // or we\u0026#39;ll be leaking that fact through timing\n+    const boost::posix_time::ptime now0 = boost::posix_time::microsec_clock::universal_time();\n+    const auto dt_actual = (now0 - start_time).total_microseconds() % 1000000;\n+    if (dt_actual \u0026lt; 1000) // if less than a millisecond... would a very slow machine always miss it ?\n+    {\n\u003c/span\u003e #ifndef _WIN32\n\u003cspan class=\"gd\"\u003e-    m_inactivity_checker.do_call(boost::bind(\u0026amp;simple_wallet::check_inactivity, this));\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+      m_inactivity_checker.do_call(boost::bind(\u0026amp;simple_wallet::check_inactivity, this));\n\u003c/span\u003e #endif\n\u003cspan class=\"gd\"\u003e-    m_refresh_checker.do_call(boost::bind(\u0026amp;simple_wallet::check_refresh, this));\n-    m_mms_checker.do_call(boost::bind(\u0026amp;simple_wallet::check_mms, this));\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+      m_refresh_checker.do_call(boost::bind(\u0026amp;simple_wallet::check_refresh, this));\n+      m_mms_checker.do_call(boost::bind(\u0026amp;simple_wallet::check_mms, this));\n\u003c/span\u003e\n-    if (!m_idle_run.load(std::memory_order_relaxed))\n\u003cspan class=\"gd\"\u003e-      break;\n-    m_idle_cond.wait_for(lock, boost::chrono::milliseconds(crypto::rand_range\u0026lt;uint32_t\u0026gt;(200, 2000)));\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+      if (!m_idle_run.load(std::memory_order_relaxed))\n+        break;\n+    }\n+\n+    // aim for the next multiple of 1 second\n+    const boost::posix_time::ptime now = boost::posix_time::microsec_clock::universal_time();\n+    const auto dt = (now - start_time).total_microseconds();\n+    const auto wait = 1000000 - dt % 1000000;\n+    m_idle_cond.wait_for(lock, boost::chrono::microseconds(wait));\n\u003c/span\u003e   }\n }\n //----------------------------------------------------------------------------------------------------\n\u003cspan class=\"gh\"\u003ediff --git a/src/simplewallet/simplewallet.h b/src/simplewallet/simplewallet.h\nindex 98195c640..0f7e38967 100644\n\u003c/span\u003e\u003cspan class=\"gd\"\u003e--- a/src/simplewallet/simplewallet.h\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+++ b/src/simplewallet/simplewallet.h\n\u003c/span\u003e\u003cspan class=\"p\"\u003e@@ -437,8 +437,8 @@\u003c/span\u003e namespace cryptonote\n     std::atomic\u0026lt;bool\u0026gt; m_in_command;\n\n     epee::math_helper::once_a_time_seconds\u0026lt;1\u0026gt; m_inactivity_checker;\n\u003cspan class=\"gd\"\u003e-    epee::math_helper::once_a_time_seconds\u0026lt;90\u0026gt; m_refresh_checker;\n-    epee::math_helper::once_a_time_seconds\u0026lt;90\u0026gt; m_mms_checker;\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+    epee::math_helper::once_a_time_seconds_range\u0026lt;80, 100\u0026gt; m_refresh_checker;\n+    epee::math_helper::once_a_time_seconds_range\u0026lt;90, 110\u0026gt; m_mms_checker;\n\u003c/span\u003e\n     // MMS\n     mms::message_store\u0026amp; get_message_store() const { return m_wallet-\u0026gt;get_message_store(); };\n\ncommit fd7b17251b8da8eba46a4a8c65ebba0892ac3635\n\u003cspan class=\"p\"\u003eAuthor: moneromooo-monero \u0026lt;moneromooo-monero@users.noreply.github.com\u0026gt;\nDate:   Thu Oct 17 12:13:17 2019 +0000\n\u003c/span\u003e\n    epee: allow a random component in once_a_time timeouts\n\ndiff --git a/contrib/epee/include/math_helper.h b/contrib/epee/include/math_helper.h\n\u003cspan class=\"gh\"\u003eindex ddc1f7f4b..3f8e83315 100644\n\u003c/span\u003e\u003cspan class=\"gd\"\u003e--- a/contrib/epee/include/math_helper.h\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+++ b/contrib/epee/include/math_helper.h\n\u003c/span\u003e\u003cspan class=\"p\"\u003e@@ -230,7 +230,7 @@\u003c/span\u003e namespace math_helper\n                }\n\n        }\n\u003cspan class=\"gd\"\u003e-       template\u0026lt;uint64_t scale, int default_interval, bool start_immediate = true\u0026gt;\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+       template\u0026lt;uint64_t scale, int default_interval_min, int default_interval_max, bool start_immediate = true\u0026gt;\n\u003c/span\u003e        class once_a_time\n        {\n     uint64_t get_time() const\n\u003cspan class=\"p\"\u003e@@ -251,12 +251,23 @@\u003c/span\u003e namespace math_helper\n #endif\n     }\n\n+    void set_next_interval()\n\u003cspan class=\"gi\"\u003e+    {\n+      m_interval = m_interval_min;\n+      if (m_interval_max \u0026gt; m_interval_min)\n+      {\n+        const float r = (rand() % 65536) / 65536.f /* never reach 1 */; // good enough ?\n+        m_interval += (m_interval_max - m_interval_min + 1) * r;\n+      }\n+    }\n+\n\u003c/span\u003e        public:\n\u003cspan class=\"gd\"\u003e-               once_a_time():m_interval(default_interval * scale)\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+               once_a_time():m_interval_min(default_interval_min * scale), m_interval_max(default_interval_max * scale)\n\u003c/span\u003e                {\n                        m_last_worked_time = 0;\n       if(!start_immediate)\n         m_last_worked_time = get_time();\n\u003cspan class=\"gi\"\u003e+      set_next_interval();\n\u003c/span\u003e                }\n\n                template\u0026lt;class functor_t\u0026gt;\n\u003cspan class=\"p\"\u003e@@ -268,6 +279,7 @@\u003c/span\u003e namespace math_helper\n                        {\n                                bool res = functr();\n                                m_last_worked_time = get_time();\n\u003cspan class=\"gi\"\u003e+        set_next_interval();\n\u003c/span\u003e                                return res;\n                        }\n                        return true;\n\u003cspan class=\"p\"\u003e@@ -275,6 +287,8 @@\u003c/span\u003e namespace math_helper\n\n        private:\n                uint64_t m_last_worked_time;\n\u003cspan class=\"gi\"\u003e+               uint64_t m_interval_min;\n+               uint64_t m_interval_max;\n\u003c/span\u003e                uint64_t m_interval;\n        };\n\n@@ -282,5 +296,7 @@ namespace math_helper\n   class once_a_time_seconds: public once_a_time\u0026lt;1000000, default_interval, start_immediate\u0026gt; {};\n   template\u0026lt;int default_interval, bool start_immediate = true\u0026gt;\n   class once_a_time_milliseconds: public once_a_time\u0026lt;1000, default_interval, start_immediate\u0026gt; {};\n\u003cspan class=\"gi\"\u003e+  template\u0026lt;int default_interval_min, int default_interval_max, bool start_immediate = true\u0026gt;\n+  class once_a_time_seconds_range: public once_a_time\u0026lt;1000000, default_interval_min, default_interval_max, start_immediate\u0026gt; {};\n\u003c/span\u003e }\n }\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","automated_response":false,"created_at":"2019-10-17T12:24:03.475Z","updated_at":"2019-10-17T12:24:03.475Z","actor":{"username":"moneromooo","cleared":false,"url":"/moneromooo","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":6064121,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Note that the random part is to avoid the \"skipping\" part (which happens if a lock was held, preventing refresh after the sleep) from causing a gap in the schedule which would give away the fact the wallet was being held up (likely by a password prompt).","markdown_message":"\u003cp\u003eNote that the random part is to avoid the \u0026quot;skipping\u0026quot; part (which happens if a lock was held, preventing refresh after the sleep) from causing a gap in the schedule which would give away the fact the wallet was being held up (likely by a password prompt).\u003c/p\u003e\n","automated_response":false,"created_at":"2019-10-17T12:39:58.628Z","updated_at":"2019-10-17T12:39:58.628Z","actor":{"username":"moneromooo","cleared":false,"url":"/moneromooo","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":6066997,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"A disclosure around December 1st sounds good. Thanks","markdown_message":"\u003cp\u003eA disclosure around December 1st sounds good. Thanks\u003c/p\u003e\n","automated_response":false,"created_at":"2019-10-17T17:50:01.676Z","updated_at":"2019-10-17T17:50:01.676Z","actor":{"username":"ftramer","cleared":false,"url":"/ftramer","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6069703,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"One concern with first issuing a fix (with v0.15) and only later issuing a disclosure, is that someone might reverse-engineer the vulnerability and claim credit for it.\nSomething similar happened to us recently when disclosing a vulnerability in Zcash. What helped there, was that Zcash acknowledged that we had disclosed a vulnerability (without giving any further details) when pushing out the fix.\nDo you think you could do the same? I.e., in your release notes for v0.15, could you mention that we found and disclosed some security vulnerabilities that this version fixes?","markdown_message":"\u003cp\u003eOne concern with first issuing a fix (with v0.15) and only later issuing a disclosure, is that someone might reverse-engineer the vulnerability and claim credit for it.\u003cbr\u003e\nSomething similar happened to us recently when disclosing a vulnerability in Zcash. What helped there, was that Zcash acknowledged that we had disclosed a vulnerability (without giving any further details) when pushing out the fix.\u003cbr\u003e\nDo you think you could do the same? I.e., in your release notes for v0.15, could you mention that we found and disclosed some security vulnerabilities that this version fixes?\u003c/p\u003e\n","automated_response":false,"created_at":"2019-10-18T00:33:58.410Z","updated_at":"2019-10-18T00:33:58.410Z","actor":{"username":"ftramer","cleared":false,"url":"/ftramer","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6072605,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"AFAIK this discussion becomes public when disclosed, so your PDF and all the rest serves as proof along with timestamps. Of course it's dependent on a third party not folding :) I think the best is you give us whatever wording you feel appropriate (ie, like an academic citation) to include in the release notes.\n\nBTW, my patches above still leave an opening, albeit one that's detectable by the wallet: the daemon can decide how many blocks to include in a refresh (since some blocks can get huge), so an active attacker may chose to send a series of blocks one by one. Since the wallet does not currently load all it can in parallel (it could, but this is the non trivial change I talked about earlier), it can see when a password gets requested, and thus which block includes an output for the wallet. I will fix it later.","markdown_message":"\u003cp\u003eAFAIK this discussion becomes public when disclosed, so your PDF and all the rest serves as proof along with timestamps. Of course it\u0026#39;s dependent on a third party not folding :) I think the best is you give us whatever wording you feel appropriate (ie, like an academic citation) to include in the release notes.\u003c/p\u003e\n\n\u003cp\u003eBTW, my patches above still leave an opening, albeit one that\u0026#39;s detectable by the wallet: the daemon can decide how many blocks to include in a refresh (since some blocks can get huge), so an active attacker may chose to send a series of blocks one by one. Since the wallet does not currently load all it can in parallel (it could, but this is the non trivial change I talked about earlier), it can see when a password gets requested, and thus which block includes an output for the wallet. I will fix it later.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-10-18T12:38:14.945Z","updated_at":"2019-10-18T12:38:14.945Z","actor":{"username":"moneromooo","cleared":false,"url":"/moneromooo","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":6073292,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"(or not, since it requires the node operator to be the attacker, and you're not supposed to do that in the first place)","markdown_message":"\u003cp\u003e(or not, since it requires the node operator to be the attacker, and you\u0026#39;re not supposed to do that in the first place)\u003c/p\u003e\n","automated_response":false,"created_at":"2019-10-18T13:37:27.543Z","updated_at":"2019-10-18T13:37:27.543Z","actor":{"username":"moneromooo","cleared":false,"url":"/moneromooo","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":6073331,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"I agree that an active attack from a remote node provider is less of a concern ","markdown_message":"\u003cp\u003eI agree that an active attack from a remote node provider is less of a concern \u003c/p\u003e\n","automated_response":false,"created_at":"2019-10-18T13:40:37.220Z","updated_at":"2019-10-18T13:40:37.220Z","actor":{"username":"ftramer","cleared":false,"url":"/ftramer","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6113768,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Hi again @ftramer.\n\nA brief side-note (because it's very pertinent to the issue): although Sekreta/Kovri will be integrated and release-ready by the time of the network upgrade (or shortly thereafter), I wouldn't expect the work to be merged until sometime *after* the network upgrade (so, around the time of the next-next release).\n\nI say this because, after a team discussion, I believe Sekreta (and likely Kovri) will *then* be available for bounty and I would like (and hope) to work with you on similar attacks/issues that Monero will face when supporting various overlay networks.\n\nThank you again for your report. We'll get your bounty sent a.s.a.p.","markdown_message":"\u003cp\u003eHi again \u003ca href=\"/ftramer\"\u003e@ftramer\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eA brief side-note (because it\u0026#39;s very pertinent to the issue): although Sekreta/Kovri will be integrated and release-ready by the time of the network upgrade (or shortly thereafter), I wouldn\u0026#39;t expect the work to be merged until sometime \u003cem\u003eafter\u003c/em\u003e the network upgrade (so, around the time of the next-next release).\u003c/p\u003e\n\n\u003cp\u003eI say this because, after a team discussion, I believe Sekreta (and likely Kovri) will \u003cem\u003ethen\u003c/em\u003e be available for bounty and I would like (and hope) to work with you on similar attacks/issues that Monero will face when supporting various overlay networks.\u003c/p\u003e\n\n\u003cp\u003eThank you again for your report. We\u0026#39;ll get your bounty sent a.s.a.p.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-10-23T06:46:16.734Z","updated_at":"2019-10-23T06:46:16.734Z","actor":{"username":"anonimal","cleared":false,"url":"/anonimal","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/040/857/f23cc3be09a21e17bc43975987c10ba2b6427239_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6116401,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"@ftramer you can just post a SHA256 hash of the PDF as a commitment on Twitter;) Also, after discussion with @moneromooo we were thinking maybe we just merge + release + you disclose at the same time close to release date, rather than waiting for the network upgrade.","markdown_message":"\u003cp\u003e\u003ca href=\"/ftramer\"\u003e@ftramer\u003c/a\u003e you can just post a SHA256 hash of the PDF as a commitment on Twitter;) Also, after discussion with \u003ca href=\"/moneromooo\"\u003e@moneromooo\u003c/a\u003e we were thinking maybe we just merge + release + you disclose at the same time close to release date, rather than waiting for the network upgrade.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-10-23T12:37:11.963Z","updated_at":"2019-10-23T12:37:11.963Z","actor":{"username":"fluffypony","cleared":false,"url":"/fluffypony","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":6140535,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Early November after the release would work for us (I'm traveling until November 1st) so the earliest I'd have a disclosure ready would be a few days after that. ","markdown_message":"\u003cp\u003eEarly November after the release would work for us (I\u0026#39;m traveling until November 1st) so the earliest I\u0026#39;d have a disclosure ready would be a few days after that. \u003c/p\u003e\n","automated_response":false,"created_at":"2019-10-25T18:47:44.769Z","updated_at":"2019-10-25T18:47:44.769Z","actor":{"username":"ftramer","cleared":false,"url":"/ftramer","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6158789,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"@ftramer Awesome. Will you then have a specific date and UTC time that you will disclose? If not, after you're ready in November, maybe a day before your disclosure, could you please click the 'Request Disclosure' button so we can have enough time to write our writeup in tandem with your disclosure (and then we'd disclose this report)?","markdown_message":"\u003cp\u003e\u003ca href=\"/ftramer\"\u003e@ftramer\u003c/a\u003e Awesome. Will you then have a specific date and UTC time that you will disclose? If not, after you\u0026#39;re ready in November, maybe a day before your disclosure, could you please click the \u0026#39;Request Disclosure\u0026#39; button so we can have enough time to write our writeup in tandem with your disclosure (and then we\u0026#39;d disclose this report)?\u003c/p\u003e\n","automated_response":false,"created_at":"2019-10-28T21:42:38.217Z","updated_at":"2019-10-28T21:42:38.217Z","actor":{"username":"anonimal","cleared":false,"url":"/anonimal","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/040/857/f23cc3be09a21e17bc43975987c10ba2b6427239_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6206602,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Yeah I'll keep you posted. Towards the end of the coming week seems reasonable. I'll let you know 1-2 days before.","markdown_message":"\u003cp\u003eYeah I\u0026#39;ll keep you posted. Towards the end of the coming week seems reasonable. I\u0026#39;ll let you know 1-2 days before.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-11-04T01:36:38.617Z","updated_at":"2019-11-04T01:36:38.617Z","actor":{"username":"ftramer","cleared":false,"url":"/ftramer","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6221834,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"The patches were PRed a couple days ago btw.","markdown_message":"\u003cp\u003eThe patches were PRed a couple days ago btw.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-11-05T14:48:19.064Z","updated_at":"2019-11-05T14:48:19.064Z","actor":{"username":"moneromooo","cleared":false,"url":"/moneromooo","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":6221923,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Sent 30 XMR: \u003cc829020c3c7e8b33ea76c8a339c4ea170ea4060d87ee02b53815395778fa6339\u003e","markdown_message":"\u003cp\u003eSent 30 XMR: \u0026lt;c829020c3c7e8b33ea76c8a339c4ea170ea4060d87ee02b53815395778fa6339\u0026gt;\u003c/p\u003e\n","automated_response":false,"created_at":"2019-11-05T15:03:00.008Z","updated_at":"2019-11-05T15:03:00.008Z","actor":{"username":"luigi1111w","cleared":false,"url":"/luigi1111w","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":6225431,"is_internal":false,"editable":false,"type":"Activities::SwagAwarded","message":"","markdown_message":"","automated_response":false,"created_at":"2019-11-05T23:46:14.626Z","updated_at":"2019-11-05T23:46:14.626Z","actor":{"url":"/monero","ibb":false,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/007/731/55634f7fcd917725c7a5771cc6e7c9b4d5fe0c22_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"Monero"}},"reporter":{"username":"ftramer","url":"/ftramer"},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6283043,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Thanks for the generous bounty! And sorry about the slow response.\nWe are planning on releasing our findings this Wednesday November 13th. Please let me know if that works for you. We would of course be grateful if you could acknowledge all of us (Florian Tramèr, Dan Boneh and Kenny Paterson) by name in your own release. Thanks!","markdown_message":"\u003cp\u003eThanks for the generous bounty! And sorry about the slow response.\u003cbr\u003e\nWe are planning on releasing our findings this Wednesday November 13th. Please let me know if that works for you. We would of course be grateful if you could acknowledge all of us (Florian Tramèr, Dan Boneh and Kenny Paterson) by name in your own release. Thanks!\u003c/p\u003e\n","automated_response":false,"created_at":"2019-11-12T00:31:25.096Z","updated_at":"2019-11-12T00:31:25.096Z","actor":{"username":"ftramer","cleared":false,"url":"/ftramer","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6290512,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Attached is the report we are planning to disclose tomorrow. This contains a synthesis of the attacks that we found both in Zcash and in Monero.\nPlease let me know if you have any issues with some of the content. We would like to also share this report with the Zcash security team before making it public.\nAre you okay with us sending this report to Zcash now, and making it public on Wednesday?","markdown_message":"\u003cp\u003eAttached is the report we are planning to disclose tomorrow. This contains a synthesis of the attacks that we found both in Zcash and in Monero.\u003cbr\u003e\nPlease let me know if you have any issues with some of the content. We would like to also share this report with the Zcash security team before making it public.\u003cbr\u003e\nAre you okay with us sending this report to Zcash now, and making it public on Wednesday?\u003c/p\u003e\n","automated_response":false,"created_at":"2019-11-12T17:52:29.568Z","updated_at":"2019-11-12T17:52:29.568Z","actor":{"username":"ftramer","cleared":false,"url":"/ftramer","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"attachments":[{"id":632640,"filename":"main.pdf","type":"application/pdf","url":"https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/yHK9sxYq8Cs5adAKTYtbnkj1?response-content-disposition=attachment%3B%20filename%3D%22main.pdf%22%3B%20filename%2A%3DUTF-8%27%27main.pdf\u0026response-content-type=application%2Fpdf\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\u0026X-Amz-Credential=ASIAQGK6FURQWPKTSU4A%2F20201229%2Fus-west-2%2Fs3%2Faws4_request\u0026X-Amz-Date=20201229T064109Z\u0026X-Amz-Expires=3600\u0026X-Amz-SignedHeaders=host\u0026X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJ7%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCICR3Wbqr3QmaXXF3DerXHfL2hl5mL6uGPxa9bL7HxbeqAiEAqWiWv4fNm1cBuTJbNOPDhjMWyvgVYBMfeqSvL3C%2Br5kqtAMIVhABGgwwMTM2MTkyNzQ4NDkiDLWeuL88FcgTd%2BHDFiqRA7sDjduiUr7yrR1bP0fy3jpTtTXARM3Gr8rkIOStwiuzOpvS67rApjBlyTcg901MzVj81BMqg2D%2FoYR3%2FSoNuwT33h6KUwD255ES%2FPaggNJ05ASpUwzUlVyePLw4P7in3wPJpZgw9N8dZGDgg6RxPAgdRMTCMAdlbL23s9IEA0HQY%2FGrR4AsNah2Xjle%2Beki0NqkG2PIPu3eRj3%2BQqZznd3OfS%2F2sVbcGOtcKdRNfVO%2Bms3UlWm2aPpwFiBKtt5yY1oKJr%2BgD%2BF%2FSQXzNSV67TxIzKIjNEaMGEHoDWRX0O4KOc6rsER7d7YcxMm3LHCy5VXT6QRFyFg%2FG4p8jairmeusKiaAs0jSa4nN2Zw3%2BCVW97Ila6RUU7muvv0d6W%2FYI6MJm443s6INDwS%2F0HX%2Bw8e4TOsebeohnSpFhM2ci9Q8tz6Q72ZmyHoSODXtdcyWxmKZOiWjWtpBmasfdIsQkZzxOUEp9TeB9Eaq72Q8%2BcHbJ%2Fn4cBcE%2FhCkABtaY7%2BW80JUqsSXPlI8vt2z0j%2B7EAZZMJT4qv8FOusB53xj88px4LwwmmUwc4%2B73P1hcJQ5adArgpVyBc%2Fvo2mvPbSXp8aV8B1%2BrfMDWuQn5Unmirx7fguBekXWHMyBRZ5m12xEhEj3mDnu3koQSeJRnoNQdEu1tOplrrLMENBFS6mTQ%2BUUBq1sggQqNoyyQNPVrpOTENkW7e%2FKnl%2FHjjMD5ktvCe3RQAaSXnShU%2FFfKQH%2FQlegKj92VkKfFBzGzGJ0gmEIyc6Fl56gBo43TML6rbL9j9QyU%2FpQpXJOVD4OV4s4%2BALvzzN5PLj4E9A%2Bwmv%2FwIgM8BdxFsm0wGfnWsssx3X6cDoUNw7ldQ%3D%3D\u0026X-Amz-Signature=d1ff4b0d062e8f722f970d549ca9a641600bfe2178dcc5ea9e4b6ea63549ce3c"}],"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6297281,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"BTW, I can't seem to request a disclosure as long as this thread is open. Does this require action on your side?","markdown_message":"\u003cp\u003eBTW, I can\u0026#39;t seem to request a disclosure as long as this thread is open. Does this require action on your side?\u003c/p\u003e\n","automated_response":false,"created_at":"2019-11-13T13:26:37.269Z","updated_at":"2019-11-13T13:26:37.269Z","actor":{"username":"ftramer","cleared":false,"url":"/ftramer","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6300522,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"@ftramer apologies for the slow response, we’re busy finalising a 0.15.0.1 point release. We’ll come back to you shortly on disclosure. Regarding the thread, I think we have to mark it as resolved before disclosure.","markdown_message":"\u003cp\u003e\u003ca href=\"/ftramer\"\u003e@ftramer\u003c/a\u003e apologies for the slow response, we’re busy finalising a 0.15.0.1 point release. We’ll come back to you shortly on disclosure. Regarding the thread, I think we have to mark it as resolved before disclosure.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-11-13T20:03:57.764Z","updated_at":"2019-11-13T20:03:57.764Z","actor":{"username":"fluffypony","cleared":false,"url":"/fluffypony","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":6301474,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"@fluffypony No worries. Just please let me know if it's okay for me to talk publicly about these attacks tomorrow. If you'd rather delay the disclosure a little, I'll talk only about our Zcash results.","markdown_message":"\u003cp\u003e\u003ca href=\"/fluffypony\"\u003e@fluffypony\u003c/a\u003e No worries. Just please let me know if it\u0026#39;s okay for me to talk publicly about these attacks tomorrow. If you\u0026#39;d rather delay the disclosure a little, I\u0026#39;ll talk only about our Zcash results.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-11-13T23:13:54.676Z","updated_at":"2019-11-13T23:13:54.676Z","actor":{"username":"ftramer","cleared":false,"url":"/ftramer","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6307469,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"@ftramer looks like the general consensus is that you can talk publicly about it no problem - the patches are public, and it's fixed in 0.15.0.0 which is released:) Thanks for your patience!","markdown_message":"\u003cp\u003e\u003ca href=\"/ftramer\"\u003e@ftramer\u003c/a\u003e looks like the general consensus is that you can talk publicly about it no problem - the patches are public, and it\u0026#39;s fixed in 0.15.0.0 which is released:) Thanks for your patience!\u003c/p\u003e\n","automated_response":false,"created_at":"2019-11-14T18:07:35.824Z","updated_at":"2019-11-14T18:07:35.824Z","actor":{"username":"fluffypony","cleared":false,"url":"/fluffypony","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":6311612,"is_internal":false,"editable":false,"type":"Activities::BugResolved","message":"","markdown_message":"","automated_response":false,"created_at":"2019-11-15T04:27:41.752Z","updated_at":"2019-11-15T04:27:41.752Z","actor":{"username":"anonimal","cleared":false,"url":"/anonimal","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/040/857/f23cc3be09a21e17bc43975987c10ba2b6427239_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"reporter":{"username":"ftramer","url":"/ftramer"},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6311614,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","markdown_message":"","automated_response":false,"created_at":"2019-11-15T04:28:04.003Z","updated_at":"2019-11-15T04:28:04.003Z","first_to_agree":true,"actor":{"username":"anonimal","cleared":false,"url":"/anonimal","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/040/857/f23cc3be09a21e17bc43975987c10ba2b6427239_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6316614,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Are you planning a public disclosure of these issues beyond this thread? E.g., on your website?\nOur writeup is now available here: https://crypto.stanford.edu/timings/","markdown_message":"\u003cp\u003eAre you planning a public disclosure of these issues beyond this thread? E.g., on your website?\u003cbr\u003e\nOur writeup is now available here: \u003ca title=\"https://crypto.stanford.edu/timings/\" href=\"/redirect?url=https%3A%2F%2Fcrypto.stanford.edu%2Ftimings%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://crypto.stanford.edu/timings/\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/p\u003e\n","automated_response":false,"created_at":"2019-11-15T14:10:27.277Z","updated_at":"2019-11-15T14:10:27.277Z","actor":{"username":"ftramer","cleared":false,"url":"/ftramer","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6316615,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","markdown_message":"","automated_response":false,"created_at":"2019-11-15T14:10:41.694Z","updated_at":"2019-11-15T14:10:41.694Z","actor":{"username":"ftramer","cleared":false,"url":"/ftramer","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6316616,"is_internal":false,"editable":false,"type":"Activities::ReportBecamePublic","message":"","markdown_message":"","automated_response":false,"created_at":"2019-11-15T14:10:41.740Z","updated_at":"2019-11-15T14:10:41.740Z","actor":{"username":"ftramer","cleared":false,"url":"/ftramer","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6319267,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"My interpretation of section IV. 2. c. of the VRP *Release finalized vulnerability announcement on public communications platform (mailing list, reddit, website, or other)* has been to submit summaries to /r/Monero which can be searched for with the **[SECURITY ADVISORY]** tag in the title. But, to answer your question, since I think your group has wonderfully said everything that needs to be said, there shouldn't be a need for us to elaborate further. I think simply linking to your writeup and this report will suffice (along with \"stay calm everyone and simply upgrade\") :)\n\nDoes that work for you?","markdown_message":"\u003cp\u003eMy interpretation of section IV. 2. c. of the VRP \u003cem\u003eRelease finalized vulnerability announcement on public communications platform (mailing list, reddit, website, or other)\u003c/em\u003e has been to submit summaries to /r/Monero which can be searched for with the \u003cstrong\u003e[SECURITY ADVISORY]\u003c/strong\u003e tag in the title. But, to answer your question, since I think your group has wonderfully said everything that needs to be said, there shouldn\u0026#39;t be a need for us to elaborate further. I think simply linking to your writeup and this report will suffice (along with \u0026quot;stay calm everyone and simply upgrade\u0026quot;) :)\u003c/p\u003e\n\n\u003cp\u003eDoes that work for you?\u003c/p\u003e\n","automated_response":false,"created_at":"2019-11-15T19:08:22.023Z","updated_at":"2019-11-15T19:15:33.391Z","actor":{"username":"anonimal","cleared":false,"url":"/anonimal","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/040/857/f23cc3be09a21e17bc43975987c10ba2b6427239_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6320104,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Sounds good! Thanks for the smooth disclosure process. ","markdown_message":"\u003cp\u003eSounds good! Thanks for the smooth disclosure process. \u003c/p\u003e\n","automated_response":false,"created_at":"2019-11-15T21:43:01.230Z","updated_at":"2019-11-15T21:43:01.230Z","actor":{"username":"ftramer","cleared":false,"url":"/ftramer","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6320141,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"One quick note: the release notes on github say that the fixed vulnerabilities only affected deployments with remote nodes. This isn't entirely correct. We do show an attack that applies when the node is local (that's the attack based on lock contention).\nThe attack is a little harder to exploit but we do have a proof of concept for it as well. ","markdown_message":"\u003cp\u003eOne quick note: the release notes on github say that the fixed vulnerabilities only affected deployments with remote nodes. This isn\u0026#39;t entirely correct. We do show an attack that applies when the node is local (that\u0026#39;s the attack based on lock contention).\u003cbr\u003e\nThe attack is a little harder to exploit but we do have a proof of concept for it as well. \u003c/p\u003e\n","automated_response":false,"created_at":"2019-11-15T21:54:18.280Z","updated_at":"2019-11-15T21:54:18.280Z","actor":{"username":"ftramer","cleared":false,"url":"/ftramer","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6341979,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Acknowledged. As @moneromooo has reminded me, AFAICT; the observer doesn't necessarily know why it's locked (could be a wallet refresh, another node requesting blocks, etc.). But, despite any of those assumptions, we believe you're still correct.","markdown_message":"\u003cp\u003eAcknowledged. As \u003ca href=\"/moneromooo\"\u003e@moneromooo\u003c/a\u003e has reminded me, AFAICT; the observer doesn\u0026#39;t necessarily know why it\u0026#39;s locked (could be a wallet refresh, another node requesting blocks, etc.). But, despite any of those assumptions, we believe you\u0026#39;re still correct.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-11-19T01:19:38.906Z","updated_at":"2019-11-19T01:19:38.906Z","actor":{"username":"anonimal","cleared":false,"url":"/anonimal","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/040/857/f23cc3be09a21e17bc43975987c10ba2b6427239_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6341991,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"@ftramer On another note, there's apparently been technical issues regarding the Monero subreddit so I've been forced to release our writeup summary over Twitter and GitHub gist for the time being. Links https://twitter.com/whoisanonimal/status/1196590492978421760 and https://gist.github.com/anonimal/18a2264419c22fab2145e699053e00e8\n\n**Edit:** a trivial correction for one of my above comments: searching r/Monero for **SECURITY ADVISORY** without brackets will show past results, not **[SECURITY ADVISORY]** like I suggested (reddit regexp apparently doesn't like that).\n\nThank you for your patience and understanding.","markdown_message":"\u003cp\u003e\u003ca href=\"/ftramer\"\u003e@ftramer\u003c/a\u003e On another note, there\u0026#39;s apparently been technical issues regarding the Monero subreddit so I\u0026#39;ve been forced to release our writeup summary over Twitter and GitHub gist for the time being. Links \u003ca title=\"https://twitter.com/whoisanonimal/status/1196590492978421760\" href=\"/redirect?url=https%3A%2F%2Ftwitter.com%2Fwhoisanonimal%2Fstatus%2F1196590492978421760\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://twitter.com/whoisanonimal/status/1196590492978421760\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e and \u003ca title=\"https://gist.github.com/anonimal/18a2264419c22fab2145e699053e00e8\" href=\"/redirect?url=https%3A%2F%2Fgist.github.com%2Fanonimal%2F18a2264419c22fab2145e699053e00e8\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://gist.github.com/anonimal/18a2264419c22fab2145e699053e00e8\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eEdit:\u003c/strong\u003e a trivial correction for one of my above comments: searching r/Monero for \u003cstrong\u003eSECURITY ADVISORY\u003c/strong\u003e without brackets will show past results, not \u003cstrong\u003e[SECURITY ADVISORY]\u003c/strong\u003e like I suggested (reddit regexp apparently doesn\u0026#39;t like that).\u003c/p\u003e\n\n\u003cp\u003eThank you for your patience and understanding.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-11-19T01:26:14.817Z","updated_at":"2019-11-19T01:31:38.615Z","actor":{"username":"anonimal","cleared":false,"url":"/anonimal","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/040/857/f23cc3be09a21e17bc43975987c10ba2b6427239_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false}],"activity_page_count":1,"activity_page_number":1,"summaries":[{"category":"team","can_view?":true,"can_create?":false},{"id":18892,"category":"researcher","content":"See https://crypto.stanford.edu/timings/ for a summary and a link to our technical report on these vulnerabilities.","can_view?":true,"can_edit?":false,"content_html":"\u003cp\u003eSee \u003ca title=\"https://crypto.stanford.edu/timings/\" href=\"/redirect?url=https%3A%2F%2Fcrypto.stanford.edu%2Ftimings%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://crypto.stanford.edu/timings/\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e for a summary and a link to our technical report on these vulnerabilities.\u003c/p\u003e\n"}]}