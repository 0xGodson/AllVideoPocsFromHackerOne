{"id":299460,"global_id":"Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8yOTk0NjA=","url":"https://hackerone.com/reports/299460","title":"Fix for self-DoS in Security-txt Chrome Extension.","state":"Closed","substate":"resolved","severity_rating":"low","readable_substate":"Resolved","created_at":"2017-12-19T19:53:35.691Z","submitted_at":"2017-12-19T19:53:35.691Z","is_member_of_team?":false,"reporter":{"disabled":false,"username":"karel_origin","url":"/karel_origin","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/077/693/a209ab3606bc8a68fc577dc38b001c8f66b3d561_original.jpg/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a"},"is_me?":false,"cleared":false,"hackerone_triager":false,"hacker_mediation":false},"team":{"id":24342,"url":"https://hackerone.com/ed","handle":"ed","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/024/342/18764de1df9c5df2781f5975a3c01990e8933dd0_original./3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a","medium":"https://profile-photos.hackerone-user-content.com/variants/000/024/342/18764de1df9c5df2781f5975a3c01990e8933dd0_original./eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"permissions":[],"submission_state":"open","default_currency":"usd","awards_miles":false,"offers_bounties":false,"state":"public_mode","only_cleared_hackers":false,"profile":{"name":"Ed","twitter_handle":"EdOverflow","website":"https://edoverflow.com","about":"This is a vulnerability disclosure program for all of my personal projects and code that I publish."}},"has_bounty?":false,"in_validation?":false,"rejected_anc_report_that_can_be_sent_back_to_anc_triagers?":false,"can_view_team":true,"can_view_report":true,"is_external_bug":false,"is_published":false,"is_participant":false,"stage":4,"public":true,"visibility":"full","cve_ids":[],"singular_disclosure_disabled":false,"disclosed_at":"2017-12-19T20:11:04.415Z","bug_reporter_agreed_on_going_public_at":"2017-12-19T20:08:44.141Z","team_member_agreed_on_going_public_at":"2017-12-19T20:11:04.324Z","comments_closed?":false,"facebook_team?":false,"team_private?":false,"vulnerability_information":"@sp1d3rs found a self-DoS vulnerability in the Security-txt Chrome Extension. He was also kind enough to provide a fix wich you can find on [GitHub](https://github.com/securitytxt/chrome-extension/pull/2). We merged @sp1d3rs' fix when he submitted a PR. We later decided that it was better to stop using XHR and use Fetch instead, a newer API. This was the result:\n\nbackground.js\n========\n~~~diff\n     }\n }\n \n-function getSecuritytxt(domain, protocol, wk, tabid) {\n-    xhr = new XMLHttpRequest;\n-    xhr.open(\"GET\", protocol + domain + wk + 'security.txt');\n-    xhr.timeout = 10000;\n-    xhr.onreadystatechange = function() {\n-        if (xhr.status != 404 \u0026\u0026 xhr.getResponseHeader('content-type').startsWith('text/plain') \u0026\u0026 xhr.responseText.indexOf('Contact:') != -1) {\n-            UpdateStorage('hasSecuritytxt', 'set', domain + ':' + wk);\n-            changeIcon(tabid, true);\n-        } else {\n-            changeIcon(tabid, false);\n-            return false\n+function getSecuritytxt(url, domain, tabid, i, messaged) {\n+    const consume = responseReader =\u003e {\n+    return responseReader.read().then(result =\u003e {\n+        if (result.done || chunks == 1) { return; }\n+        const chunk = result.value;\n+        chunks++\n+\n+        if(chunk.length \u003e 500){\n+            UpdateStorage(\"blacklist\", \"add\", domain)\n+            setTimeout(function(){chrome.runtime.reload()}, 2000)\n+            console.warn(\"Detected a large security.txt file, reloading the extension and blacklisting the domain.\")\n+        }\n+\n+        if (new TextDecoder(\"utf-8\").decode(chunk).indexOf(\"Contact:\") \u003e -1) {\n+            response_string = new TextDecoder(\"utf-8\").decode(chunk)\n+        }\n+\n+        if (typeof messaged == \"undefined\"){\n+            if (typeof response_string != \"undefined\") {\n+                changeIcon(tabid, true)\n+                obj = new Object; obj[domain] = locations[i]\n+                UpdateStorage(\"hasSecuritytxt\", \"set\", obj)\n+            } else if(i == locations.length - 1) {\n+                changeIcon(tabid, false)\n+            }\n+        }else{\n+            chrome.runtime.sendMessage({\"content\": response_string})\n         }\n-    };\n-    xhr.send();\n+\n+        return consume(responseReader);\n+        });\n+    }\n+    if(storage.blacklist.indexOf(domain) == -1) {\n+        fetch(url).then(response =\u003e {\n+            chunks = 0\n+            if (response.status == 200 \u0026\u0026 response.headers.get(\"content-type\").indexOf(\"text/plain\") \u003e -1 \u0026\u0026 response.redirected == false) {\n+                setTimeout(function(){return consume(response.body.getReader())}, 200)\n+            } else {\n+                changeIcon(tabid, false)\n+            }\n+        }\n+    )}\n }\n \n function UpdateStorage(path, action, value) {\n     chrome.storage.local.get(function(callback) {\n         storage = callback;\n         if (Object.keys(storage).length == 0) {\n             chrome.storage.local.set({\n-                \"hasSecuritytxt\": [],\n-                \"location\": []\n+                \"hasSecuritytxt\": {},\n+                \"blacklist\": []\n             })\n         };\n-        if (path == 'hasSecuritytxt') {\n-            if (action == 'set' \u0026\u0026 storage.hasSecuritytxt.indexOf(value.split(':')[0]) \u003c 0) {\n-                storage.hasSecuritytxt.push(value.split(':')[0]);\n-                storage.location.push(value.split(':')[1])\n+        if (path == \"hasSecuritytxt\") {\n+            if(action == \"set\") {\n+                storage.hasSecuritytxt[Object.keys(value)[0]] = value[Object.keys(value)[0]]\n             }\n-        };\n+        }else if (path == \"blacklist\") {\n+            if (action == \"add\") {\n+                storage.blacklist.push(value)\n+            }\n+        }\n         chrome.storage.local.set(storage);\n     })\n }\n \n chrome.runtime.onMessage.addListener(function(message, sender, response) {\n-    if (message.securityTxt != undefined \u0026\u0026 message.securityTxt) {\n-        if (getSecuritytxt(message.securityTxt[0].domain, message.securityTxt[0].protocol, \"/\", sender.tab.id) == false) {\n-            getSecuritytxt(message.securityTxt[0].domain, message.securityTxt[0].protocol, \"/.well-known/\", sender.tab.id)\n+    locations = [\"/security.txt\", \"/.well-known/security.txt\"]\n+    if (message.securityTxt != undefined \u0026\u0026 message.securityTxt.popup == undefined) {\n+        for(i = 0; i \u003c locations.length; i++) {\n+            getSecuritytxt(message.securityTxt.root.concat(locations[i]), message.securityTxt.root.split('/')[2], sender.tab.id, i)\n+        }\n+    }else if (message.securityTxt != undefined \u0026\u0026 message.securityTxt.popup) {\n+        for(i = 0; i \u003c locations.length; i++) {\n+            getSecuritytxt(message.securityTxt.root.concat(locations[i]), message.securityTxt.root.split('/')[2], null, i, true)\n         }\n     }\n })\n \n chrome.storage.onChanged.addListener(function() {\n     UpdateStorage()\n });\n-UpdateStorage();\n+\n+UpdateStorage(); \n~~~\n\nLet me explain everything a bit more for those of you who don't know/understand JavaScript very well (you really should learn it! :)). XHR is the root cause of this issue because of the way it handles responses. \n\nNew features in the Fetch API:\n\u003eWe are now able to buffer data as it comes in, and we don’t have to wait until it’s all there. Streaming the response body improves the site’s memory usage and gives a greater perception of speed when trying to show content over slow connections. In XHR, the whole response would be buffered, rather than being able to operate on the data in chunks.\n\nSource: [blogs.windows.com](https://blogs.windows.com/msedgedev/2016/05/24/fetch-and-xhr-limitations/)\n\nThe buffering of XHR requires a lot of the available system resources, especially on lower-end PCs/laptops, potentially causing crashes with large files. You can see how I'm reading the data chunk-by-chunk in the `getSecuritytxt` function.\n\n```\nfunction getSecuritytxt(url, domain, tabid, i, messaged) {\n    const consume = responseReader =\u003e {\n    return responseReader.read().then(result =\u003e {\n        //Only handle the first chunk.\n        if (result.done || chunks == 1) { return; }\n        const chunk = result.value;\n        chunks++\n        //Reload the extension if the chunk is larger than 500 bytes and blacklist the domain.\n        if(chunk.length \u003e 500){\n            UpdateStorage(\"blacklist\", \"add\", domain)\n            setTimeout(function(){chrome.runtime.reload()}, 2000)\n            console.warn(\"Detected a large security.txt file, reloading the extension and blacklisting the domain.\")\n        }\n        //Convert the Uint8Array to a string.\n        if (new TextDecoder(\"utf-8\").decode(chunk).indexOf(\"Contact:\") \u003e -1) {\n            response_string = new TextDecoder(\"utf-8\").decode(chunk)\n        }\n\n        if (typeof messaged == \"undefined\"){\n            if (typeof response_string != \"undefined\") {\n                changeIcon(tabid, true)\n                obj = new Object; obj[domain] = locations[i]\n                UpdateStorage(\"hasSecuritytxt\", \"set\", obj)\n            } else if(i == locations.length - 1) {\n                changeIcon(tabid, false)\n            }\n        }else{\n            chrome.runtime.sendMessage({\"content\": response_string})\n        }\n...\n```\n\n`if (result.done || chunks == 1) { return; }` makes sure that we only handle one chunk, because one chunk will be big enough for the entire security.txt file.\n\n```\nif(chunk.length \u003e 500){\n     UpdateStorage(\"blacklist\", \"add\", domain)\n     setTimeout(function(){chrome.runtime.reload()}, 2000)\n     console.warn(\"Detected a large security.txt file, reloading the extension and blacklisting the domain.\")\n }\n```\nThis will check if the chunk is larger than 500 bytes, it will also add it to a blacklist if it is. I used `chrome.runtime.reload()` because at this moment, there's no way to cancel a Fetch request in Chrome, only in FireFox and Edge, so I'm reloading the entire extension to cancel it which seems to work fine. Otherwise, the request will just keep on going, even if I'm not doing anything with the received data.\n\n```\nif (typeof messaged == \"undefined\"){\n     if (typeof response_string != \"undefined\") {\n          changeIcon(tabid, true)\n          obj = new Object; obj[domain] = locations[i]\n          UpdateStorage(\"hasSecuritytxt\", \"set\", obj)\n      } else if(i == locations.length - 1) {\n          changeIcon(tabid, false)\n      }\n} else {\n    chrome.runtime.sendMessage({\"content\": response_string})\n}\n```\n\nThis saves the domain to a list of domains with security.txt files, if it is valid, and passes the contents of the file to the extension popup (the window you see after clicking on an extension's icon).\n\nThe changes made to content.js and popup.js aren't required to fix this issue, but they are required for the extension to function correctly after implementing the fix.\n\nThank you @sp1d3rs for reporting this issue, and helping me fix it. Also thanks to @edio (@edoverflow) for his kind words and compliments. :)\n\nI hope that this motivates others to test this extension and look at Ed's program\nHappy hacking!\n\n~ Karel.\n\n## Impact\n\n.","vulnerability_information_html":"\u003cp\u003e\u003ca href=\"/sp1d3rs\"\u003e@sp1d3rs\u003c/a\u003e found a self-DoS vulnerability in the Security-txt Chrome Extension. He was also kind enough to provide a fix wich you can find on \u003ca href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fsecuritytxt%2Fchrome-extension%2Fpull%2F2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003eGitHub\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e. We merged \u003ca href=\"/sp1d3rs\"\u003e@sp1d3rs\u003c/a\u003e\u0026#39; fix when he submitted a PR. We later decided that it was better to stop using XHR and use Fetch instead, a newer API. This was the result:\u003c/p\u003e\n\n\u003ch1 id=\"background-js\"\u003ebackground.js\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight diff\"\u003e\u003ccode\u003e     }\n }\n\n-function getSecuritytxt(domain, protocol, wk, tabid) {\n\u003cspan class=\"gd\"\u003e-    xhr = new XMLHttpRequest;\n-    xhr.open(\u0026quot;GET\u0026quot;, protocol + domain + wk + \u0026#39;security.txt\u0026#39;);\n-    xhr.timeout = 10000;\n-    xhr.onreadystatechange = function() {\n-        if (xhr.status != 404 \u0026amp;\u0026amp; xhr.getResponseHeader(\u0026#39;content-type\u0026#39;).startsWith(\u0026#39;text/plain\u0026#39;) \u0026amp;\u0026amp; xhr.responseText.indexOf(\u0026#39;Contact:\u0026#39;) != -1) {\n-            UpdateStorage(\u0026#39;hasSecuritytxt\u0026#39;, \u0026#39;set\u0026#39;, domain + \u0026#39;:\u0026#39; + wk);\n-            changeIcon(tabid, true);\n-        } else {\n-            changeIcon(tabid, false);\n-            return false\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+function getSecuritytxt(url, domain, tabid, i, messaged) {\n+    const consume = responseReader =\u0026gt; {\n+    return responseReader.read().then(result =\u0026gt; {\n+        if (result.done || chunks == 1) { return; }\n+        const chunk = result.value;\n+        chunks++\n+\n+        if(chunk.length \u0026gt; 500){\n+            UpdateStorage(\u0026quot;blacklist\u0026quot;, \u0026quot;add\u0026quot;, domain)\n+            setTimeout(function(){chrome.runtime.reload()}, 2000)\n+            console.warn(\u0026quot;Detected a large security.txt file, reloading the extension and blacklisting the domain.\u0026quot;)\n+        }\n+\n+        if (new TextDecoder(\u0026quot;utf-8\u0026quot;).decode(chunk).indexOf(\u0026quot;Contact:\u0026quot;) \u0026gt; -1) {\n+            response_string = new TextDecoder(\u0026quot;utf-8\u0026quot;).decode(chunk)\n+        }\n+\n+        if (typeof messaged == \u0026quot;undefined\u0026quot;){\n+            if (typeof response_string != \u0026quot;undefined\u0026quot;) {\n+                changeIcon(tabid, true)\n+                obj = new Object; obj[domain] = locations[i]\n+                UpdateStorage(\u0026quot;hasSecuritytxt\u0026quot;, \u0026quot;set\u0026quot;, obj)\n+            } else if(i == locations.length - 1) {\n+                changeIcon(tabid, false)\n+            }\n+        }else{\n+            chrome.runtime.sendMessage({\u0026quot;content\u0026quot;: response_string})\n\u003c/span\u003e         }\n\u003cspan class=\"gd\"\u003e-    };\n-    xhr.send();\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+\n+        return consume(responseReader);\n+        });\n+    }\n+    if(storage.blacklist.indexOf(domain) == -1) {\n+        fetch(url).then(response =\u0026gt; {\n+            chunks = 0\n+            if (response.status == 200 \u0026amp;\u0026amp; response.headers.get(\u0026quot;content-type\u0026quot;).indexOf(\u0026quot;text/plain\u0026quot;) \u0026gt; -1 \u0026amp;\u0026amp; response.redirected == false) {\n+                setTimeout(function(){return consume(response.body.getReader())}, 200)\n+            } else {\n+                changeIcon(tabid, false)\n+            }\n+        }\n+    )}\n\u003c/span\u003e }\n\n function UpdateStorage(path, action, value) {\n     chrome.storage.local.get(function(callback) {\n         storage = callback;\n         if (Object.keys(storage).length == 0) {\n             chrome.storage.local.set({\n\u003cspan class=\"gd\"\u003e-                \u0026quot;hasSecuritytxt\u0026quot;: [],\n-                \u0026quot;location\u0026quot;: []\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+                \u0026quot;hasSecuritytxt\u0026quot;: {},\n+                \u0026quot;blacklist\u0026quot;: []\n\u003c/span\u003e             })\n         };\n\u003cspan class=\"gd\"\u003e-        if (path == \u0026#39;hasSecuritytxt\u0026#39;) {\n-            if (action == \u0026#39;set\u0026#39; \u0026amp;\u0026amp; storage.hasSecuritytxt.indexOf(value.split(\u0026#39;:\u0026#39;)[0]) \u0026lt; 0) {\n-                storage.hasSecuritytxt.push(value.split(\u0026#39;:\u0026#39;)[0]);\n-                storage.location.push(value.split(\u0026#39;:\u0026#39;)[1])\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+        if (path == \u0026quot;hasSecuritytxt\u0026quot;) {\n+            if(action == \u0026quot;set\u0026quot;) {\n+                storage.hasSecuritytxt[Object.keys(value)[0]] = value[Object.keys(value)[0]]\n\u003c/span\u003e             }\n\u003cspan class=\"gd\"\u003e-        };\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+        }else if (path == \u0026quot;blacklist\u0026quot;) {\n+            if (action == \u0026quot;add\u0026quot;) {\n+                storage.blacklist.push(value)\n+            }\n+        }\n\u003c/span\u003e         chrome.storage.local.set(storage);\n     })\n }\n\n chrome.runtime.onMessage.addListener(function(message, sender, response) {\n\u003cspan class=\"gd\"\u003e-    if (message.securityTxt != undefined \u0026amp;\u0026amp; message.securityTxt) {\n-        if (getSecuritytxt(message.securityTxt[0].domain, message.securityTxt[0].protocol, \u0026quot;/\u0026quot;, sender.tab.id) == false) {\n-            getSecuritytxt(message.securityTxt[0].domain, message.securityTxt[0].protocol, \u0026quot;/.well-known/\u0026quot;, sender.tab.id)\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+    locations = [\u0026quot;/security.txt\u0026quot;, \u0026quot;/.well-known/security.txt\u0026quot;]\n+    if (message.securityTxt != undefined \u0026amp;\u0026amp; message.securityTxt.popup == undefined) {\n+        for(i = 0; i \u0026lt; locations.length; i++) {\n+            getSecuritytxt(message.securityTxt.root.concat(locations[i]), message.securityTxt.root.split(\u0026#39;/\u0026#39;)[2], sender.tab.id, i)\n+        }\n+    }else if (message.securityTxt != undefined \u0026amp;\u0026amp; message.securityTxt.popup) {\n+        for(i = 0; i \u0026lt; locations.length; i++) {\n+            getSecuritytxt(message.securityTxt.root.concat(locations[i]), message.securityTxt.root.split(\u0026#39;/\u0026#39;)[2], null, i, true)\n\u003c/span\u003e         }\n     }\n })\n\n chrome.storage.onChanged.addListener(function() {\n     UpdateStorage()\n });\n\u003cspan class=\"gd\"\u003e-UpdateStorage();\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+\n+UpdateStorage(); \n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eLet me explain everything a bit more for those of you who don\u0026#39;t know/understand JavaScript very well (you really should learn it! :)). XHR is the root cause of this issue because of the way it handles responses. \u003c/p\u003e\n\n\u003cp\u003eNew features in the Fetch API:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eWe are now able to buffer data as it comes in, and we don’t have to wait until it’s all there. Streaming the response body improves the site’s memory usage and gives a greater perception of speed when trying to show content over slow connections. In XHR, the whole response would be buffered, rather than being able to operate on the data in chunks.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eSource: \u003ca href=\"/redirect?url=https%3A%2F%2Fblogs.windows.com%2Fmsedgedev%2F2016%2F05%2F24%2Ffetch-and-xhr-limitations%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003eblogs.windows.com\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eThe buffering of XHR requires a lot of the available system resources, especially on lower-end PCs/laptops, potentially causing crashes with large files. You can see how I\u0026#39;m reading the data chunk-by-chunk in the \u003ccode\u003egetSecuritytxt\u003c/code\u003e function.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003efunction getSecuritytxt(url, domain, tabid, i, messaged) {\n    const consume = responseReader =\u0026gt; {\n    return responseReader.read().then(result =\u0026gt; {\n        //Only handle the first chunk.\n        if (result.done || chunks == 1) { return; }\n        const chunk = result.value;\n        chunks++\n        //Reload the extension if the chunk is larger than 500 bytes and blacklist the domain.\n        if(chunk.length \u0026gt; 500){\n            UpdateStorage(\u0026quot;blacklist\u0026quot;, \u0026quot;add\u0026quot;, domain)\n            setTimeout(function(){chrome.runtime.reload()}, 2000)\n            console.warn(\u0026quot;Detected a large security.txt file, reloading the extension and blacklisting the domain.\u0026quot;)\n        }\n        //Convert the Uint8Array to a string.\n        if (new TextDecoder(\u0026quot;utf-8\u0026quot;).decode(chunk).indexOf(\u0026quot;Contact:\u0026quot;) \u0026gt; -1) {\n            response_string = new TextDecoder(\u0026quot;utf-8\u0026quot;).decode(chunk)\n        }\n\n        if (typeof messaged == \u0026quot;undefined\u0026quot;){\n            if (typeof response_string != \u0026quot;undefined\u0026quot;) {\n                changeIcon(tabid, true)\n                obj = new Object; obj[domain] = locations[i]\n                UpdateStorage(\u0026quot;hasSecuritytxt\u0026quot;, \u0026quot;set\u0026quot;, obj)\n            } else if(i == locations.length - 1) {\n                changeIcon(tabid, false)\n            }\n        }else{\n            chrome.runtime.sendMessage({\u0026quot;content\u0026quot;: response_string})\n        }\n...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e\u003ccode\u003eif (result.done || chunks == 1) { return; }\u003c/code\u003e makes sure that we only handle one chunk, because one chunk will be big enough for the entire security.txt file.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003eif(chunk.length \u0026gt; 500){\n     UpdateStorage(\u0026quot;blacklist\u0026quot;, \u0026quot;add\u0026quot;, domain)\n     setTimeout(function(){chrome.runtime.reload()}, 2000)\n     console.warn(\u0026quot;Detected a large security.txt file, reloading the extension and blacklisting the domain.\u0026quot;)\n }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis will check if the chunk is larger than 500 bytes, it will also add it to a blacklist if it is. I used \u003ccode\u003echrome.runtime.reload()\u003c/code\u003e because at this moment, there\u0026#39;s no way to cancel a Fetch request in Chrome, only in FireFox and Edge, so I\u0026#39;m reloading the entire extension to cancel it which seems to work fine. Otherwise, the request will just keep on going, even if I\u0026#39;m not doing anything with the received data.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003eif (typeof messaged == \u0026quot;undefined\u0026quot;){\n     if (typeof response_string != \u0026quot;undefined\u0026quot;) {\n          changeIcon(tabid, true)\n          obj = new Object; obj[domain] = locations[i]\n          UpdateStorage(\u0026quot;hasSecuritytxt\u0026quot;, \u0026quot;set\u0026quot;, obj)\n      } else if(i == locations.length - 1) {\n          changeIcon(tabid, false)\n      }\n} else {\n    chrome.runtime.sendMessage({\u0026quot;content\u0026quot;: response_string})\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis saves the domain to a list of domains with security.txt files, if it is valid, and passes the contents of the file to the extension popup (the window you see after clicking on an extension\u0026#39;s icon).\u003c/p\u003e\n\n\u003cp\u003eThe changes made to content.js and popup.js aren\u0026#39;t required to fix this issue, but they are required for the extension to function correctly after implementing the fix.\u003c/p\u003e\n\n\u003cp\u003eThank you \u003ca href=\"/sp1d3rs\"\u003e@sp1d3rs\u003c/a\u003e for reporting this issue, and helping me fix it. Also thanks to \u003ca href=\"/edio\"\u003e@edio\u003c/a\u003e (@edoverflow) for his kind words and compliments. :)\u003c/p\u003e\n\n\u003cp\u003eI hope that this motivates others to test this extension and look at Ed\u0026#39;s program\u003cbr\u003e\nHappy hacking!\u003c/p\u003e\n\n\u003cp\u003e~ Karel.\u003c/p\u003e\n\n\u003ch2 id=\"impact\"\u003eImpact\u003c/h2\u003e\n\n\u003cp\u003e.\u003c/p\u003e\n","weakness":{"id":48,"name":"Denial of Service"},"original_report_id":null,"original_report_url":null,"attachments":[],"allow_singular_disclosure_at":"2018-01-18T20:08:44.200Z","allow_singular_disclosure_after":-92913571.58715892,"singular_disclosure_allowed":true,"vote_count":9,"voters":["edoverflow","asad0x01_","eveeez","khalidamin","vulnh0lic","cr4xerbik4sh","japz","paglababa0365","spetr0x"],"severity":{"rating":"low","author_type":"User"},"structured_scope":null,"abilities":{"assignable_team_members":[],"assignable_team_member_groups":[]},"can_edit_custom_fields_attributes":false,"activities":[{"id":2236045,"is_internal":false,"editable":false,"type":"Activities::BugTriaged","message":"Wonderful; thank you for the fix, @karel_origin!","markdown_message":"\u003cp\u003eWonderful; thank you for the fix, \u003ca href=\"/karel_origin\"\u003e@karel_origin\u003c/a\u003e!\u003c/p\u003e\n","automated_response":false,"created_at":"2017-12-19T20:02:07.316Z","updated_at":"2017-12-19T20:02:07.316Z","actor":{"username":"edoverflow","cleared":true,"url":"/edoverflow","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/116/374/9a3cf4d62b2f507a0d33808aacbad863ec4455ac_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ed","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":2236047,"is_internal":false,"editable":false,"type":"Activities::BugResolved","message":"","markdown_message":"","automated_response":false,"created_at":"2017-12-19T20:02:18.744Z","updated_at":"2017-12-19T20:02:18.744Z","actor":{"username":"edoverflow","cleared":true,"url":"/edoverflow","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/116/374/9a3cf4d62b2f507a0d33808aacbad863ec4455ac_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"reporter":{"username":"karel_origin","url":"/karel_origin"},"genius_execution_id":null,"team_handle":"ed","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":2236067,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","markdown_message":"","automated_response":false,"created_at":"2017-12-19T20:08:44.170Z","updated_at":"2017-12-19T20:08:44.170Z","first_to_agree":true,"actor":{"username":"karel_origin","cleared":false,"url":"/karel_origin","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/077/693/a209ab3606bc8a68fc577dc38b001c8f66b3d561_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ed","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":2236075,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"Let's show the world your amazing work!\n\n{F248190}","markdown_message":"\u003cp\u003eLet\u0026#39;s show the world your amazing work!\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"markdown-attachment-link markdown-attachment-inline-reference\" data-attachment-filename=\"200.gif\" data-attachment-link=\"https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/000/248/190/b0f57dcf07299643973d9afdadeef08335bb6671/200.gif?response-content-disposition=attachment%3B%20filename%3D%22200.gif%22%3B%20filename%2A%3DUTF-8%27%27200.gif\u0026amp;response-content-type=image%2Fgif\u0026amp;X-Amz-Algorithm=AWS4-HMAC-SHA256\u0026amp;X-Amz-Credential=ASIAQGK6FURQWS7SVX5C%2F20201229%2Fus-west-2%2Fs3%2Faws4_request\u0026amp;X-Amz-Date=20201229T052815Z\u0026amp;X-Amz-Expires=3600\u0026amp;X-Amz-SignedHeaders=host\u0026amp;X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJv%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCICTltBX5kZS78yzw3IUUt%2Fa035OzgQ2vLu8U1ZxOKGilAiEAqT8jxmclsgLwaEL5fi7C70iqLwP7J3SWF5ypfn%2Fn%2BdUqtAMIVBABGgwwMTM2MTkyNzQ4NDkiDGRWkSc4Hmgq8mMXKCqRA0Pq%2Bzgh6dptjyRB4GzYO9sir45RVm0RyvFSB8lDBYTBiDIVL0nR3Ah5epkHqGDZZEh0G%2BfKYu%2FWpfgxJl7qllLzKg%2BOA0izVs9KPgQdxk0VWwW%2FPKL2ZT4v%2FSNRvF7rPUbZ7WhGTZqx0%2BinzKM%2BO6lDyXZKNKMzhjRnIFdI7Th01c4ma39imTXQDmxc%2FNzHFK40lrkAbTZoTlcq%2BsnIcIRSB0h4GHasXhR5OHx8rifULR7sVKHDcZMCzSYjrtagaKs9I81LEzlSbEGxIQar2MK%2BZBwmpT57aT%2F1nIOoa%2FlH5nfP4Ihcv4Mqfp19pFx8mlVoMe%2FTEx0pqNuC4lGQXowSDJKBcSjrYM6ouddZWfwY6R4O8X69XqZawGSrmBiXyAVG%2BDj895xbDJhiOXMvqkvSfsEzIfvcaHAzshzNZjFT3yiN4h81wfUF3QuLc6DHCTt1MPDYiUB8I7UCQ8wJxW4pg3xTnHqSwUeqww3YY8RFfsgvfp9PzGJ1s4vReFrzuzYVanpT22oz4w33z29yMPmMMO21qv8FOusBOsYr4rmEPt9wYTc2WNI63vM9u2VUhGNHafH2%2Fh3q6i%2BwJ0u2HLCQd44aqHfWZ%2Bc8hzInEQnRNrZf7owYuE4cHiraWaOsNJjfOEJBZu5nzzun4JSk7801NfOqa1zcgLMWOwyWJCtalb9fGn6qhwTWTBMzsOFHc661yyW%2FaqejCIRf6%2BwNOGhO8kc%2BEhEIq0iydp5k4rlMRKlFJPFlphrQYGeZgYr9TM%2FVgHlN%2Bx4Oxtcg1UwCGXMGiV%2BqXzeMEmO%2FdxKETdJJvF%2BEaJSsF0r1i7s8g61czrgyi9MKMpia%2Fg6ovVFkrvHOejV96g%3D%3D\u0026amp;X-Amz-Signature=64878327d4209c7a3de7646e4b440abc5e6d148908917236aac6c645503c9538\" data-attachment-type=\"image/gif\"\u003e\u003cimg src=\"https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/000/248/190/b0f57dcf07299643973d9afdadeef08335bb6671/200.gif?response-content-disposition=attachment%3B%20filename%3D%22200.gif%22%3B%20filename%2A%3DUTF-8%27%27200.gif\u0026amp;response-content-type=image%2Fgif\u0026amp;X-Amz-Algorithm=AWS4-HMAC-SHA256\u0026amp;X-Amz-Credential=ASIAQGK6FURQWS7SVX5C%2F20201229%2Fus-west-2%2Fs3%2Faws4_request\u0026amp;X-Amz-Date=20201229T052815Z\u0026amp;X-Amz-Expires=3600\u0026amp;X-Amz-SignedHeaders=host\u0026amp;X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJv%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCICTltBX5kZS78yzw3IUUt%2Fa035OzgQ2vLu8U1ZxOKGilAiEAqT8jxmclsgLwaEL5fi7C70iqLwP7J3SWF5ypfn%2Fn%2BdUqtAMIVBABGgwwMTM2MTkyNzQ4NDkiDGRWkSc4Hmgq8mMXKCqRA0Pq%2Bzgh6dptjyRB4GzYO9sir45RVm0RyvFSB8lDBYTBiDIVL0nR3Ah5epkHqGDZZEh0G%2BfKYu%2FWpfgxJl7qllLzKg%2BOA0izVs9KPgQdxk0VWwW%2FPKL2ZT4v%2FSNRvF7rPUbZ7WhGTZqx0%2BinzKM%2BO6lDyXZKNKMzhjRnIFdI7Th01c4ma39imTXQDmxc%2FNzHFK40lrkAbTZoTlcq%2BsnIcIRSB0h4GHasXhR5OHx8rifULR7sVKHDcZMCzSYjrtagaKs9I81LEzlSbEGxIQar2MK%2BZBwmpT57aT%2F1nIOoa%2FlH5nfP4Ihcv4Mqfp19pFx8mlVoMe%2FTEx0pqNuC4lGQXowSDJKBcSjrYM6ouddZWfwY6R4O8X69XqZawGSrmBiXyAVG%2BDj895xbDJhiOXMvqkvSfsEzIfvcaHAzshzNZjFT3yiN4h81wfUF3QuLc6DHCTt1MPDYiUB8I7UCQ8wJxW4pg3xTnHqSwUeqww3YY8RFfsgvfp9PzGJ1s4vReFrzuzYVanpT22oz4w33z29yMPmMMO21qv8FOusBOsYr4rmEPt9wYTc2WNI63vM9u2VUhGNHafH2%2Fh3q6i%2BwJ0u2HLCQd44aqHfWZ%2Bc8hzInEQnRNrZf7owYuE4cHiraWaOsNJjfOEJBZu5nzzun4JSk7801NfOqa1zcgLMWOwyWJCtalb9fGn6qhwTWTBMzsOFHc661yyW%2FaqejCIRf6%2BwNOGhO8kc%2BEhEIq0iydp5k4rlMRKlFJPFlphrQYGeZgYr9TM%2FVgHlN%2Bx4Oxtcg1UwCGXMGiV%2BqXzeMEmO%2FdxKETdJJvF%2BEaJSsF0r1i7s8g61czrgyi9MKMpia%2Fg6ovVFkrvHOejV96g%3D%3D\u0026amp;X-Amz-Signature=64878327d4209c7a3de7646e4b440abc5e6d148908917236aac6c645503c9538\" class=\"markdown-inline-image\" style=\"display: inline-block\"\u003e\u003c/a\u003e\u003c/p\u003e\n","automated_response":false,"created_at":"2017-12-19T20:11:04.353Z","updated_at":"2017-12-19T20:11:04.353Z","actor":{"username":"edoverflow","cleared":true,"url":"/edoverflow","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/116/374/9a3cf4d62b2f507a0d33808aacbad863ec4455ac_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"attachments":[{"id":248190,"filename":"200.gif","type":"image/gif","url":"https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/000/248/190/b0f57dcf07299643973d9afdadeef08335bb6671/200.gif?response-content-disposition=attachment%3B%20filename%3D%22200.gif%22%3B%20filename%2A%3DUTF-8%27%27200.gif\u0026response-content-type=image%2Fgif\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\u0026X-Amz-Credential=ASIAQGK6FURQWS7SVX5C%2F20201229%2Fus-west-2%2Fs3%2Faws4_request\u0026X-Amz-Date=20201229T052815Z\u0026X-Amz-Expires=3600\u0026X-Amz-SignedHeaders=host\u0026X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJv%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCICTltBX5kZS78yzw3IUUt%2Fa035OzgQ2vLu8U1ZxOKGilAiEAqT8jxmclsgLwaEL5fi7C70iqLwP7J3SWF5ypfn%2Fn%2BdUqtAMIVBABGgwwMTM2MTkyNzQ4NDkiDGRWkSc4Hmgq8mMXKCqRA0Pq%2Bzgh6dptjyRB4GzYO9sir45RVm0RyvFSB8lDBYTBiDIVL0nR3Ah5epkHqGDZZEh0G%2BfKYu%2FWpfgxJl7qllLzKg%2BOA0izVs9KPgQdxk0VWwW%2FPKL2ZT4v%2FSNRvF7rPUbZ7WhGTZqx0%2BinzKM%2BO6lDyXZKNKMzhjRnIFdI7Th01c4ma39imTXQDmxc%2FNzHFK40lrkAbTZoTlcq%2BsnIcIRSB0h4GHasXhR5OHx8rifULR7sVKHDcZMCzSYjrtagaKs9I81LEzlSbEGxIQar2MK%2BZBwmpT57aT%2F1nIOoa%2FlH5nfP4Ihcv4Mqfp19pFx8mlVoMe%2FTEx0pqNuC4lGQXowSDJKBcSjrYM6ouddZWfwY6R4O8X69XqZawGSrmBiXyAVG%2BDj895xbDJhiOXMvqkvSfsEzIfvcaHAzshzNZjFT3yiN4h81wfUF3QuLc6DHCTt1MPDYiUB8I7UCQ8wJxW4pg3xTnHqSwUeqww3YY8RFfsgvfp9PzGJ1s4vReFrzuzYVanpT22oz4w33z29yMPmMMO21qv8FOusBOsYr4rmEPt9wYTc2WNI63vM9u2VUhGNHafH2%2Fh3q6i%2BwJ0u2HLCQd44aqHfWZ%2Bc8hzInEQnRNrZf7owYuE4cHiraWaOsNJjfOEJBZu5nzzun4JSk7801NfOqa1zcgLMWOwyWJCtalb9fGn6qhwTWTBMzsOFHc661yyW%2FaqejCIRf6%2BwNOGhO8kc%2BEhEIq0iydp5k4rlMRKlFJPFlphrQYGeZgYr9TM%2FVgHlN%2Bx4Oxtcg1UwCGXMGiV%2BqXzeMEmO%2FdxKETdJJvF%2BEaJSsF0r1i7s8g61czrgyi9MKMpia%2Fg6ovVFkrvHOejV96g%3D%3D\u0026X-Amz-Signature=64878327d4209c7a3de7646e4b440abc5e6d148908917236aac6c645503c9538"}],"genius_execution_id":null,"team_handle":"ed","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":2236076,"is_internal":false,"editable":false,"type":"Activities::ReportBecamePublic","message":"","markdown_message":"","automated_response":false,"created_at":"2017-12-19T20:11:04.439Z","updated_at":"2017-12-19T20:11:04.439Z","actor":{"username":"edoverflow","cleared":true,"url":"/edoverflow","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/116/374/9a3cf4d62b2f507a0d33808aacbad863ec4455ac_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ed","actor_is_team_member":true,"actor_is_concealed_member":false}],"activity_page_count":1,"activity_page_number":1,"summaries":[{"category":"team","can_view?":true,"can_create?":false},{"category":"researcher","can_view?":true,"can_create?":false}]}