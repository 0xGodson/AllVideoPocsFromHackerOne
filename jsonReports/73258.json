{"id":73258,"global_id":"Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC83MzI1OA==","url":"https://hackerone.com/reports/73258","title":"Python: imageop Unsafe Arithmetic","state":"Closed","substate":"resolved","readable_substate":"Resolved","created_at":"2015-05-22T00:00:00.000Z","submitted_at":"2015-05-22T00:00:00.000Z","is_member_of_team?":false,"reporter":{"disabled":false,"username":"johnleitch","url":"/johnleitch","profile_picture_urls":{"small":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"is_me?":false,"cleared":false,"hackerone_triager":false,"hacker_mediation":false},"team":{"id":27,"url":"https://hackerone.com/ibb-python","handle":"ibb-python","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/000/027/c46b79d4c73a7b34d61a717ed19ae719a0b67b2e_original.png/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a","medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/027/c46b79d4c73a7b34d61a717ed19ae719a0b67b2e_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"permissions":[],"submission_state":"open","default_currency":"usd","awards_miles":false,"offers_bounties":true,"state":"public_mode","only_cleared_hackers":false,"profile":{"name":"Python (IBB)","twitter_handle":"","website":"http://www.python.org/news/security","about":""}},"has_bounty?":true,"in_validation?":false,"rejected_anc_report_that_can_be_sent_back_to_anc_triagers?":false,"can_view_team":true,"can_view_report":true,"is_external_bug":false,"is_published":false,"is_participant":false,"stage":4,"public":true,"visibility":"full","cve_ids":[],"singular_disclosure_disabled":false,"disclosed_at":"2015-05-31T00:00:00.000Z","bug_reporter_agreed_on_going_public_at":null,"team_member_agreed_on_going_public_at":"2015-05-31T00:00:00.000Z","comments_closed?":false,"facebook_team?":false,"team_private?":false,"vulnerability_information":"http://bugs.python.org/issue24264\n\n----\n\nSeveral functions within the imageop module are vulnerable to exploitable buffer overflows due to unsafe arithmetic in check_multiply_size(). The problem exists because the check to confirm that size == product / y / x does not take remainders into account.\n\n```\nstatic int\ncheck_multiply_size(int product, int x, const char* xname, int y, const char* yname, int size)\n{\n    if ( !check_coordonnate(x, xname) )\n        return 0;\n    if ( !check_coordonnate(y, yname) )\n        return 0;\n    if ( size == (product / y) / x )\n        return 1;\n    PyErr_SetString(ImageopError, \"String has incorrect length\");\n    return 0;\n}\n```\n\nConsider a call to check_multiply_size() where product is 16, x is 1, and y is 9. In the Windows x86 release of Python 2.7.9, the division is performed using the idiv instruction:\n\n```\n0:000\u003e dV\n        product = 0n16\n              x = 0n1\n          xname = 0x1e1205a4 \"x\"\n              y = 0n9\n          yname = 0x1e127ab8 \"y\"\n           size = 0n1\n0:000\u003e u eip\npython27!check_multiply_size+0x25 [c:\\build27\\cpython\\modules\\imageop.c @ 53]:\n1e0330e5 f7ff            idiv    eax,edi\n1e0330e7 99              cdq\n1e0330e8 f7fe            idiv    eax,esi\n1e0330ea 3944240c        cmp     dword ptr [esp+0Ch],eax\n1e0330ee 7506            jne     python27!check_multiply_size+0x36 (1e0330f6)\n1e0330f0 b801000000      mov     eax,1\n1e0330f5 c3              ret\n1e0330f6 8b15e47e241e    mov     edx,dword ptr [python27!ImageopError (1e247ee4)]\n0:000\u003e ?eax\nEvaluate expression: 16 = 00000010\n0:000\u003e ?edi\nEvaluate expression: 9 = 00000009\n```\n\nWhen the first idiv instruction is executed, the result (eax) is 1 with a remainder of 7 (edx):\n\n```\n0:000\u003e p\neax=00000001 ebx=00000000 ecx=1e127ab8 edx=00000007 esi=00000001 edi=00000009\neip=1e0330e7 esp=0027fcec ebp=00000001 iopl=0         nv up ei pl nz na po nc\ncs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202\npython27!check_multiply_size+0x27:\n1e0330e7 99              cdq\n0:000\u003e ?eax\nEvaluate expression: 1 = 00000001\n0:000\u003e ?edx\nEvaluate expression: 7 = 00000007\n```\n\nBecause size is 1, the check passes:\n\n```\nBreakpoint 4 hit\neax=00000001 ebx=00000000 ecx=1e127ab8 edx=00000000 esi=00000001 edi=00000009\neip=1e0330f0 esp=0027fcec ebp=00000001 iopl=0         nv up ei pl zr na pe nc\ncs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246\npython27!check_multiply_size+0x30:\n1e0330f0 b801000000      mov     eax,1\n```\n\nThis is problematic because some of the imageop functions, such as grey2rgb, utilize check_multiply_size() to check divisibility prior to copying data into a buffer. Consider a call to grey2rgb where x is 1, y is 9, and len is 16.\n\n```\nstatic PyObject *\nimageop_grey2rgb(PyObject *self, PyObject *args)\n{\n    int x, y, len, nlen; \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c x = 1, y = 9, and len = 16.\n    unsigned char *cp;\n    unsigned char *ncp;\n    PyObject *rv;\n    int i;\n    unsigned char value;\n    int backward_compatible = imageop_backward_compatible();\n\n    if ( !PyArg_ParseTuple(args, \"s#ii\", \u0026cp, \u0026len, \u0026x, \u0026y) )\n        return 0;\n\n    if ( !check_multiply(len, x, y) ) \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c 16 != 1 * 9, but this check still passes.\n        return 0;\n    nlen = x*y*4; \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c 1 * 9 * 4 == 36.\n    if ( !check_multiply_size(nlen, x, \"x\", y, \"y\", 4) )\n        return 0;\n\n    rv = PyString_FromStringAndSize(NULL, nlen); \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c This creates a buffer of length 36.\n    if ( rv == 0 )\n        return 0;\n    ncp = (unsigned char *)PyString_AsString(rv); \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c This retrieves the buffer of length 36.\n\n    for ( i=0; i \u003c len; i++ ) { \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c This loop assumes that len * 4 == nlen, which is incorrect\n                                         in this case.\n        value = *cp++;\n        if (backward_compatible) {\n            VVVVVVVV Each iteration copies 4 bytes into the 36 byte buffer pointed to by ncp and \n                     advances the pointer by 4. Because len is 16, 64 bytes are ultimately copied\n                     into the buffer, leading to an exploitable buffer overflow condition.\n            * (Py_UInt32 *) ncp = (Py_UInt32) value | ((Py_UInt32) value \u003c\u003c 8 ) | ((Py_UInt32) value \u003c\u003c 16);\n            ncp += 4;\n        } else {\n            *ncp++ = 0;\n            *ncp++ = value;\n            *ncp++ = value;\n            *ncp++ = value;\n        }\n    }\n    return rv;\n}\n```\n\nWhen the call completes, memory has been corrupted:\n\n```\n0:000\u003e g\n(12f4.640): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=00444444 ebx=00000001 ecx=1e201d98 edx=00303030 esi=1e201d98 edi=1e201d98\neip=1e031fc6 esp=0027fe7c ebp=00000002 iopl=0         nv up ei ng nz ac pe cy\ncs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010297\npython27!update_refs+0x6:\n1e031fc6 8b5010          mov     edx,dword ptr [eax+10h] ds:002b:00444454=????????\n0:000\u003e g\n(12f4.640): Access violation - code c0000005 (!!! second chance !!!)\neax=00444444 ebx=00000001 ecx=1e201d98 edx=00303030 esi=1e201d98 edi=1e201d98\neip=1e031fc6 esp=0027fe7c ebp=00000002 iopl=0         nv up ei ng nz ac pe cy\ncs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010297\npython27!update_refs+0x6:\n1e031fc6 8b5010          mov     edx,dword ptr [eax+10h] ds:002b:00444454=????????\n```\n\nDuring fuzzing, DEP access violations were encountered, so it should be assumed that this vulnerability can be exploited to achieve arbitrary code execution. To fix this vulnerability, it is recommended that check_multiply_size() confirm divisibility.\n","vulnerability_information_html":"\u003cp\u003e\u003ca title=\"http://bugs.python.org/issue24264\" href=\"/redirect?url=http%3A%2F%2Fbugs.python.org%2Fissue24264\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttp://bugs.python.org/issue24264\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003chr\u003e\n\n\u003cp\u003eSeveral functions within the imageop module are vulnerable to exploitable buffer overflows due to unsafe arithmetic in check_multiply_size(). The problem exists because the check to confirm that size == product / y / x does not take remainders into account.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003estatic int\ncheck_multiply_size(int product, int x, const char* xname, int y, const char* yname, int size)\n{\n    if ( !check_coordonnate(x, xname) )\n        return 0;\n    if ( !check_coordonnate(y, yname) )\n        return 0;\n    if ( size == (product / y) / x )\n        return 1;\n    PyErr_SetString(ImageopError, \u0026quot;String has incorrect length\u0026quot;);\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eConsider a call to check_multiply_size() where product is 16, x is 1, and y is 9. In the Windows x86 release of Python 2.7.9, the division is performed using the idiv instruction:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e0:000\u0026gt; dV\n        product = 0n16\n              x = 0n1\n          xname = 0x1e1205a4 \u0026quot;x\u0026quot;\n              y = 0n9\n          yname = 0x1e127ab8 \u0026quot;y\u0026quot;\n           size = 0n1\n0:000\u0026gt; u eip\npython27!check_multiply_size+0x25 [c:\\build27\\cpython\\modules\\imageop.c @ 53]:\n1e0330e5 f7ff            idiv    eax,edi\n1e0330e7 99              cdq\n1e0330e8 f7fe            idiv    eax,esi\n1e0330ea 3944240c        cmp     dword ptr [esp+0Ch],eax\n1e0330ee 7506            jne     python27!check_multiply_size+0x36 (1e0330f6)\n1e0330f0 b801000000      mov     eax,1\n1e0330f5 c3              ret\n1e0330f6 8b15e47e241e    mov     edx,dword ptr [python27!ImageopError (1e247ee4)]\n0:000\u0026gt; ?eax\nEvaluate expression: 16 = 00000010\n0:000\u0026gt; ?edi\nEvaluate expression: 9 = 00000009\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWhen the first idiv instruction is executed, the result (eax) is 1 with a remainder of 7 (edx):\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e0:000\u0026gt; p\neax=00000001 ebx=00000000 ecx=1e127ab8 edx=00000007 esi=00000001 edi=00000009\neip=1e0330e7 esp=0027fcec ebp=00000001 iopl=0         nv up ei pl nz na po nc\ncs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202\npython27!check_multiply_size+0x27:\n1e0330e7 99              cdq\n0:000\u0026gt; ?eax\nEvaluate expression: 1 = 00000001\n0:000\u0026gt; ?edx\nEvaluate expression: 7 = 00000007\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eBecause size is 1, the check passes:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003eBreakpoint 4 hit\neax=00000001 ebx=00000000 ecx=1e127ab8 edx=00000000 esi=00000001 edi=00000009\neip=1e0330f0 esp=0027fcec ebp=00000001 iopl=0         nv up ei pl zr na pe nc\ncs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246\npython27!check_multiply_size+0x30:\n1e0330f0 b801000000      mov     eax,1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis is problematic because some of the imageop functions, such as grey2rgb, utilize check_multiply_size() to check divisibility prior to copying data into a buffer. Consider a call to grey2rgb where x is 1, y is 9, and len is 16.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003estatic PyObject *\nimageop_grey2rgb(PyObject *self, PyObject *args)\n{\n    int x, y, len, nlen; \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; x = 1, y = 9, and len = 16.\n    unsigned char *cp;\n    unsigned char *ncp;\n    PyObject *rv;\n    int i;\n    unsigned char value;\n    int backward_compatible = imageop_backward_compatible();\n\n    if ( !PyArg_ParseTuple(args, \u0026quot;s#ii\u0026quot;, \u0026amp;cp, \u0026amp;len, \u0026amp;x, \u0026amp;y) )\n        return 0;\n\n    if ( !check_multiply(len, x, y) ) \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; 16 != 1 * 9, but this check still passes.\n        return 0;\n    nlen = x*y*4; \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; 1 * 9 * 4 == 36.\n    if ( !check_multiply_size(nlen, x, \u0026quot;x\u0026quot;, y, \u0026quot;y\u0026quot;, 4) )\n        return 0;\n\n    rv = PyString_FromStringAndSize(NULL, nlen); \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; This creates a buffer of length 36.\n    if ( rv == 0 )\n        return 0;\n    ncp = (unsigned char *)PyString_AsString(rv); \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; This retrieves the buffer of length 36.\n\n    for ( i=0; i \u0026lt; len; i++ ) { \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; This loop assumes that len * 4 == nlen, which is incorrect\n                                         in this case.\n        value = *cp++;\n        if (backward_compatible) {\n            VVVVVVVV Each iteration copies 4 bytes into the 36 byte buffer pointed to by ncp and \n                     advances the pointer by 4. Because len is 16, 64 bytes are ultimately copied\n                     into the buffer, leading to an exploitable buffer overflow condition.\n            * (Py_UInt32 *) ncp = (Py_UInt32) value | ((Py_UInt32) value \u0026lt;\u0026lt; 8 ) | ((Py_UInt32) value \u0026lt;\u0026lt; 16);\n            ncp += 4;\n        } else {\n            *ncp++ = 0;\n            *ncp++ = value;\n            *ncp++ = value;\n            *ncp++ = value;\n        }\n    }\n    return rv;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWhen the call completes, memory has been corrupted:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e0:000\u0026gt; g\n(12f4.640): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=00444444 ebx=00000001 ecx=1e201d98 edx=00303030 esi=1e201d98 edi=1e201d98\neip=1e031fc6 esp=0027fe7c ebp=00000002 iopl=0         nv up ei ng nz ac pe cy\ncs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010297\npython27!update_refs+0x6:\n1e031fc6 8b5010          mov     edx,dword ptr [eax+10h] ds:002b:00444454=????????\n0:000\u0026gt; g\n(12f4.640): Access violation - code c0000005 (!!! second chance !!!)\neax=00444444 ebx=00000001 ecx=1e201d98 edx=00303030 esi=1e201d98 edi=1e201d98\neip=1e031fc6 esp=0027fe7c ebp=00000002 iopl=0         nv up ei ng nz ac pe cy\ncs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010297\npython27!update_refs+0x6:\n1e031fc6 8b5010          mov     edx,dword ptr [eax+10h] ds:002b:00444454=????????\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eDuring fuzzing, DEP access violations were encountered, so it should be assumed that this vulnerability can be exploited to achieve arbitrary code execution. To fix this vulnerability, it is recommended that check_multiply_size() confirm divisibility.\u003c/p\u003e\n","bounty_amount":"1000.0","formatted_bounty":"$1,000","original_report_id":null,"original_report_url":null,"attachments":[],"allow_singular_disclosure_at":null,"vote_count":0,"voters":[],"structured_scope":null,"abilities":{"assignable_team_members":[],"assignable_team_member_groups":[]},"can_edit_custom_fields_attributes":false,"activities":[{"id":496271,"is_internal":false,"editable":false,"type":"Activities::BountyAwarded","message":"","markdown_message":"","automated_response":false,"created_at":"2015-06-30T11:45:48.095Z","updated_at":"2015-06-30T11:45:48.095Z","actor":{"url":"/ibb-python","ibb":true,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/027/c46b79d4c73a7b34d61a717ed19ae719a0b67b2e_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"Python (IBB)"}},"bounty_amount":"1000.0","bounty_currency":"usd","genius_execution_id":null,"team_handle":"ibb-python","collaborator":{"username":"johnleitch","url":"/johnleitch"},"actor_is_team_member":false,"actor_is_concealed_member":false},{"id":1196233,"is_internal":false,"editable":false,"type":"Activities::BugResolved","message":null,"markdown_message":"","automated_response":false,"created_at":"2015-06-30T11:45:48.095Z","updated_at":"2016-09-15T13:29:46.387Z","actor":{"url":"/ibb-python","ibb":true,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/027/c46b79d4c73a7b34d61a717ed19ae719a0b67b2e_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"Python (IBB)"}},"reporter":{"username":"johnleitch","url":"/johnleitch"},"genius_execution_id":null,"team_handle":"ibb-python","actor_is_team_member":false,"actor_is_concealed_member":false}],"activity_page_count":1,"activity_page_number":1,"summaries":[{"category":"team","can_view?":true,"can_create?":false},{"category":"researcher","can_view?":true,"can_create?":false}]}