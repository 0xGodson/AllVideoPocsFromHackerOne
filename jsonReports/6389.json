{"id":6389,"global_id":"Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC82Mzg5","url":"https://hackerone.com/reports/6389","title":"Integer overflow in strop.expandtabs","state":"Closed","substate":"resolved","readable_substate":"Resolved","created_at":"2014-03-31T00:09:44.000Z","submitted_at":"2014-03-31T00:09:44.000Z","is_member_of_team?":false,"reporter":{"disabled":false,"username":"ianbeer","url":"/ianbeer","profile_picture_urls":{"small":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"is_me?":false,"cleared":false,"hackerone_triager":false,"hacker_mediation":false},"team":{"id":27,"url":"https://hackerone.com/ibb-python","handle":"ibb-python","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/000/027/c46b79d4c73a7b34d61a717ed19ae719a0b67b2e_original.png/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a","medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/027/c46b79d4c73a7b34d61a717ed19ae719a0b67b2e_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"permissions":[],"submission_state":"open","default_currency":"usd","awards_miles":false,"offers_bounties":true,"state":"public_mode","only_cleared_hackers":false,"profile":{"name":"Python (IBB)","twitter_handle":"","website":"http://www.python.org/news/security","about":""}},"has_bounty?":true,"in_validation?":false,"rejected_anc_report_that_can_be_sent_back_to_anc_triagers?":false,"can_view_team":true,"can_view_report":true,"is_external_bug":false,"is_published":false,"is_participant":false,"stage":4,"public":true,"visibility":"full","cve_ids":[],"singular_disclosure_disabled":false,"disclosed_at":"2014-03-31T00:09:44.000Z","bug_reporter_agreed_on_going_public_at":null,"team_member_agreed_on_going_public_at":"2014-03-31T00:09:44.000Z","comments_closed?":false,"facebook_team?":false,"team_private?":false,"vulnerability_information":"*This issue was originally disclosed directly to the Python Security Response Team*\n\nHere's a bug in a string handling function which might be reachable in some \"sandboxed python\" environments, and maybe (at a stretch) remotely if someone were to offer \"expanding-tabs-in-strings\"-as-a-service...\n\n# Bug:\n\nModules/stropmodule.c\n\n```\nstatic PyObject *\nstrop_expandtabs(PyObject *self, PyObject *args)\n...\n  i = j = old_j = 0;\n  e = string + stringlen;\n  for (p = string; p \u003c e; p++) {\n      if (*p == '\\t') {\n          j += tabsize - (j%tabsize);\n          if (old_j \u003e j) {\n              PyErr_SetString(PyExc_OverflowError,\n                              \"new string is too long\");\n              return NULL;\n          }\n          old_j = j;\n      } else {\n          j++;\n          if (*p == '\\n') {\n              i += j;               \u003c-- missing check here\n              j = 0;\n          }\n      }\n  }\n...\n  out = PyString_FromStringAndSize(NULL, i+j);\n...\n  i = 0;\n  q = PyString_AS_STRING(out);\n\n  for (p = string; p \u003c e; p++) {\n      if (*p == '\\t') {\n          j = tabsize - (i%tabsize);\n          i += j;\n          while (j-- \u003e 0)\n              *q++ = ' ';\n      } else {\n          *q++ = *p;\n          i++;\n          if (*p == '\\n')\n              i = 0;\n      }\n  }\n...\n```\n\nThere's no check preventing i from overflowing, meaning that a string consisting of multiple tabs spread over multiple lines combined with a large tabsize can cause the allocation of an undersized string buffer.\n\nWith some simple heap manipulation the length of the copy into this buffer can be controlled, and it's pretty easy to corrupt memory in such a way as to gain native code execution:\n\n[h1|----------][h2|\\t\\n\\t\\n....][h3|----------]\n\nh1: PyStringObject header of undersized buffer\nh2: PyStringObject header of tabstring\n\nBy grooming the heap such that this allocation pattern is achieved when the expandtabs function starts expanding the h2 string into the h1 inline buffer it will overflow into the string being expanded, overwriting the tabs in the original string with spaces so that the second loop won't expand them anymore.\n\nBy carefully crafting the string to expand and choosing the tabsize you can limit the extent of the memory corruption to chosen objects.\n\nGetting code execution is simply a matter of pointing the ob_type field of the h2 string header to a controlled address with a fake struct _typeobject. The struct contains the following function pointers which will be called when their corresponing python function is called:\n\n  destructor tp_dealloc;\n  printfunc tp_print;\n  getattrfunc tp_getattr;\n  setattrfunc tp_setattr;\n  cmpfunc tp_compare;\n  reprfunc tp_repr;\n\n# Patch:\n\nYou've actually already patched this bug in a copy-and-paste version of this function... In fact there seem to be at least three versions of expandtabs; transmogrify.h and stropmodule.c are both vulnerable; stringobject.c isn't. I'm not familiar enough with the code to know when each version will be used.\n\nThe patch is to use the stringobject.c implementation which does the overflow check correctly, but here's a quick patch (for the 2.7 branch) which will do the job:\n\n```\n--- a/Modules/stropmodule.c Sun Mar 30 16:43:11 2014 -0400\n+++ b/Modules/stropmodule.c Mon Mar 31 00:36:57 2014 +0200\n@@ -624,6 +624,11 @@\n         } else {\n             j++;\n             if (*p == '\\n') {\n+                if (i \u003e PY_SSIZE_T_MAX - j){\n+                    PyErr_SetString(PyExc_OverflowError,\n+                                    \"new string is too long\");\n+                    return NULL;\n+                }\n                 i += j;\n                 j = 0;\n             }\n```\n\n# Proof of Concept\n\nRun this script for a very simple crashing PoC for 32-bit python 2.7 which should crash at at address near 0x20202020 (since the ob_type field will be overwritten with spaces.) No idea if the heap manipulation used here will work on other platforms but it should be easy to do.\n\n```lang=python\nimport strop\n\nstrs = []\nfor i in range(20):\n  strs.append('\\t\\n' * 0x10000 + 'A' * 0x1000000)\nfor i in range(20):\n  print hex(id(strs[i]))\nstrs[14] = None\nstrop.expandtabs(strs[15], 0x10001)\nprint strs[15]\n```\n","vulnerability_information_html":"\u003cp\u003e\u003cem\u003eThis issue was originally disclosed directly to the Python Security Response Team\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eHere\u0026#39;s a bug in a string handling function which might be reachable in some \u0026quot;sandboxed python\u0026quot; environments, and maybe (at a stretch) remotely if someone were to offer \u0026quot;expanding-tabs-in-strings\u0026quot;-as-a-service...\u003c/p\u003e\n\n\u003ch1 id=\"bug\"\u003eBug:\u003c/h1\u003e\n\n\u003cp\u003eModules/stropmodule.c\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003estatic PyObject *\nstrop_expandtabs(PyObject *self, PyObject *args)\n...\n  i = j = old_j = 0;\n  e = string + stringlen;\n  for (p = string; p \u0026lt; e; p++) {\n      if (*p == \u0026#39;\\t\u0026#39;) {\n          j += tabsize - (j%tabsize);\n          if (old_j \u0026gt; j) {\n              PyErr_SetString(PyExc_OverflowError,\n                              \u0026quot;new string is too long\u0026quot;);\n              return NULL;\n          }\n          old_j = j;\n      } else {\n          j++;\n          if (*p == \u0026#39;\\n\u0026#39;) {\n              i += j;               \u0026lt;-- missing check here\n              j = 0;\n          }\n      }\n  }\n...\n  out = PyString_FromStringAndSize(NULL, i+j);\n...\n  i = 0;\n  q = PyString_AS_STRING(out);\n\n  for (p = string; p \u0026lt; e; p++) {\n      if (*p == \u0026#39;\\t\u0026#39;) {\n          j = tabsize - (i%tabsize);\n          i += j;\n          while (j-- \u0026gt; 0)\n              *q++ = \u0026#39; \u0026#39;;\n      } else {\n          *q++ = *p;\n          i++;\n          if (*p == \u0026#39;\\n\u0026#39;)\n              i = 0;\n      }\n  }\n...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThere\u0026#39;s no check preventing i from overflowing, meaning that a string consisting of multiple tabs spread over multiple lines combined with a large tabsize can cause the allocation of an undersized string buffer.\u003c/p\u003e\n\n\u003cp\u003eWith some simple heap manipulation the length of the copy into this buffer can be controlled, and it\u0026#39;s pretty easy to corrupt memory in such a way as to gain native code execution:\u003c/p\u003e\n\n\u003cp\u003e[h1|----------][h2|\\t\\n\\t\\n....][h3|----------]\u003c/p\u003e\n\n\u003cp\u003eh1: PyStringObject header of undersized buffer\u003cbr\u003e\nh2: PyStringObject header of tabstring\u003c/p\u003e\n\n\u003cp\u003eBy grooming the heap such that this allocation pattern is achieved when the expandtabs function starts expanding the h2 string into the h1 inline buffer it will overflow into the string being expanded, overwriting the tabs in the original string with spaces so that the second loop won\u0026#39;t expand them anymore.\u003c/p\u003e\n\n\u003cp\u003eBy carefully crafting the string to expand and choosing the tabsize you can limit the extent of the memory corruption to chosen objects.\u003c/p\u003e\n\n\u003cp\u003eGetting code execution is simply a matter of pointing the ob_type field of the h2 string header to a controlled address with a fake struct _typeobject. The struct contains the following function pointers which will be called when their corresponing python function is called:\u003c/p\u003e\n\n\u003cp\u003edestructor tp_dealloc;\u003cbr\u003e\n  printfunc tp_print;\u003cbr\u003e\n  getattrfunc tp_getattr;\u003cbr\u003e\n  setattrfunc tp_setattr;\u003cbr\u003e\n  cmpfunc tp_compare;\u003cbr\u003e\n  reprfunc tp_repr;\u003c/p\u003e\n\n\u003ch1 id=\"patch\"\u003ePatch:\u003c/h1\u003e\n\n\u003cp\u003eYou\u0026#39;ve actually already patched this bug in a copy-and-paste version of this function... In fact there seem to be at least three versions of expandtabs; transmogrify.h and stropmodule.c are both vulnerable; stringobject.c isn\u0026#39;t. I\u0026#39;m not familiar enough with the code to know when each version will be used.\u003c/p\u003e\n\n\u003cp\u003eThe patch is to use the stringobject.c implementation which does the overflow check correctly, but here\u0026#39;s a quick patch (for the 2.7 branch) which will do the job:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight diff\"\u003e\u003ccode\u003e\u003cspan class=\"gd\"\u003e--- a/Modules/stropmodule.c Sun Mar 30 16:43:11 2014 -0400\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+++ b/Modules/stropmodule.c Mon Mar 31 00:36:57 2014 +0200\n\u003c/span\u003e\u003cspan class=\"p\"\u003e@@ -624,6 +624,11 @@\u003c/span\u003e\n         } else {\n             j++;\n             if (*p == \u0026#39;\\n\u0026#39;) {\n\u003cspan class=\"gi\"\u003e+                if (i \u0026gt; PY_SSIZE_T_MAX - j){\n+                    PyErr_SetString(PyExc_OverflowError,\n+                                    \u0026quot;new string is too long\u0026quot;);\n+                    return NULL;\n+                }\n\u003c/span\u003e                 i += j;\n                 j = 0;\n             }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch1 id=\"proof-of-concept\"\u003eProof of Concept\u003c/h1\u003e\n\n\u003cp\u003eRun this script for a very simple crashing PoC for 32-bit python 2.7 which should crash at at address near 0x20202020 (since the ob_type field will be overwritten with spaces.) No idea if the heap manipulation used here will work on other platforms but it should be easy to do.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003eimport strop\n\nstrs = []\nfor i in range(20):\n  strs.append(\u0026#39;\\t\\n\u0026#39; * 0x10000 + \u0026#39;A\u0026#39; * 0x1000000)\nfor i in range(20):\n  print hex(id(strs[i]))\nstrs[14] = None\nstrop.expandtabs(strs[15], 0x10001)\nprint strs[15]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","bounty_amount":"1500.0","formatted_bounty":"$1,500","original_report_id":null,"original_report_url":null,"attachments":[],"allow_singular_disclosure_at":null,"vote_count":2,"voters":["mygk","hasskodark"],"structured_scope":null,"abilities":{"assignable_team_members":[],"assignable_team_member_groups":[]},"can_edit_custom_fields_attributes":false,"activities":[{"id":26154,"is_internal":false,"editable":false,"type":"Activities::BountyAwarded","message":"Thanks Ian, we always appreciate fantastic detailed write-ups like this. We're awarding the minimum bounty because it's a relatively low severity issue (a rather obscure code path in a nearly obsolete module).\r\n\r\nResolved in the upcoming 2.7.7 release: http://hg.python.org/cpython/rev/5dabc2d2f776","markdown_message":"\u003cp\u003eThanks Ian, we always appreciate fantastic detailed write-ups like this. We\u0026#39;re awarding the minimum bounty because it\u0026#39;s a relatively low severity issue (a rather obscure code path in a nearly obsolete module).\u003c/p\u003e\n\n\u003cp\u003eResolved in the upcoming 2.7.7 release: \u003ca title=\"http://hg.python.org/cpython/rev/5dabc2d2f776\" href=\"/redirect?url=http%3A%2F%2Fhg.python.org%2Fcpython%2Frev%2F5dabc2d2f776\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttp://hg.python.org/cpython/rev/5dabc2d2f776\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/p\u003e\n","automated_response":false,"created_at":"2014-04-08T04:11:53.769Z","updated_at":"2014-04-08T04:11:53.769Z","actor":{"url":"/ibb-python","ibb":true,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/027/c46b79d4c73a7b34d61a717ed19ae719a0b67b2e_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"Python (IBB)"}},"bounty_amount":"1500.0","bounty_currency":"usd","genius_execution_id":null,"team_handle":"ibb-python","collaborator":{"username":"ianbeer","url":"/ianbeer"},"actor_is_team_member":false,"actor_is_concealed_member":false},{"id":1196014,"is_internal":false,"editable":false,"type":"Activities::BugResolved","message":null,"markdown_message":"","automated_response":false,"created_at":"2014-04-08T15:23:28.299Z","updated_at":"2016-09-15T13:28:31.009Z","actor":{"url":"/ibb-python","ibb":true,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/027/c46b79d4c73a7b34d61a717ed19ae719a0b67b2e_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"Python (IBB)"}},"reporter":{"username":"ianbeer","url":"/ianbeer"},"genius_execution_id":null,"team_handle":"ibb-python","actor_is_team_member":false,"actor_is_concealed_member":false}],"activity_page_count":1,"activity_page_number":1,"summaries":[{"category":"team","can_view?":true,"can_create?":false},{"category":"researcher","can_view?":true,"can_create?":false}]}